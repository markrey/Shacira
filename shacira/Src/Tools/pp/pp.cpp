

/// PR 13.06.14 - created version 2.0.0:
///               removed compatibility code to old preprocessor
///               added new code for detection of qt version (see _PPUsage)
///               changes through preprocessor definition VERSION_2
///               detection mechanism::
///               if QT3Framework or QT4Framework are part of the input file path:
///                 detected version is 3 or 4 respective no more tests
///               if -qtdir<path> is specified:
///                 if path is empty copy value of environment variable QTDIR to path
///                   if path contains Qt<digit> or Qt.<digit
///                      version is value of digit
///               version is undetected
/// PR 24.09.14 - created version 2.1.0:
///               added compatibility to old preprocessor specifications of VCPNet


#define MAJOR_VERSION         2
#define MINOR_VERSION         1
#define BUGFIX_VERSION        1
#define PP_VERSION            ((MAJOR_VERSION*10000)+(INOR_VERSION*100)+(BUGFIX_VERSION))

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
using namespace std;

#if (MAJOR_VERSION < 2)
static int _QtVersion = 3;
static bool _Qt4Adaptions = false;
int AdjustQtVersion(int qt_version, const char * input_file, const char * qtDirEnv);
#else
static int _QtVersion = 0;
static char _ppFile[0x200] = {0};
static char _outputFile[0x200] = {0};
const char * _PPUsage =
   "usage pp input_file [OPTIONS]\n"
   "OPTIONS:\n"
   "   -qtdir<path>      evaluate supplied parameter path\n"
   "                     evaluate environment variable QTDIR if supplied parameter is empty\n"
   "   -o                output file (stdout, if not supplied)\n";
bool AnalyzeCommandLine(int argc, char ** argv, const char * & input_file, const char * & output_file, int & global_qt_version);
#endif

void PrintCmdLine(int argc, char ** argv);
void PrintEnvironment();

typedef struct _var_ref {
   char name[0x200];
}  VAR_REF_T;
typedef struct _func_ref {
   char name[0x200];
}  FUNC_REF_T;
typedef struct _property {
   char type[0x200];
   char name[0x200];
}  PROPERTY_T;

#define TAB_SIZE 0x500
static unsigned long _ActVarRef = 0;
static unsigned long _ActProperty = 0;
static unsigned long _ActFuncRef = 0;
static VAR_REF_T _VarRefTab[TAB_SIZE] = {0};
static FUNC_REF_T _FuncRefTab[TAB_SIZE] = {0};
static PROPERTY_T _PropertyTab[TAB_SIZE] = {0};

static int SearchFor(const char * str, const char * s_str)
{
   int s_len = strlen(s_str);
   const char * s_ptr = str;
   int s_end = strlen(str) - s_len;
   if (s_end < 0) {
      return -1;
   }
   int i = 0;
   for (i=0; i<s_end; i++) {
      if (strncmp(s_ptr, s_str, s_len) == 0) {
         return i;
      }
      s_ptr++;
   }
   return -1;
}

static void AddProperty(const char * type, const char * name)
{
   strcpy(_PropertyTab[_ActProperty].type, type);
   strcpy(_PropertyTab[_ActProperty].name, name);
   _ActProperty++;
}

static void AddVarRef(const char * name)
{
   strcpy(_VarRefTab[_ActVarRef].name, name);
   _ActVarRef++;
}

static void AddFuncRef(const char * name)
{
   strcpy(_FuncRefTab[_ActFuncRef].name, name);
   _ActFuncRef++;
}

static void PrintComment(FILE * ofile, const char * comment)
{
   fprintf(ofile, "\t/*! \\brief\n");
   fprintf(ofile, "\t * %s", comment);
   fprintf(ofile, "\t */\n");
}

void PrintEnvironment()
{
   const char * qtdir = getenv("QTDIR");
   if (qtdir == NULL) {
      fprintf(stderr, "QTDIR not set\n");
   } else {
      fprintf(stderr, "QTDIR=%s\n", qtdir);
   }
   const char * qtvariant = getenv("QTVARIANT");
   if (qtvariant == NULL) {
      fprintf(stderr, "QTVARIANT not set\n");
   } else {
      fprintf(stderr, "QTVARIANT=%s\n", qtvariant);
   }
}

static void PrintAttributes(FILE * ofile)
{
static bool attributes_printed = false;
   if (!attributes_printed) {
      unsigned int i = 0;
      for (i=0; i<_ActProperty; i++) {
         const char * p_name = _PropertyTab[i].name;
         const char * p_type = _PropertyTab[i].type;
         PrintComment(ofile, "this is a member variable generated by pp\n");
         fprintf(ofile, "\t%s _%sValue;\n", p_type, p_name);
      }
      for (i=0; i<_ActVarRef; i++) {
         const char * p_name = _VarRefTab[i].name;
         PrintComment(ofile, "this is a member variable generated by pp\n");
         if (_QtVersion > 3) {
            fprintf(ofile, "\tQByteArray\t_%sSpec;\n", p_name);
         } else {
            fprintf(ofile, "\tQCString\t_%sSpec;\n", p_name);
         }
         PrintComment(ofile, "this is a member variable generated by pp\n");
         fprintf(ofile, "\tVAR_REF_PTR\t_%sRef;\n", p_name);
         PrintComment(ofile, "this is a member variable generated by pp\n");
         fprintf(ofile, "\tDATA_VIEW_PTR\t_%sView;\n", p_name);
      }
      for (i=0; i<_ActFuncRef; i++) {
         const char * p_name = _FuncRefTab[i].name;
         PrintComment(ofile, "this is a member variable generated by pp\n");
         if (_QtVersion > 3) {
            fprintf(ofile, "\tQByteArray\t_%sSpec;\n", p_name);
         } else {
            fprintf(ofile, "\tQCString\t_%sSpec;\n", p_name);
         }
         PrintComment(ofile, "this is a member variable generated by pp\n");
         fprintf(ofile, "\tFUNC_REF_PTR\t_%sRef;\n", p_name);
      }
      attributes_printed = true;
   }
}

static void PrintMethods(FILE * ofile)
{
static bool methods_printed = false;
   if (!methods_printed) {
      unsigned int i = 0;
      for (i=0; i<_ActProperty; i++) {
         const char * p_name = _PropertyTab[i].name;
         const char * p_type = _PropertyTab[i].type;
         PrintComment(ofile, "this is a setter method generated by pp\n");
         fprintf(ofile, "\tvoid set%s(const %s &value) { _%sValue = value; PropertyChanged(); }\n", p_name, p_type, p_name);
         PrintComment(ofile, "this is a getter method generated by pp\n");
         fprintf(ofile, "\t%s get%s() const { return _%sValue; }\n\n", p_type, p_name, p_name);
      }
      for (i=0; i<_ActVarRef; i++) {
         const char * p_name = _VarRefTab[i].name;
         PrintComment(ofile, "this is a setter method generated by pp\n");
         if (_QtVersion > 3) {
            fprintf(ofile, "\tvoid set%sRef(const QByteArray &value) { _%sSpec = value; PropertyChanged(); }\n", p_name, p_name);
         } else {
            fprintf(ofile, "\tvoid set%sRef(const QCString &value) { _%sSpec = value; PropertyChanged(); }\n", p_name, p_name);
         }
         PrintComment(ofile, "this is a getter method generated by pp\n");
         if (_QtVersion > 3) {
            fprintf(ofile, "\tQByteArray get%sRef() const { return _%sSpec; }\n\n", p_name, p_name);
         } else {
            fprintf(ofile, "\tQCString get%sRef() const { return _%sSpec; }\n\n", p_name, p_name);
         }
      }
      for (i=0; i<_ActFuncRef; i++) {
         const char * p_name = _FuncRefTab[i].name;
         PrintComment(ofile, "this is a setter method generated by pp\n");
         if (_QtVersion > 3) {
            fprintf(ofile, "\tvoid set%sRef(const QByteArray &value) { _%sSpec = value; PropertyChanged(); }\n", p_name, p_name);
         } else {
            fprintf(ofile, "\tvoid set%sRef(const QCString &value) { _%sSpec = value; PropertyChanged(); }\n", p_name, p_name);
         }
         PrintComment(ofile, "this is a getter method generated by pp\n");
         if (_QtVersion > 3) {
            fprintf(ofile, "\tQByteArray get%sRef() const { return _%sSpec; }\n\n", p_name, p_name);
         } else {
            fprintf(ofile, "\tQCString get%sRef() const { return _%sSpec; }\n\n", p_name, p_name);
         }
      }
      methods_printed = true;
   }
}

static const char * Strip(char * name)
{
   bool init = true;
   const char * name_ptr = name;
   int len = strlen(name);
   int i = 0;
   for (i=0; i<len; i++) {
      int c = name[i];
      if (init) {
         if (c == ' ') {
            name_ptr++;
         } else {
            init = false;
         }
      } else {
         if (c == ' ') {
            name[i] = '\0';
            return name_ptr;
         }
      }
   }
   return name_ptr;
}

bool LineValid(const char * line)
{
   int len = strlen(line);
   int i = 0;
   for (i=0; i<len; i++) {
      char c = line[i];
      if (c == ' ' ||
          c == '\t') {
      } else {
         if (c == 'P' ||
             c == 'A' ||
             c == 'M' ||
             c == 'F' ||
             c == 'V' ||
             c == 'B' ||
             c == 'E') {
            return true;
         } else {
            return false;
         }
      }
   }
   return false;
}

static void ProcessLine(FILE * ofile, const char * line)
{
   char type[0x100] = {0};
   char name[0x100] = {0};
   char rubbish[0x400] = {0};
   int params = 0;
   if (LineValid(line)) {
      bool is_valid_line = false;
      if ((params = sscanf(line, "%[^P]PROPERTY_2i(%[^,],%[^)])", rubbish, type, name)) == 3) {
         fprintf(ofile, "\tQ_PROPERTY(%s %s READ get%s WRITE set%s)\n",
               Strip(type),
               Strip(name),
               Strip(name),
               Strip(name));
         AddProperty(Strip(type), Strip(name));
      } else if ((params = sscanf(line, "%[^P]PROPERTY_QT4(%[^,],%[^)])", rubbish, type, name)) == 3) {
#if (MAJOR_VERSION < 2)
         if (_Qt4Adaptions) {
            string getName = Strip(name);
            string setName = "set";
            setName += getName;
            setName[3] = toupper(getName[0]);
            string memberName = "_";
            memberName += getName;
            memberName += "Value";
            fprintf(ofile, "\tQ_PROPERTY(%s %s READ %s WRITE %s)\n", Strip(type), getName.c_str(), getName.c_str(), setName.c_str());
            fprintf(ofile, "\t%s %s;\n", Strip(type), memberName.c_str());
            fprintf(ofile, "\tvoid %s(const %s &value) {%s = value; PropertyChanged();}\n", setName.c_str(), Strip(type), memberName.c_str());
            fprintf(ofile, "\t%s %s() const { return %s; }\n", Strip(type), getName.c_str(), memberName.c_str());
         }
#else
         // actually ignoring it
#endif
      } else if ((params = sscanf(line, "%[^V]VAR_REF_2i(%[^)])", rubbish, name)) == 2) {
         if (_QtVersion > 3) {
            fprintf(ofile, "\tQ_PROPERTY(QByteArray %sRef READ get%sRef WRITE set%sRef)\n",
                  Strip(name),
                  Strip(name),
                  Strip(name));
         } else {
            fprintf(ofile, "\tQ_PROPERTY(QCString %sRef READ get%sRef WRITE set%sRef)\n",
                  Strip(name),
                  Strip(name),
                  Strip(name));
         }
         AddVarRef(Strip(name));
      } else if ((params = sscanf(line, "%[^F]FUNC_REF_2i(%[^)])", rubbish, name)) == 2) {
         if (_QtVersion > 3) {
            fprintf(ofile, "\tQ_PROPERTY(QByteArray %sRef READ get%sRef WRITE set%sRef)\n",
                  Strip(name),
                  Strip(name),
                  Strip(name));
         } else {
            fprintf(ofile, "\tQ_PROPERTY(QCString %sRef READ get%sRef WRITE set%sRef)\n",
                  Strip(name),
                  Strip(name),
                  Strip(name));
         }
         AddFuncRef(Strip(name));
      } else if (SearchFor(line, "METHODS_2i") >= 0) {
//         fprintf(ofile, "\t/// start of pp generated property getter and setter methods\n");
         PrintMethods(ofile);
//         fprintf(ofile, "\t/// end of pp generated property getter and setter methods\n");
      } else if (SearchFor(line, "ATTRIBUTES_2i") >= 0) {
//         fprintf(ofile, "\t/// start of pp generated member variables\n");
         PrintAttributes(ofile);
//         fprintf(ofile, "\t/// end of pp generated member variables\n");
#if (MAJOR_VERSION < 2)
      } else if (SearchFor(line, "BEGIN_QT4_ADAPTIONS") >= 0) {
         _Qt4Adaptions = true;
      } else if (SearchFor(line, "END_QT4_ADAPTIONS") >= 0) {
         _Qt4Adaptions = false;
#else
      // actually ignoring it
#endif
      } else {
         fprintf(ofile, "%s", line);
      }
   } else {
      fprintf(ofile, "%s", line);
   }
}

static char _LineBuf[0x2000] = {0};

int main(int argc, char* argv[])
{
   fprintf(stderr, "preprocessor %d.%d.%d Copyright 2014-2015 2i Industrial Informatics GmbH\n", MAJOR_VERSION, MINOR_VERSION, BUGFIX_VERSION);
#if (MAJOR_VERSION < 2)
   int i = 0;
   char ppfile[0x100] = {0};
   char outfile[0x100] = {0};
   char QtDirEnv[0x100] = {0};
   const char * pp_file = NULL;
   const char * input_file = NULL;
   const char * output_file = NULL;
   const char * pQtDirEnv = NULL;
   for (i=1; i<argc; i++) {
      if (strncmp(argv[i], "-f", 2) == 0) {
         if (strlen(argv[i]) == 2) {
            if (i < argc) {
               i++;
               input_file = pp_file = argv[i];
            }
         } else {
            strcpy(ppfile, &(argv[i])[2]);
            input_file = pp_file = ppfile;
         }
      } else if (strncmp(argv[i], "-o", 2) == 0) {
         if (strlen(argv[i]) == 2) {
            if (i < argc) {
               i++;
               output_file = argv[i];
            }
         } else {
            strcpy(outfile, &(argv[i])[2]);
            output_file = outfile;
         }
      //} else if (strncmp(argv[i], "-qt", 3) == 0) {
      //   char qt_version[0x10] = {0};
      //   if (strlen(argv[i]) == 3) {
      //      if (i < argc) {
      //         i++;
      //         strcpy(qt_version, argv[i]);
      //      }
      //   } else {
      //      strcpy(qt_version, &(argv[i])[3]);
      //   }
      //   _QtVersion = atol(qt_version);
      //   if (_QtVersion < 3 || _QtVersion > 5) {
      //      fprintf(stderr, "invalid Qt version %d (3,4,5)\n", _QtVersion);
      //      return -1;
      //   }
      } else if (strncmp(argv[i], "-qtdir", 6) == 0) {
         if (strlen(argv[i]) == 6) {
            if (i < argc) {
               i++;
               output_file = argv[i];
            }
         } else {
            strcpy(QtDirEnv, &(argv[i])[6]);
            pQtDirEnv = QtDirEnv;
         }
      } else {
         input_file = argv[i];
      }
   }
   if (input_file == NULL) {
      fprintf(stderr, "no input file\n");
      return -1;
   }
   _QtVersion = AdjustQtVersion(_QtVersion, input_file, pQtDirEnv);
#else
   const char * input_file = NULL;
   const char * output_file = NULL;
   if (!AnalyzeCommandLine(argc, argv, input_file, output_file, _QtVersion)) {
      PrintCmdLine(argc, argv);
      fprintf(stderr, "invalid usage of pp.exe\n");
      fprintf(stderr, "%s\n", _PPUsage);
      return -1;
   }
   if (_QtVersion == 0) {
      PrintCmdLine(argc, argv);
      fprintf(stderr, "failed to detect qt version\n");
      PrintEnvironment();
      return -1;
   }
   if (input_file == NULL) {
      fprintf(stderr, "no input file\n");
      return -1;
   }
#endif
   fprintf(stderr, "used Qt version is %d\n", _QtVersion);
   FILE * ifile = fopen(input_file, "r");
   if (ifile == NULL) {
      fprintf(stderr, "cannot open input file %s\n", input_file);
      return -1;
   }
   FILE * ofile = (output_file == NULL) ? stdout : fopen(output_file, "w");
   if (ofile == NULL) {
      fprintf(stderr, "cannot open output file %s\n", output_file);
      fclose(ifile);
      return -1;
   }
   fprintf(stderr, "processing %s >> %s\n", input_file, output_file);
   char * line = 0;
   while (line = fgets(_LineBuf, sizeof(_LineBuf), ifile)) {
      ProcessLine(ofile, line);
   }
   fclose(ifile);
   if (ofile != stdout) {
      fclose(ofile);
   }
   return 0;
}

static int SearchQtVersion(const char * path)
{
   int version = 0;
   int i = 0;
   for (i=0; i<(int)strlen(path); i++) {
      if (_strnicmp(&path[i], "qt", 2) == 0) {
         char c = path[i+2];
         if (isdigit(c)) {
            version = c - 0x30;
            return version;
         } else {
            if (c == '\\' ||
                c == '/') {
               c = path[i+3];
               if (isdigit(c)) {
                  version = c - 0x30;
                  return version;
               }
            }
         }
      }
   }
   return 0;
}

static bool AnalyzeCommandLine(int argc, char ** argv, const char * & input_file, const char * & output_file, int & global_qt_version)
{
   int qt_version = 0;
   int input_qt_version = 0;
   int qtdir_qt_version = 0;
   int i = 0;
   for (i=1; i<argc; i++) {
      char * argument = argv[i];
      int argument_length = strlen(argument);
      if (argument[0] == '-') {
         if (_strnicmp(&argument[1], "qtdir", 5) == 0) {
            const char * qtdir = NULL;
            if (argument_length == 6) {
               qtdir = getenv("QTDIR");
            } else {
               char path[0x200] = {0};
               strncpy(path, &argument[6], argument_length - 6);
               qtdir = path;
            }
            qtdir_qt_version = SearchQtVersion(qtdir);
         } else if (_strnicmp(&argument[1], "o", 1) == 0) {
            strncpy(_outputFile, &argument[2], argument_length - 2);
            output_file = _outputFile;
         } else if (argument[1] == 'f') {
            // ignore this for backward compatibility
            if (argument[2] == ' ' || argument[2] == 0) {
               i++;
            }
         } else {
            fprintf(stderr, "invalid argument %s\n", argument);
            return false;
         }
      } else {
         if (input_file != NULL) {
            fprintf(stderr, "invalid argument %s: (input file specified twice?)\n", argument);
            return false;
         }
         strcpy(_ppFile, argument);
         input_file = _ppFile;
         const char * text_ptr = input_file;
         int i = 0;
         for (i=0; i<(int)strlen(argument); i++) {
            if (_strnicmp(text_ptr, "QT3Framework", 12) == 0) {
               input_qt_version = 3;
            }
            if (_strnicmp(text_ptr, "QT4Framework", 12) == 0) {
               input_qt_version = 4;
            }
            text_ptr++;
         }
      }
   }
   if (qtdir_qt_version != 0) {
      qt_version = qtdir_qt_version;
   }
   if (qt_version == 0) {
      if (input_qt_version != 0) {
         qt_version = input_qt_version;
      }
   }
   if (qt_version == 0) {
      const char * qtvariant = getenv("QTVARIANT");
      if (qtvariant != NULL) {
         // Environment variable QTVARIANT
         if (_strnicmp(qtvariant, "qt3", 3) == 0) {
            qt_version = 3;
         }
         if (_strnicmp(qtvariant, "qt4", 3) == 0) {
            qt_version = 4;
         }
         if (_strnicmp(qtvariant, "qt5", 3) == 0) {
            qt_version = 5;
         }
      }
   }
   if (qt_version != 0) {
      global_qt_version = qt_version;
   }
   return true;
}

static void PrintCmdLine(int argc, char ** argv)
{
   int i = 0;
   for (i=0; i<argc; i++) {
      fprintf(stderr, "%s ", argv[i]);
   }
   fprintf(stderr, "\n");
}

static int AdjustQtVersion(int qt_version, const char * input_file, const char * qtDirEnv)
{
   int length = 0;
   int i = 0;
   const char * text_ptr = input_file;
   length = strlen(text_ptr);
   i = 0;
   for (i=0; i<length; i++) {
      if (_strnicmp(text_ptr, "QT3Framework", 12) == 0) {
         int new_version = 3;
         if (qt_version == 4) {
            fprintf(stderr, "Qt version changed from %d to %d\n", _QtVersion, new_version);
         }
         return new_version;
      }
      if (_strnicmp(text_ptr, "QT4Framework", 12) == 0) {
         int new_version = 4;
         if (qt_version == 3) {
            fprintf(stderr, "Qt version changed from %d to %d\n", _QtVersion, new_version);
         }
         return new_version;
      }
      text_ptr++;
   }

   const char * qt_variant = getenv("QTVARIANT");
   if (qt_variant == NULL) { // Environment variable QTVARIANT
      qt_version = 3;

      // Use Environment variable QTDIR to define qt version
      if (qtDirEnv != NULL) {
         fprintf(stderr, "detected QTDIR = %s (getenv)\n", getenv("QTDIR"));
         fprintf(stderr, "detected QTDIR = %s\n", qtDirEnv);

         string qt_directory = qtDirEnv;
         length = qt_directory.size();
         for (i=0; i<length; i++) {
            if (toupper(qt_directory[i]) == 'Q') {
               if (toupper(qt_directory[i+1]) == 'T') {
                  if (qt_directory[i+2] == '/' ||
                      qt_directory[i+2] == '\\') {
                     if (qt_directory[i+3] == '3') {
                        qt_version = 3;
                        //fprintf(stderr, "detected Qt version %d from QTDIR = %s\n", qt_version, qt_directory.c_str());
                        break;
                     }
                     else if (qt_directory[i+3] == '4') {
                        qt_version = 4;
                        //fprintf(stderr, "detected Qt version %d from QTDIR = %s\n", qt_version, qt_directory.c_str());
                        break;
                     }
                     else if (qt_directory[i+3] == '5') {
                        qt_version = 5;
                        //fprintf(stderr, "detected Qt version %d from QTDIR = %s\n", qt_version, qt_directory.c_str());
                        break;
                     }
                  }
               }
            }
         }
      }
   } 
   else {
      if (_strnicmp(qt_variant, "QT3", 3) == 0) {
         qt_version = 3;
      } else if (_strnicmp(qt_variant, "QT4", 3) == 0) {
         qt_version = 4;
      } else if (_strnicmp(qt_variant, "QT5", 3) == 0) {
         qt_version = 5;
      }
   }
   return qt_version;
}

