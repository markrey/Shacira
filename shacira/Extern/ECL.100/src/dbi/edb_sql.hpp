/*.SH.*/

/*
 *  Headerfile for module edb_sql
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  edb_sql.cpp on Sunday February 24 2002  21:56:48
 */

#ifndef __edb_sql__
#define __edb_sql__


// Headerfiles
// ===========================================================================

#include "base/eb_str.hpp"


// Utility Functions
// ===========================================================================

inline cString Concat(cString s1, cString sep, cString s2)
   { return s1.isEmpty() ? s2
          : s2.isEmpty() ? s1
          : s1 + sep + s2; }

namespace SQL {


// ===========================================================================
// Definition COND
// --------------------------------------------------------------------------
//
// COND
//
// ===========================================================================

enum REL_OP {
   REL_NONE,
   REL_NOT, REL_EXISTS,
   REL_GE, REL_LE, REL_GT, REL_LT, REL_EQ, REL_NE,
   REL_LIKE, REL_IS, REL_IN
};

class __ECL_DLLEXPORT__ COND {
   cString cond;

public:
   COND()
      { }
   COND(cString sql)
      { cond = sql.trim(); }
   COND(const char *sql)
      { cond = cString(sql).trim(); }

   COND(REL_OP op, cString expr);
   COND(cString left_expr, REL_OP op, cString right_expr);

   operator cString() const
      { return cond; }


   REL_OP getRelOp() const;
   int getExprCount() const;
   cString getLeftExpr() const;
   cString getRightExpr() const;

};


// ===========================================================================
// Definition WHERE
// ---------------------------------------------------------------------------
//
// WHERE
//
// ===========================================================================

class __ECL_DLLEXPORT__ WHERE {
   cString conds;

public:
   WHERE()
      { }
   WHERE(cString sql)
      { conds = sql.trim(); }
   WHERE(const char *sql)
      { conds = cString(sql).trim(); }

   operator cString() const
      { return conds; }

   inline friend WHERE operator&(const COND& f1, const COND& f2)
      { return WHERE(Concat(f1, " AND ", f2)); }
   inline friend WHERE operator&(const COND& f1, const WHERE& fs2)
      { return WHERE(Concat(f1, " AND ", fs2)); }
   inline friend WHERE operator&(const WHERE& fs1, const COND& f2)
      { return WHERE(Concat(fs1, " AND ", f2)); }
   inline friend WHERE operator&(const WHERE& fs1, const WHERE& fs2)
      { return WHERE(Concat(fs1, " AND ", fs2)); }

   inline friend WHERE operator|(const COND& f1, const COND& f2)
      { return WHERE(Concat(f1, " OR ", f2)); }
   inline friend WHERE operator|(const COND& f1, const WHERE& fs2)
      { return WHERE(Concat(f1, " OR ", fs2)); }
   inline friend WHERE operator|(const WHERE& fs1, const COND& f2)
      { return WHERE(Concat(fs1, " OR ", f2)); }
   inline friend WHERE operator|(const WHERE& fs1, const WHERE& fs2)
      { return WHERE(Concat(fs1, " OR ", fs2)); }

   int getCondCount() const;
   COND getCond(int n) const;

};


// ===========================================================================
// Definition ASSIGN
// --------------------------------------------------------------------------
//
// ASSIGN
//
// ===========================================================================

class __ECL_DLLEXPORT__ ASSIGN {
   cString assign;

public:
   ASSIGN()
      { }
   ASSIGN(cString sql)
      { assign = sql.trim(); }
   ASSIGN(const char *sql)
      { assign = cString(sql).trim(); }

   operator cString() const
      { return assign; }

   cString getField() const;
   cString getExpr() const;

};


// ===========================================================================
// Definition SET
// ---------------------------------------------------------------------------
//
// SET
//
// ===========================================================================

class __ECL_DLLEXPORT__ SET {
   cString assigns;

public:
   SET()
      { }
   SET(cString sql)
      { assigns = sql.trim(); }
   SET(const char *sql)
      { assigns = cString(sql).trim(); }

   operator cString() const
      { return assigns; }

   inline friend SET operator+(const ASSIGN& f1, const ASSIGN& f2)
      { return SET(Concat(f1, ",", f2)); }
   inline friend SET operator+(const ASSIGN& f1, const SET& fs2)
      { return SET(Concat(f1, ",", fs2)); }
   inline friend SET operator+(const SET& fs1, const ASSIGN& f2)
      { return SET(Concat(fs1, ",", f2)); }
   inline friend SET operator+(const SET& fs1, const SET& fs2)
      { return SET(Concat(fs1, ",", fs2)); }

   int getAssignCount() const;
   ASSIGN getAssign(int n) const;

};


// ===========================================================================
// Definition TABLE
// ---------------------------------------------------------------------------
//
// TABLE
//
// ===========================================================================

class __ECL_DLLEXPORT__ TABLE {
   cString table;

public:
   TABLE()
      { }
   TABLE(cString sql)
      { table = sql; }
   TABLE(const char *sql)
      { table = cString(sql).trim(); }

   operator cString() const
      { return table; }

   cString getTableName(bool include_schema = true) const;
   cString getTableAlias() const;

};


// ===========================================================================
// Definition JOIN
// ---------------------------------------------------------------------------
//
// <join>          ::= $JOIN( <table> <join_type> <table_or_join> ON <cond> )
// <join_type>     ::= INNER JOIN
//                   | LEFT OUTER JOIN
//                   | RIGHT OUTER JOIN
//                   | FULL OUTER JOIN
//
// ===========================================================================

enum JOIN_TYPE {
   JOIN_INNER, // Inner join
   JOIN_OUTER_LEFT, JOIN_OUTER_RIGHT, JOIN_OUTER_FULL // Outer joins
};

class __ECL_DLLEXPORT__ JOIN {
   cString join;

public:
   JOIN();
   JOIN(cString sql);
   JOIN(const char *sql);
   JOIN(JOIN_TYPE type,
        const TABLE& table,
        const TABLE& joined_table,
        const WHERE& cond = WHERE());
   JOIN(JOIN_TYPE type,
        const TABLE& table,
        const JOIN& joined_join,
        const WHERE& cond);

   operator cString() const
      { return "$JOIN(" + join + ")"; }

   // Ermittelt den Typ des JOINs
   JOIN_TYPE getJoinType() const;
   // Ermittelt die Haupttabelle des JOINs
   TABLE getJoinTable() const;
   // Ermittelt die Bedingung des JOINs
   WHERE getJoinOn() const;

   // Wird eine Tabelle verknuepft?
   bool isJoinedTable() const;
   // Ermittelt die verknuepfte Tabelle
   TABLE getJoinedTable() const;

   // Wird ein weiterer JOIN verknuepft?
   bool isJoinedJoin() const;
   // Ermittelt die untergeordnete Verknuepfung
   JOIN getJoinedJoin() const;

};


// ===========================================================================
// Definition FROM
// ---------------------------------------------------------------------------
//
// <from>          ::= FROM <table_or_join> { , <table_or_join> }
// <table_or_join> ::= <table> | <join>
//
// ===========================================================================

class __ECL_DLLEXPORT__ FROM {
   cString tables;

public:
   FROM()
      { }
   FROM(cString sql)
      { tables = sql.trim(); }
   FROM(const char *sql)
      { tables = cString(sql).trim(); }

   operator cString() const
      { return tables; }

   inline friend FROM operator+(const TABLE& f1, const TABLE& f2)
      { return FROM(Concat(f1, ",", f2)); }
   inline friend FROM operator+(const TABLE& f1, const FROM& fs2)
      { return FROM(Concat(f1, ",", fs2)); }
   inline friend FROM operator+(const FROM& fs1, const TABLE& f2)
      { return FROM(Concat(fs1, ",", f2)); }
   inline friend FROM operator+(const FROM& fs1, const FROM& fs2)
      { return FROM(Concat(fs1, ",", fs2)); }

   // Liefert die Anzahl Tabellen bzw. JOINs auf oberster Ebene
   int getTableCount() const;
   // Liefert die Basistabelle (gleichgueltig ob innerhalb JOIN oder nicht)
   TABLE getBaseTable() const;

   // Ist das n-te Listenelement eine Tabelle?
   bool isTable(int n) const;
   // Liefert die Tabelle an n-ter Position der Liste
   TABLE getTable(int n) const;

   // Ist das n-te Listenelement ein JOIN
   bool isJoin(int n) const;
   // Liefert den JOIN an n-ter Position der Liste
   JOIN getJoin(int n) const;

};


// ===========================================================================
// Definition FIELD
// ---------------------------------------------------------------------------
//
// FIELD
//
// ===========================================================================

class __ECL_DLLEXPORT__ FIELD {
   cString field;

public:
   FIELD()
      { }
   FIELD(cString sql)
      { field = sql.trim(); }
   FIELD(const char *sql)
      { field = cString(sql).trim(); }

   operator cString() const
      { return field; }

   cString getFieldName(bool include_table = true) const;
   cString getFieldAlias() const;
   cString getTableName() const;

};


// ===========================================================================
// Definition FIELDS
// ---------------------------------------------------------------------------
//
// FIELDS
//
// ===========================================================================

class __ECL_DLLEXPORT__ FIELDS {
   cString fields;

public:
   FIELDS()
      { }
   FIELDS(cString sql)
      { fields = sql.trim(); }
   FIELDS(const char *sql)
      { fields = cString(sql).trim(); }

   operator cString() const
      { return fields; }

   inline friend FIELDS operator+(const FIELD& f1, const FIELD& f2)
      { return FIELDS(Concat(f1, ",", f2)); }
   inline friend FIELDS operator+(const FIELD& f1, const FIELDS& fs2)
      { return FIELDS(Concat(f1, ",", fs2)); }
   inline friend FIELDS operator+(const FIELDS& fs1, const FIELD& f2)
      { return FIELDS(Concat(fs1, ",", f2)); }
   inline friend FIELDS operator+(const FIELDS& fs1, const FIELDS& fs2)
      { return FIELDS(Concat(fs1, ",", fs2)); }

   int getFieldCount() const;
   FIELD getField(int n) const;
   FIELDS getFieldsFrom(const TABLE& t) const;

   int findField(const FIELD& field, bool no_case = true) const;
   bool hasField(const FIELD& field, bool no_case = true) const;

   void setField(int n, const FIELD& field);

};


// ===========================================================================
// Definition VALUE
// ---------------------------------------------------------------------------
//
// VALUE
//
// ===========================================================================

class __ECL_DLLEXPORT__ VALUE {
   cString value;

public:
   VALUE()
      { }
   VALUE(cString sql)
      { value = sql.trim(); }
   VALUE(const char *sql)
      { value = cString(sql).trim(); }

   operator cString() const
      { return value; }

};


// ===========================================================================
// Definition VALUES
// ---------------------------------------------------------------------------
//
// VALUES
//
// ===========================================================================

class __ECL_DLLEXPORT__ VALUES {
   cString values;

public:
   VALUES()
      { }
   VALUES(cString sql)
      { values = sql.trim(); }
   VALUES(const char *sql)
      { values = cString(sql).trim(); }

   operator cString() const
      { return values; }

   inline friend VALUES operator+(const VALUE& v1, const VALUE& v2)
      { return VALUES(Concat(v1, ",", v2)); }
   inline friend VALUES operator+(const VALUE& v1, const VALUES& vs2)
      { return VALUES(Concat(v1, ",", vs2)); }
   inline friend VALUES operator+(const VALUES& vs1, const VALUE& v2)
      { return VALUES(Concat(vs1, ",", v2)); }
   inline friend VALUES operator+(const VALUES& vs1, const VALUES& vs2)
      { return VALUES(Concat(vs1, ",", vs2)); }

   int getValueCount() const;
   VALUE getValue(int n) const;

};


// ===========================================================================
// Definition GROUPBY
// ---------------------------------------------------------------------------
//
// GROUPBY
//
// ===========================================================================

class __ECL_DLLEXPORT__ GROUPBY : public FIELDS {

public:
   GROUPBY()
      { }
   GROUPBY(cString sql) : FIELDS(sql)
      { }
   GROUPBY(const char *sql) : FIELDS(sql)
      { }

   inline friend GROUPBY operator+(const FIELD& f1, const GROUPBY& fs2)
      { return GROUPBY(Concat(f1, ",", fs2)); }
   inline friend GROUPBY operator+(const GROUPBY& fs1, const FIELD& f2)
      { return GROUPBY(Concat(fs1, ",", f2)); }
   inline friend GROUPBY operator+(const GROUPBY& fs1, const GROUPBY& fs2)
      { return GROUPBY(Concat(fs1, ",", fs2)); }

};


// ===========================================================================
// Definition ORDERBY
// ---------------------------------------------------------------------------
//
// ORDERBY
//
// ===========================================================================

class __ECL_DLLEXPORT__ ORDERBY : public FIELDS {

public:
   ORDERBY()
      { }
   ORDERBY(cString sql) : FIELDS(sql)
      { }
   ORDERBY(const char *sql) : FIELDS(sql)
      { }

   inline friend ORDERBY operator+(const FIELD& f1, const ORDERBY& fs2)
      { return ORDERBY(Concat(f1, ",", fs2)); }
   inline friend ORDERBY operator+(const ORDERBY& fs1, const FIELD& f2)
      { return ORDERBY(Concat(fs1, ",", f2)); }
   inline friend ORDERBY operator+(const ORDERBY& fs1, const ORDERBY& fs2)
      { return ORDERBY(Concat(fs1, ",", fs2)); }

};


// ===========================================================================
// Definition HINT
// ---------------------------------------------------------------------------
//
// HINT
//
// ===========================================================================

class __ECL_DLLEXPORT__ HINT {
   cString hint;

public:
   HINT()
      { }
   HINT(cString sql)
      { hint = sql; }
   HINT(const char *sql)
      { hint = cString(sql).trim(); }

   operator cString() const
      { return hint; }

   cString getName() const;
   cString getValue() const;

};


// ===========================================================================
// Definition HINTS
// ---------------------------------------------------------------------------
//
// HINTS
//
// ===========================================================================

class __ECL_DLLEXPORT__ HINTS {
   cString hints;

public:
   HINTS()
      { }
   HINTS(cString sql)
      { hints = sql.trim(); }
   HINTS(const char *sql)
      { hints = cString(sql).trim(); }

   operator cString() const
      { return hints; }

   inline friend HINTS operator+(const HINT& f1, const HINT& f2)
      { return HINTS(Concat(f1, ",", f2)); }
   inline friend HINTS operator+(const HINT& f1, const HINTS& fs2)
      { return HINTS(Concat(f1, ",", fs2)); }
   inline friend HINTS operator+(const HINTS& fs1, const HINT& f2)
      { return HINTS(Concat(fs1, ",", f2)); }
   inline friend HINTS operator+(const HINTS& fs1, const HINTS& fs2)
      { return HINTS(Concat(fs1, ",", fs2)); }

   int getHintCount() const;
   HINT getHint(int n) const;
   HINT getHint(cString hint_name) const;

};


// ===========================================================================
// Definition SELECT
// ---------------------------------------------------------------------------
//
// SELECT [ALL|DISTINCT]
//    fields
//    FROM tables
//    [WHERE condition]
//    [ORDER BY fields]
//    [GROUP BY fields]
//
// ===========================================================================

enum SELECT_STYLE { STYLE_NONE, STYLE_ALL, STYLE_DISTINCT };

class __ECL_DLLEXPORT__ SELECT {
   cString select;

public:
   SELECT()
      { }
   SELECT(cString sql)
      { select = sql.trim(); }
   SELECT(const char *sql)
      { select = cString(sql).trim(); }
   SELECT(SELECT_STYLE style,
          const HINTS& hints,
          const FIELDS& fields,
          const FROM& tables,
          const WHERE& conds = WHERE(),
          const GROUPBY& groups = GROUPBY(),
          const ORDERBY& orders = ORDERBY());
   SELECT(SELECT_STYLE style,
          const FIELDS& fields,
          const FROM& tables,
          const WHERE& conds = WHERE(),
          const GROUPBY& groups = GROUPBY(),
          const ORDERBY& orders = ORDERBY());
   SELECT(const HINTS& hints,
          const FIELDS& fields,
          const FROM& tables,
          const WHERE& conds = WHERE(),
          const GROUPBY& groups = GROUPBY(),
          const ORDERBY& orders = ORDERBY());
   SELECT(const FIELDS& fields,
          const FROM& tables,
          const WHERE& conds = WHERE(),
          const GROUPBY& groups = GROUPBY(),
          const ORDERBY& orders = ORDERBY());

   operator cString() const
      { return select; }

   inline friend SELECT operator+(const SELECT& s, const HINT& h)
      { SELECT sn(s); sn.setHints(sn.getHints() + h); return sn; }
   inline friend SELECT operator+(const SELECT& s, const FIELD& f)
      { SELECT sn(s); sn.setFields(sn.getFields() + f); return sn; }
   inline friend SELECT operator+(const SELECT& s, const FROM& f)
      { SELECT sn(s); sn.setFrom(sn.getFrom() + f); return sn; }
   inline friend SELECT operator+(const SELECT& s, const GROUPBY& o)
      { SELECT sn(s); sn.setGroupBy(sn.getGroupBy() + o); return sn; }
   inline friend SELECT operator+(const SELECT& s, const ORDERBY& o)
      { SELECT sn(s); sn.setOrderBy(sn.getOrderBy() + o); return sn; }

   inline friend SELECT operator&(const SELECT& s, const WHERE& w)
      { SELECT sn(s); sn.setWhere(sn.getWhere() & w); return sn; }
   inline friend SELECT operator|(const SELECT& s, const WHERE& w)
      { SELECT sn(s); sn.setWhere(sn.getWhere() | w); return sn; }

   SELECT_STYLE getStyle() const;
   HINTS getHints() const;
   FIELDS getFields() const;
   FROM getFrom() const;
   WHERE getWhere() const;
   GROUPBY getGroupBy() const;
   ORDERBY getOrderBy() const;

   void setStyle(SELECT_STYLE style);
   void setHints(const HINTS& hints);
   void setFields(const FIELDS& fields);
   void setFrom(const FROM& from);
   void setWhere(const WHERE& where);
   void setGroupBy(const GROUPBY& groupby);
   void setOrderBy(const ORDERBY& orderby);

private:
   void init(SELECT_STYLE style,
             const HINTS& hints,
             const FIELDS& fields,
             const FROM& tables,
             const WHERE& conds,
             const GROUPBY& groups,
             const ORDERBY& orders);

};


// ===========================================================================
// Definition INSERT
// ---------------------------------------------------------------------------
//
// INSERT INTO table [(fields)]
//    [VALUES (values) | SELECT ...]
//
// ===========================================================================

class __ECL_DLLEXPORT__ INSERT {
   cString insert;

public:
   INSERT()
      { }
   INSERT(cString sql)
      { insert = sql.trim(); }
   INSERT(const char *sql)
      { insert = cString(sql).trim(); }
   INSERT(const TABLE& table,
          const FIELDS& fields,
          const VALUES& values);
   INSERT(const TABLE& hints,
          const FIELDS& fields,
          const SELECT& select);
   INSERT(const TABLE& table,
          const VALUES& values);
   INSERT(const TABLE& hints,
          const SELECT& select);

   operator cString() const
      { return insert; }

   inline friend INSERT operator+(const INSERT& i, const FIELD& f)
      { INSERT in(i); in.setFields(in.getFields() + f); return in; }
   inline friend INSERT operator+(const INSERT& i, const VALUE& v)
      { INSERT in(i); in.setValues(in.getValues() + v); return in; }

   TABLE getTable() const;
   FIELDS getFields() const;
   VALUES getValues() const;
   SELECT getSelect() const;

   void setTable(TABLE table);
   void setFields(const FIELDS& fields);
   void setValues(const VALUES& values);
   void setSelect(const SELECT& select);

private:
   void init(const TABLE& table,
             const FIELDS& fields,
             const VALUES& values,
             const SELECT& select);

   INSERT(const TABLE& table,
          const FIELDS& fields,
          const VALUES& values,
          const SELECT& select);

};


// ===========================================================================
// Definition UPDATE
// ---------------------------------------------------------------------------
//
// UPDATE table
//    SET field=value {,field=value}
//    [WHERE where]
//
// ===========================================================================

class __ECL_DLLEXPORT__ UPDATE {
   cString update;

public:
   UPDATE()
      { }
   UPDATE(cString sql)
      { update = sql.trim(); }
   UPDATE(const char *sql)
      { update = cString(sql).trim(); }
   UPDATE(const TABLE& table,
          const SET& set,
          const WHERE& where = WHERE());

   operator cString() const
      { return update; }

   inline friend UPDATE operator+(const UPDATE& u, const SET& s)
      { UPDATE un(u); un.setSet(un.getSet() + s); return un; }

   inline friend UPDATE operator&(const UPDATE& u, const WHERE& w)
      { UPDATE un(u); un.setWhere(un.getWhere() & w); return un; }
   inline friend UPDATE operator|(const UPDATE& u, const WHERE& w)
      { UPDATE un(u); un.setWhere(un.getWhere() | w); return un; }

   TABLE getTable() const;
   SET getSet() const;
   WHERE getWhere() const;

   void setTable(TABLE table);
   void setSet(const SET& set);
   void setWhere(const WHERE& where);

private:
   void init(const TABLE& table,
             const SET& set,
             const WHERE& where);

};


// ===========================================================================
// Definition DELETE
// ---------------------------------------------------------------------------
//
// DELETE FROM table
//    [WHERE where]
//
// ===========================================================================

class __ECL_DLLEXPORT__ DELETE {
   cString delstr;

public:
   DELETE()
      { }
   DELETE(cString sql)
      { delstr = sql.trim(); }
   DELETE(const char *sql)
      { delstr = cString(sql).trim(); }
   DELETE(const TABLE& table,
          const WHERE& where = WHERE());

   operator cString() const
      { return delstr; }

   inline friend DELETE operator&(const DELETE& d, const WHERE& w)
      { DELETE dn(d); dn.setWhere(dn.getWhere() & w); return dn; }
   inline friend DELETE operator|(const DELETE& d, const WHERE& w)
      { DELETE dn(d); dn.setWhere(dn.getWhere() | w); return dn; }

   TABLE getTable() const;
   WHERE getWhere() const;

   void setTable(TABLE table);
   void setWhere(const WHERE& where);

private:
   void init(const TABLE& table,
             const WHERE& where);

};


// ===========================================================================
// Definition STMT
// ---------------------------------------------------------------------------
//
// STMT
//
// ===========================================================================

enum STMT_TYPE { STMT_NONE, STMT_SELECT, STMT_INSERT, STMT_UPDATE, STMT_DELETE };

class __ECL_DLLEXPORT__ STMT {
   cString stmt;

public:
   STMT()
      { }
   STMT(const cString& sql)
      { stmt = sql.trim(); }
   STMT(const char *sql)
      { stmt = cString(sql).trim(); }
   STMT(const SELECT& sql)
      { stmt = cString(sql).trim(); }
   STMT(const INSERT& sql)
      { stmt = cString(sql).trim(); }
   STMT(const UPDATE& sql)
      { stmt = cString(sql).trim(); }
   STMT(const DELETE& sql)
      { stmt = cString(sql).trim(); }

   operator cString() const
      { return stmt; }

   STMT_TYPE getType() const;
   HINTS getHints() const;
   WHERE getWhere() const;

   void setHints(const HINTS& hints);
   void setWhere(const WHERE& where);

};

}; /* namespace SQL*/


#endif

/*.EH.*/
