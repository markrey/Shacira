/*.SH.*/

/*
 *  Headerfile for module edb_cursor
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  edb_cursor.cpp on Wednesday March 20 2002  22:46:08
 */

#ifndef __edb_cursor__
#define __edb_cursor__


// Headerfiles
// ===========================================================================

#include <time.h>
#include "dbi/edb_sql.hpp"
#include "dbi/edb_database.hpp"
#include "store/es_var.hpp"


// ===========================================================================
// Definition cdbCursor
// ---------------------------------------------------------------------------
//
// Anmerkung zu den Datentypen:
//
//  - Die Groesse der C-Typen 'check', 'rowid', 'date', 'time' und 'timestamp'
//    ist so gewaehlt, dass ausreichend Platz fuer alle unterstuetzten
//    Datenbanken zur Verfuegung steht.
//
//  - Auf den Inhalt des 'check'-Typs kann nur ueber getSize(), setSize(),
//    isNull() und setNull() zugegriffen werden.
//
//  - Auf den Inhalt der 'date', 'time' und 'timestamp'-Typen kann nur ueber
//    die get()- und set()-Methoden zugegriffen werden.
//
//  - Auf den Inhalt des 'rowid'-Typs kann nicht zugegriffen werden, da ihm
//    keine datenbankunabhaengige Bedeutung zugeordnet werden kann.
//
// cBase
//  +--cdbCursor
//
// ===========================================================================

class __ECL_DLLEXPORT__ cdbCursor : public cBase {
   friend class cdbErr;

public:
   cdbCursor(cdbDatabase& db, int prefetch_count = 1);
   cdbCursor(const cdbCursor& other, int prefetch_count = -1);
   ~cdbCursor();


   // Cursor-Typen
   // ============

   struct check { long unspecific; };
   struct rowid { char unspecific[18]; };
   struct date { char unspecific[6]; };
   struct time { char unspecific[6]; };
   struct timestamp { char unspecific[16]; };

   enum VARTYPE {       // C-Typen:
      tShort,           // short
      tLong,            // long
      tFloat,           // float
      tDouble,          // double
      tChar,            // char
      tString,          // char[]
      tRowid,           // cdbCursor::rowid
      tDate,            // cdbCursor::date
      tTime,            // cdbCursor::time
      tTimeStamp        // cdbCursor::timestamp
   };

   enum DTFIELD {
      fYear,            // Jahr (0..9999)
      fMonth,           // Monat (1..12)
      fDay,             // Tag (1..31)
      fHour,            // Stunde (0..23)
      fMinute,          // Minute (0..59)
      fSecond           // Sekunde (0..59)
   };

   // Groesseninformation aus check-Variable ermitteln
   // (Sonderwerte: -1 = NULL, -2 = nullterminierter String)
   int getSize(const check& ind) const;
   // Groessenformation in check-Variable setzen
   // (Sonderwerte: -1 = NULL, -2 = nullterminierter String)
   void setSize(check& ind, int size) const;

   // NULL-Zustand aus check-Variable ermitteln
   bool isNull(const check& ind) const;
   // NULL-Zustand in check-Variable setzen
   void setNull(check& ind) const;

   // Komponente aus date-Struktur einzeln abfragen
   short get(const date& var, DTFIELD field) const;
   // Komponente aus time-Struktur einzeln abfragen
   short get(const time& var, DTFIELD field) const;
   // Komponente aus timestamp-Struktur einzeln abfragen
   short get(const timestamp& var, DTFIELD field) const;
   // date-Struktur im time_t-Format abfragen
   time_t get(const date& var, time_t& time) const;
   // time-Struktur im time_t-Format abfragen
   time_t get(const time& var, time_t& time) const;
   // timestamp-Struktur im time_t-Format abfragen
   time_t get(const timestamp& var, time_t& time) const;
   // date-Struktur im cDate-Format abfragen
   cDate get(const date& var) const;
   // time-Struktur im cTime-Format abfragen
   cTime get(const time& var) const;
   // timestamp-Struktur im cDateTime-Format abfragen
   cDateTime get(const timestamp& var) const;

   // Komponente in date-Struktur einzeln setzen
   void set(date& var, DTFIELD field, short value) const;
   // Komponente in time-Struktur einzeln setzen
   void set(time& var, DTFIELD field, short value) const;
   // Komponente in timestamp-Struktur einzeln setzen
   void set(timestamp& var, DTFIELD field, short value) const;
   // date-Struktur ueber time_t-Variable setzen
   void set(date& var, time_t time) const;
   // time-Struktur ueber time_t-Variable setzen
   void set(time& var, time_t time) const;
   // timestamp-Struktur ueber time_t-Variable setzen
   void set(timestamp& var, time_t time) const;
   // date-Struktur ueber cDate-Variable setzen
   void set(date& var, cDate date) const;
   // time-Struktur ueber cTime-Variable setzen
   void set(time& var, cTime time) const;
   // timestamp-Struktur ueber cDateTime-Variable setzen
   void set(timestamp& var, cDateTime datetime) const;


   // Ausfuehrungskontrolle
   // =====================

   enum CONCURRENCY {
      cReadOnly,        // Nur lesen (default)
      cLocked           // Sperren
   };

   // Locking-Modus setzen
   void setLockMode(CONCURRENCY concur);
   // SQL-Anweisung vorbereiten (vor dem Binden von Variablen)
   void compile(SQL::STMT sql_str);
   // SQL-Anweisung ausfuehren (nach dem Binden von Variablen)
   void exec();
   // SQL-Anweisung direkt ausfuehren (ohne gebundene Variablen)
   void exec(SQL::STMT sql_str);
   // (Naechste) Zeile der Ergebnismenge abfragen
   bool fetch();
   // Ausfuehrung der SQL-Anweisung unterbrechen
   void halt();
   // Aktuelle Verarbeitung (u.U. vorzeitig) beenden
   void close();

   // Zugrundeliegende Datenbank ermitteln
   cdbDatabase *getDB() const;
   // Zugrundeliegende SQL-Anweisung ermitteln
   SQL::STMT getSQL() const;


   // Schluesselfelder
   // ================
   // Mit Hilfe dieser Funktionen kann erfragt werden, welche Kombination
   // von Ergebnisspalten einen eindeutigen Schluessel bildet. Kann diese
   // Eigenschaft nicht von der Datenbank erfragt werden, gibt das System
   // die ersten N Ergebnisspalten als Schluessel zurueck, wobei N
   // folgendermassen bestimmt wird:
   //
   //  - Enthaelt das SQL::STMT keinen PK-Hint, wird N = 1
   //  - Enthaelt das SQL::STMT einen "PK=<x>"-Hint, wird N=<x>
   //
   // Zudem koennen zwei spezifische Spalten fuer Bedeutungen "Name" und
   // "Beschreibung" erfragt werden

   // Ermittelt die Anzahl Ergebnisspalten, die einen eindeutigen Schluessel bilden
   int getKeyCount() const;
   // Ermittelt die Feldnummer der n-ten Schluesselspalte
   int getKeyField(int n) const;
   // Ermittelt die Feldnummer der Namensspalte
   int getNameField() const;
   // Ermittelt die Feldnummer der Beschreibungsspalte
   int getDescrField() const;


   // Eigenschaften der Ergebnisspalten
   // =================================
   // Diese Eigenschaften stehen fruehestens nach dem Aufruf von exec()
   // zur Verfuegung. Die Ergebnisse werden bis zum naechsten Aufruf von
   // exec() gecached, koennen also ohne Zusatzaufwand beliebig oft
   // abgefragt werden.

   // Anzahl Ergebnisspalten (= Felder) erfragen
   int getFieldCount() const;
   // Feldname erfragen
   cString getFieldName(int n) const;
   // Label des Feldes erfragen
   cString getFieldLabel(int n) const;
   // Name des Schemas der Basistabelle erfragen
   cString getFieldBaseSchema(int n) const;
   // Name der Basistabelle erfragen
   cString getFieldBaseTable(int n) const;
   // Name des Feldes in der Basistabelle erfragen
   cString getFieldBaseColumn(int n) const;
   // Variablentyp erfragen
   VARTYPE getFieldType(int n) const;
   // Maximale Spaltenbreite erfragen
   int getFieldSize(int n) const;
   // Anzahl Nachkommastellen erfragen
   int getFieldDigits(int n) const;
   // Erfragen, ob die Spalte NULL-Werte enthalten darf
   bool getFieldNullable(int n) const;
   // Erfragen, ob die Spalte Werte fester Laenge enthaelt
   bool getFieldFixedLength(int n) const;


   // Eigenschaften der Parameter
   // ===========================
   // Diese Eigenschaften stehen fruehestens nach dem Aufruf von exec()
   // zur Verfuegung. Die Ergebnisse werden bis zum naechsten Aufruf von
   // exec() gecached, koennen also ohne Zusatzaufwand beliebig oft
   // abgefragt werden.

   // Anzahl Parameter erfragen
   int getParamCount() const;
   // Variablentyp erfragen
   cdbCursor::VARTYPE getParamType(int n) const;
   // Maximale Spaltenbreite erfragen
   int getParamSize(int n) const;
   // Anzahl Nachkommastellen erfragen
   int getParamDigits(int n) const;
   // Erfragen, ob der Parameter NULL-Werte enthalten darf
   bool getParamNullable(int n) const;
   // Erfragen, ob der Parameter einen Wert fester Laenge enthaelt
   bool getParamFixedLength(int n) const;


   long getRowCount();  // RowCount bei letztem INSERT, UPDATE oder DELETE, oder -1
   bool getDescr(int n, char *name, short *db_size, VARTYPE *db_type, short *width = NULL); // Uraltversion, sterben lassen

   cString getLastErrorMsg() const;
   cString getLastCmd() const;


   // Ergebnisvariablen binden
   // ========================

   // Ergebnisvariable an csVar-Objekt binden
   void define(int n, csVar& var);
   // Ergebnisvariable an csStorage-Objekt binden
   void define(int n, csStorage *var);
   // Ergebnisvariable an herkoemmliche C-Variable binden
   void define(int n, VARTYPE type, void *buf, size_t len, check *ind = NULL);
   // Bindung an Ergebnisvariable aufheben
   void define(int n);

   void define(int n, short& var) { define(n, tShort, &var, sizeof var); }
   void define(int n, long& var) { define(n, tLong, &var, sizeof var); }
   void define(int n, float& var) { define(n, tFloat, &var, sizeof var); }
   void define(int n, double& var) { define(n, tDouble, &var, sizeof var); }
   void define(int n, char *var, size_t len) { define(n, tString, var, len); }
   void define(int n, rowid& var) { define(n, tRowid, &var, sizeof var); }
   void define(int n, date& var) { define(n, tDate, &var, sizeof var); }
   void define(int n, time& var) { define(n, tTime, &var, sizeof var); }
   void define(int n, timestamp& var) { define(n, tTimeStamp, &var, sizeof var); }

   void define(int n, short& var, check& ind) { define(n, tShort, &var, sizeof var, &ind); }
   void define(int n, long& var, check& ind) { define(n, tLong, &var, sizeof var, &ind); }
   void define(int n, float& var, check& ind) { define(n, tFloat, &var, sizeof var, &ind); }
   void define(int n, double& var, check& ind) { define(n, tDouble, &var, sizeof var, &ind); }
   void define(int n, char *var, size_t len, check& ind) { define(n, tString, var, len, &ind); }
   void define(int n, rowid& var, check& ind) { define(n, tRowid, &var, sizeof var, &ind); }
   void define(int n, date& var, check& ind) { define(n, tDate, &var, sizeof var, &ind); }
   void define(int n, time& var, check& ind) { define(n, tTime, &var, sizeof var, &ind); }
   void define(int n, timestamp& var, check& ind) { define(n, tTimeStamp, &var, sizeof var, &ind); }


   // Numerische Parametervariablen binden
   // ====================================

   // Parameter ueber Index an csVar-Objekt binden
   void bind(int n, csVar& var);
   // Parameter ueber Index an csStorage-Objekt binden
   void bind(int n, csStorage *var);
   // Parameter ueber Index an herkoemmliche C-Variable binden
   void bind(int n, VARTYPE type, void *buf, size_t len, check *ind = NULL);
   // Bindung an Index-Parameter aufheben
   void bind(int n);

   void bind(int n, short& var) { bind(n, tShort, &var, sizeof var); }
   void bind(int n, int& var) { bind(n, tLong, &var, sizeof var); }
   void bind(int n, long& var) { bind(n, tLong, &var, sizeof var); }
   void bind(int n, float& var) { bind(n, tFloat, &var, sizeof var); }
   void bind(int n, double& var) { bind(n, tDouble, &var, sizeof var); }
   void bind(int n, char *var, int len) { bind(n, tString, var, len-1); }
   void bind(int n, rowid& var) { bind(n, tRowid, &var, sizeof var); }
   void bind(int n, date& var) { bind(n, tDate, &var, sizeof var); }
   void bind(int n, time& var) { bind(n, tTime, &var, sizeof var); }
   void bind(int n, timestamp& var) { bind(n, tTimeStamp, &var, sizeof var); }

   void bind(int n, short& var, check& ind) { bind(n, tShort, &var, sizeof var, &ind); }
   void bind(int n, int& var, check& ind) { bind(n, tLong, &var, sizeof var, &ind); }
   void bind(int n, long& var, check& ind) { bind(n, tLong, &var, sizeof var, &ind); }
   void bind(int n, float& var, check& ind) { bind(n, tFloat, &var, sizeof var, &ind); }
   void bind(int n, double& var, check& ind) { bind(n, tDouble, &var, sizeof var, &ind); }
   void bind(int n, char *var, int len, check& ind) { bind(n, tString, var, len-1, &ind); }
   void bind(int n, rowid& var, check& ind) { bind(n, tRowid, &var, sizeof var, &ind); }
   void bind(int n, date& var, check& ind) { bind(n, tDate, &var, sizeof var, &ind); }
   void bind(int n, time& var, check& ind) { bind(n, tTime, &var, sizeof var, &ind); }
   void bind(int n, timestamp& var, check& ind) { bind(n, tTimeStamp, &var, sizeof var, &ind); }


   // Symbolische Parametervariablen binden
   // =====================================
   // Sollen Parametervariablen sowohl numerisch als auch per Namen an den
   // selben Cursor gebunden werden, muessen ERST ALLE numerischen Bindungen
   // und DANN die Bindungen per Namen ausgefuehrt werden!!

   // Parameter ueber Name an csVar-Objekt binden
   void bind(cString name, csVar& var);
   // Parameter ueber Name an csStorage-Objekt binden
   void bind(cString name, csStorage *var);
   // Parameter ueber Name an herkoemmliche C-Variable binden
   void bind(cString name, VARTYPE type, void *buf, size_t len, check *ind = NULL);

   void bind(cString name, short& var) { bind(name, tShort, &var, sizeof var); }
   void bind(cString name, int& var) { bind(name, tLong, &var, sizeof var); }
   void bind(cString name, long& var) { bind(name, tLong, &var, sizeof var); }
   void bind(cString name, float& var) { bind(name, tFloat, &var, sizeof var); }
   void bind(cString name, double& var) { bind(name, tDouble, &var, sizeof var); }
   void bind(cString name, char *var, int len) { bind(name, tString, var, len); }
   void bind(cString name, rowid& rid) { bind(name, tRowid, &rid, sizeof rid); }
   void bind(cString name, date& rid) { bind(name, tDate, &rid, sizeof rid); }
   void bind(cString name, time& rid) { bind(name, tTime, &rid, sizeof rid); }
   void bind(cString name, timestamp& rid) { bind(name, tTimeStamp, &rid, sizeof rid); }


   // Statische Parametervariablen binden
   // ===================================

   // Statische Parametervariable binden (ansprechbar ueber $##X, wobei 0 <= X <= 9)
   static void bindStatic(int n, const char *buf);
   // Wert einer statisch gebundenen Parametervariablen ermitteln
   static const char *getStaticBound(int n);


   // Treiber-Internas
   // ================

   // Treiberspezifische Informationen ermitteln
   long getDriverInfo(int code) const;
   // Treiberspezifische Routinen ausfuehren
   int executeDriverCode(int code, void *data) const;


private:
   void *cu_base;

};


#endif

/*.EH.*/
