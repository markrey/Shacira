/*.SH.*/

/*
 *  Headerfile for module et_tomate
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  et_tomate.cpp on Thursday February 15 2001  13:12:36
 */

#ifndef __et_tomate__
#define __et_tomate__


#ifdef NO_ECL
#define USE_THREAD 0
#else
#define USE_THREAD 1    // Tomate-Thread (aus ECL) 0=aus, 1=ein
#endif

#include <stdarg.h>
#include <setjmp.h>
#include <stdio.h>
#include <conio.h>

#if USE_THREAD
   // bisher einzige Abhaengigkeit von der restlichen ECL
   #include "base/eb_thread.hpp"
#endif


// ===========================================================================
// Definition cTomConsole
// ---------------------------------------------------------------------------
//
// cTomConsole -  (virtuelle) Konsolenklasse, die Defaultimplementierung
//                benutzt die 0815-Funktionen aus conio.h
//
// ---------------------------------------------------------------------------

#if defined __ECL_ICC__
   // Hier sind cgets und cputs als Makros definiert... Was fatal ist
   // fuer die Verwendung dieser Namen als Klassen-Komponenten...
   #undef cputs
   #undef cgets
   inline int cputs(const char *s) { return _cputs((char *)(void *)s); }
   inline char *cgets(char *b) { return _cgets(b); }
#endif

class __ECL_DLLEXPORT__ cTomConsole {
public:
   // von der Tomate benutzte Funktionen:
   virtual int io_getch();
   virtual int io_cputs(const char *str);
   virtual char *io_cgets(char *buf);
   virtual int io_vprintf(const char *fmt, va_list arg);
   // (noch) nicht benutzte Funktionen ...
   virtual int io_putch(int ch);
   virtual int io_kbhit();
};


// ---------------------------------------------------------------------------
// Exportierte Datentypen
// ---------------------------------------------------------------------------

/*
 *  TYPNAME:
 *     Tom_TYPE - die alles erschlagende Struktur der Tom-Tabellen
 *
 *  TYPDEFINITION:
 *     [RECORD
 *        func [char*(*)(char*,Tom_TYPE*)] - Adresse der Aktionsfunktion
 *        value [int] - Integer-Parameter
 *        ptr1 [void*] - erster Zeiger-Parameter, am Tabellenende Zeiger
 *                          auf Initialisierungs-Funktion oder NULL.
 *        ptr2 [void*] - zweiter Zeiger-Parameter, am Tabellenende Zeiger
 *                          auf Deinitialisierungs-Funktion oder NULL.
 *        minlen [int] - Mindestlaenge des Tokens, besondere Faelle sind:
 *                          = 0 --> Tabellenende
 *                          = -1 --> Default-Eintrag, passt immer
 *                          ACHTUNG: 0 und -1 werdem getauscht werden !!!
 *                          = -2 --> Dummy-Eintrag, passt niemals
 *                          = -3 --> Protect-Eintrag, hat kein Token
 *        token [char*] - Token (mit Hilfe-Text), besondere Faelle sind:
 *                          Tabellenende: Prompt, ggf. mit %d oder NULL
 *                              wenn kein spezielles Prompt gewuenscht ist
 *                          Default/Dummy-Eintrag: nur fuer Ausgabe
 *                          Protect-Eintrag: immer NULL, sprich nix
 *     ]
 *
 *  BEMERKUNGEN:
 *     Der Aufbau der Struktur ist nicht Teil der Tomate-Schnittstelle. Die
 *     Komponenten und deren Bedeutung kann sich jederzeit wieder aendern!!!
 */
typedef struct _tomtype {
   char *(*func) ( char*, struct _tomtype* );
   int  value;
   void *ptr1;
   void *ptr2;
   int minlen;
   char *token;
} Tom_TYPE;


/**
 * TYPNAME
 *    Tom_FUNC - Typ der handelsueblichen Tomaten-Funktionen
 *
 * TYPDEFINITION:
 *    ...
 */
typedef char *(*Tom_FUNC) ( char*, Tom_TYPE* ) ;


/*
 *  TYPNAME:
 *     Tom_NAMES - Verbindung zwischen Variablen und symbolischen Namen
 *
 *  TYPDEFINITION:
 *     [RECORD
 *        var [void*] - Zeiger auf Variable
 *        sym [Tom_TYPE *] - Tom-Tabelle mit Symbolen dazu
 *     ]
 *
 *  BEMERKUNGEN:
 *     Bei Tom_VIEW, Tom_SET und Tom_RESET wird bei den Typen _ENUM und _MASK
 *     statt der Variablen-Adresse immer ein Zeiger auf eine Tom_NAMES-Struk-
 *     tur uebergeben um die Verbindung zu den symbolischen Namen zu schaffen.
 */
typedef struct {
   void *var;
   Tom_TYPE *sym;
} Tom_NAMES;



// ---------------------------------------------------------------------------
// Konstanten zur Kennzeichnung der Datentypen / sonstige Konstanten
// ---------------------------------------------------------------------------

enum {
   _char,      // (signed) char
   _short,     // (signed) short int
   _int,       // (signed) int
   _long,      // (signed) long int
   _uchar,     // unsigned char
   _ushort,    // unsigned short int
   _uint,      // unsigned int
   _ulong,     // unsigned long int
   _bool,      // bool
   _float,     // float
   _double,    // double
   _ldouble,   // long double

   _ptr,       // void*
   _TEXT,      // char*
   _STR,       // char[]

   _ENUM,      // Aufzaehltyp (int)
   _MASK,      // Bitmasken (unsigned int)

   _DEG,       // Radiant??? / Grad??? (double)

   _ENUM_O,    // Aufzaehltyp OHNE Tom_NAMES-Struktur
   _MASK_O,    // Maskentyp OHNE Tom_NAMES-Struktur

   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   Tom_BREAK = 22222    // besonderer Abbruch-Level fuer Tom_Jump
};



// ---------------------------------------------------------------------------
// DIE TOMATEN - HAUPTKLASSE
// ---------------------------------------------------------------------------

class __ECL_DLLEXPORT__ cTomate {

   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // Parametrisierungs- und interne Konstanten
private:
   enum {
      TOM_ISTACK_MAX =   10,  // Schachtelungstiefe fuer Eingabedateien

      TOM_BUF_MAX    =  100,  /* Laenge des Eingabepuffers */
      TOM_TOK_MAX    =   32,  /* max. Tokenlaenge fuer Ausgabe */
      TOM_STK_MAX    =   10,  /* Groesse des Zeilenstack */
      TOM_PRM_MAX    =   40,  /* maximale Pfadlaenge im Prompt */

      TOM_OCON       = 0x01,  /* Masken fuer TomOMode */
      TOM_OFILE      = 0x02
   };
   #define TOM_AUTO_VAR "ECL_AUTOMATE"


   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // Sonstige Konstanten
public:
   enum {
      // Diese Konstanten stehen beim Aufruf irgendwelcher Gate-Funktionen in
      // der Komponente "value" des beigepackten Tom-Tabellen-Eintrages.
      // Nur so, just for fun, aus Langeweile ...
      TOM_IDINIT    = 1,   // Kennzeichnung fuer Tom_GATES/init-Funktion
      TOM_IDEXIT    = 2,   // Kennzeichnung fuer Tom_GATES/exit-Funktion
      TOM_IDPARAM   = 3,   // Kennzeichnung fuer Tom_GPARAM-Funktion
      TOM_IDLEVEL   = 4,   // Kennzeichnung fuer Tom_GLEVEL-Funktion
      TOM_IDPROTECT = 5,   // Kennzeichnung fuer Tom_PROTECT-Funktionen

      // Werte von TOM_ENDE & TOM_DEFAULT am 16.05.2000 geaendert !!!
      // Dadurch werden alte (falsche) Default-Eintraege zu einem Tabellenende !!!
      TOM_DEFAULT    =    0,  /* minlen fuer Default-Eintrag, neuer Code */
      TOM_DEFAULT1   =   -1,  /* minlen fuer Default-Eintrag, alter Code */
      TOM_DUMMY      =   -2,  /* minlen fuer Dummy-Eintraege */
      TOM_PROTECT    =   -3,  /* minlen fuer Protect-Eintraege */
      TOM_ENDE       =   -4   /* minlen fuer Tabellenende, frueher 0 */
   };


   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // interne Datentypen
private:
   /*
    *
    * TYPNAME:
    *    Tom_ENV - Garten-Typ fuer Tomaten-Umgebungsvariable
    *
    * BESCHREIBUNG:
    *    Dieser Typ ist *NICHT* Teil irgendeiner Schnittstelle !!!
    *
    */

   typedef struct _tomenv {
      /* Allgemeiner Teil mit der Umgebungsverzeigerung: */
      struct _tomenv *envold;  /* Zeiger auf vorangehende Umgebung */
      jmp_buf jmpbuf;          /* Zustandsvariable fuer longjmp */
      int level;               /* Nummer der Umgebung */

      /* Identifikation der Funktion aus der die Umgebung ist: */
      bool start;              /* true = Tom_Start, false = Tom_Level */

      Tom_TYPE *shortcut;      /* Benutzerdefinierte immer-Befehle,
                                  wird nur in Tom_Start gesetzt */

      /* nur in Tom_Level-Umgebungen definierte Komponenten: */
      Tom_TYPE *curtt;         /* aktuelle Tom-Tabelle */
      char *prompt;            /* Prompt der Umgebung */
   } Tom_ENV;

   /* Struktur fuer Zeilenstack: */
   typedef struct {
      char *line;
      char **script;
   } Tom_LINE;


   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // offizielle Schnittstelle
public:
   // ehemals: void Tom_Init ( ToCo_INTERFACE *toco );
   cTomate(cTomConsole *toco=NULL);
   // ehemals: void Tom_Exit ( void );
   ~cTomate();

   // Kommandozeile hinterlegen
   static void Arg( int argc, char **argv );

   // klassischer Tomate-Start
   static void Start ( Tom_TYPE *root, Tom_TYPE *global );

   #if USE_THREAD
      // Tomate in einem eigenen Thread starten
      void Thread ( Tom_TYPE *root, Tom_TYPE *global );
   #endif

   static int _vprintf ( char* , va_list );     // Aufrufmacro: Tom_vprintf
   static char *_GetS ( char*, char* );         // Aufrufmacro: Tom_GetS
   static int _Jump ( int );                    // Aufrufmacro: Tom_Jump
   static bool _GetLong ( char**, long* );      // Aufrufmacro: Tom_GetLong
   static bool _GetInt ( char**, int* );        // Aufrufmacro: Tom_GetInt
   static bool _GetDouble ( char**, double* );  // Aufrufmacro: Tom_GetDouble
   static bool _GetArg ( char**, char*, int );  // Aufrufmacro: Tom_GetArg
   static bool _GetStr ( char**, char*, int );  // Aufrufmacro: Tom_GetStr
   // int Tom_printf ( char*, ... );            // globale (Igitt) Funktion
   static char *_PutEnum( int, Tom_TYPE* );     // Aufrufmacro: Tom_PutEnum

   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // interne Aktionsfunktionen fuer die Tomaten-Tabellen-Konstruktions-Macros
public:
   static char *_Param ( char *line, Tom_TYPE *tt );
   static char *_With ( char *line, Tom_TYPE *tt );
   static char *_Level ( char *line, Tom_TYPE *tt );
   static char *_Script ( char *line, Tom_TYPE *tt );
   static char *_Alias ( char *line, Tom_TYPE *tt );
   static char *_Dummy ( char *line, Tom_TYPE *tt );
   static char *_DummyEnd ( char *line, Tom_TYPE *tt );

   static char *_Set ( char *line, Tom_TYPE *tt );
   static char *_Reset ( char *line, Tom_TYPE *tt );
   static char *_View ( char *line, Tom_TYPE *tt );
   static char *_Const ( char *line, Tom_TYPE *tt );


   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // "echte" interne Funktionen ...
private:
   static void Tom_LnPush ( char *, char ** );
   static char *Tom_LnPop ( void );

   static char *TomCompTokens ( char*, char*, int );
   static Tom_TYPE *TomFindToken ( Tom_TYPE*, char*, char** );
   static Tom_TYPE *TomEscape ( Tom_TYPE*, char*, char** );
   static char *TomPutWord ( char* );
   static char *TomPutEnum ( int*, Tom_TYPE* );
   static char *TomGetEnum ( char*, int*, Tom_TYPE* );
   static char *TomPutMask ( unsigned int*, unsigned int*, Tom_TYPE* );
   static char *TomGetMask ( char*, unsigned int*, unsigned int*, Tom_TYPE* );
   static char *TomPutPath ( Tom_ENV*, char*, int, int );
   static void TomTokList ( Tom_TYPE* );


   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // ... und Daten
private:
   static bool TomQuiet;                        // Ausgabe unterdruecken
   static bool TomPrompt;                       // true fuer Pfad-Prompt, false sonst

   static int TomOMode;                         // Ausgabemode: b0=Con, b1=File
   static FILE *TomOFile;                       // Ausgabestrom
   static FILE *TomIFile;                       // Eingabestrom

   static FILE *TomIStack[TOM_ISTACK_MAX];      // Stack fuer Eingabedateien
   static int TomIStackPtr;                     // Index in TomIStack

   static int TomMore;                          // Eingestellte More-Zeilenzahl
   static int TomMCnt;                          // aktueller More-Zeilenzaehler
   static char TomBuf[TOM_BUF_MAX];             // Eingabepuffer

   static bool TomDefCon;                       // true bei Standard-Konsole
   static cTomConsole *TomCon;                  // Konsolen-Treiber

   static Tom_LINE TomLnStack[TOM_STK_MAX];     // Feld fuer Zeilenstack
   static int TomLnSP;                          // Zeilenstack-Zeiger

   static Tom_ENV *Tom_Env;                     // Umgebungs-Struktur

   static int TomTID;                           // Thread-ID

   static int TomArgC;                          // Kommandozeile
   static char **TomArgV;

   // Helferlein, die die Tomate verstaendlicher lesbarer machen
   static const char * const TomTypes[];        // Typenbezeichner
   static const int TomSizes[];                 // Groessen der Datentypen (fuer Tom-Tools)
   static const bool TomHelp[];                 // Typen mit Minimal-Hilfe ## und die anderen ???
   static const Tom_TYPE cTomate::TomBools[];   // erlaubte Bool-Werte


   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // Zugriffsfunktionen fuer die internen Variablen (zur besonderen Verwendung)
public:
   // Umgebungsinformationen fuer ToTo_Tree
   static void getTomEnv( char **prompt, int *level, Tom_TYPE **tomtab );
   static const int *getTomSizes();
   // Thread-ID festhalten
   static void setTid(int tid);


   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   // interne Tomaten-Konstruktionen zur Steuerung der Tomate
private:
   // Wurzel der immer-und-ueberall erreichbaren Tom-Befehle
   static const Tom_TYPE TomInternal[];

   // Aktionsfunktion der Tomatensteuerung
   static char *_tomcontrol( char *line , Tom_TYPE *tt );
   // Kennungen der verfuegbaren Funktionalitaeten
   enum {
      TOM_ECHO,
      TOM_VIEW,
      TOM_PATH,
      TOM_GOTO,
      TOM_OUTF,
      TOM_WAIT,
      TOM_CHWD,
      TOM_RUNS,
      TOM_VSET,
      TOM_VGET,
      TOM_VINS,
      TOM_VCMD
   };
   // weitere Tabellenteile ...
   static const Tom_TYPE _tompath[];      // Moeglichkeiten des PATH-Befehls
   static const Tom_TYPE _tomquiet[];     // Moeglichkeiten des QUIET-Befehls
   static const Tom_TYPE _tomofile[];     // Moeglichkeiten der Ausgabeumleitung
   static const Tom_TYPE _tomfunc[];      // immer-und-ueberall Tom-Befehlen
   static const char _tomhelp[];          // Text der bei HELP ausgegeben wird
   static const char _tomversion[];       // Text der bei VERSION ausgegeben wird
};



// ===========================================================================
// Definition cTomThread
// ---------------------------------------------------------------------------
//
// cTomThread -
//
// ---------------------------------------------------------------------------

class cTomThread : public cThread {
   Tom_TYPE *root;
   Tom_TYPE *global;
public:
   cTomThread() : cThread( cThread::tdAutoDel) {}
   void setParameter(Tom_TYPE *r, Tom_TYPE *g) { root = r; global = g; }

   virtual int onMain(void *extra);
};


// ---------------------------------------------------------------------------
// globale Funktionen / Macros fuer statische Funktionen
// ---------------------------------------------------------------------------

//## TBD Doku

__ECL_EXP1__ int __ECL_EXP2__ Tom_printf ( char*, ... );

#define Tom_vprintf( fmt , ap )        cTomate::_vprintf( fmt , ap )
#define Tom_GetS( prompt, str )        cTomate::_GetS( prompt, str )
#define Tom_Jump( level )              cTomate::_Jump( level )
#define Tom_GetLong( line, value )     cTomate::_GetLong( line, value )
#define Tom_GetInt( line, value )      cTomate::_GetInt( line, value )
#define Tom_GetDouble( line, value )   cTomate::_GetDouble( line, value )
#define Tom_GetArg( line, buf, size )  cTomate::_GetArg( line, buf, size )
#define Tom_GetStr( line, buf, size )  cTomate::_GetStr( line, buf, size )
#define Tom_PutEnum( var, tt )         cTomate::_PutEnum( var, tt )
// macht ein statischer Start Sinn? Frueher war es jedenfalls moeglich ...
#define Tom_Start( root, global )      cTomate::Start( root, global )



// ---------------------------------------------------------------------------
// Macros zur Konstruktion der Tomate-Tabellen
// ---------------------------------------------------------------------------

/**.SC.***********************************************************************
*
*  MACRONAME:
*     Tom_COMMENT - Kommentare in Tabelle erzeugen
*
*  AUFRUF:
*     Tom_COMMENT( comment )
*
*  PARAMETER:
*     comment IN [char *] - beliebiger Text der bei '?' an dieser Stelle
*        in der Tabelle ausgegeben wird.
*
**.EC.***********************************************************************/

/**
 * Dummy-Zeile die lediglich einen Text (Kommentar) anzeigt
 */
#define Tom_COMMENT( str ) \
               (Tom_FUNC) cTomate::_Dummy , 0 , NULL , NULL , cTomate::TOM_DUMMY, str ,


/**.SC.***********************************************************************
*
*  MACRONAME:
*     Tom_PROMT - Tabellenende bei Eingabestufen
*     Tom_GATES - Tabellenende bei Eingabestufen mit Ein/Ausgangskontrolle
*     Tom_ENDE - Ende bei allen anderen Tabellen
*
*  AUFRUF:
*     Tom_PROMPT( prompt )
*     Tom_GATES( init, exit, prompt )
*     Tom_ENDE()
*
*  PARAMETER:
*     prompt IN [char *] - Prompt-String, ein %d wird durch die Nummer der
*        aktuellen Eingabestufe ersetzt (oder NULL fuer ein Default-Prompt).
*     init IN [char *(*)(char*,Tom_TYPE*)] - Adresse einer Benutzerfunktion
*        die beim Betreten einer Eingabestufe zur Initialisierung aufgerufen
*        wird oder NULL wenn darauf verzichtet wird.
*     exit IN [char *(*)(char*,Tom_TYPE*)] - Adresse einer Benutzerfunktion
*        die beim Verlassen einer Eingabestufe zur Deinitialisierung aufge-
*        rufen wird oder NULL wenn darauf verzichtet wird.
*
*  BEMERKUNGEN:
*     Eines dieser Macros muss am Ende JEDER Tabelle stehen. Die Funktionen
*     init und exit muessen folgender Definition entsprechen:
*
*     AUFRUF:
*        rest = init( line , tt )
*        rest = exit( line , tt )
*
*     PARAMETER:
*        rest RESULT [char *] - NULL falls das Betreten bzw. das Verlassen
*           der Eingabestufe nicht erlaubt ist, sonst noch nicht ausgewer-
*           teter Teil der uebergebenen Eingabezeile (oder sonst eine Zeile
*           mit der weitergearbeitet werden soll).
*        line IN [char *] - Eingabezeile fuer Parameterauswertung, wird
*           i. d. R. immer zurueckgegeben, wenn der Funktionswert nicht
*           NULL ist.
*        tt IN [Tom_TYPE *] - Variable mit dem Tom-Tabellen-Eintrag, der
*           die Definition der Gate-Funktion(en) und es Prompts enthaelt.
*           Folgende Komponente ist immer belegt:
*
*              tt->value = TOM_IDINIT - beim Aufruf der Init-Funktion.
*              tt->value = TOM_IDEXIT - beim Aufruf der Exit-Funktion.
*
*           Beim Aufruf einer Init-Funktion koennen noch die folgenden
*           Komponenten (sinnvoll) geaendert werden:
*
*              tt->token [char *] - Prompt-String mit dem sich diese
*                 Eingabestufe melden soll (dynamische Prompts).
*              tt->ptr2 [char *(*)(char*,Tom_TYPE*)] - Zeiger auf die
*                 Exit-Funktion, die beim Verlassen der Eingabestufe
*                 aufgerufen werden soll.
*
*           Als Default sind die in der Tabellen-Definition angegebenen
*           Werte eingetragen.
*
**.EC.***********************************************************************/

/**
 * Tabellenende mit Prompt (bei Eingabestufen)
 */
#define Tom_PROMPT( str ) \
               (Tom_FUNC) cTomate::_DummyEnd , 0 , NULL , NULL , cTomate::TOM_ENDE, str

/**
 * Tabellenende mit Prompt und Initialisierungs/Deinitialisierungsfunktionen
 */
#define Tom_GATES( onEnter , onLeave , str ) \
               (Tom_FUNC) cTomate::_DummyEnd , 0 , (void *) onEnter , (void *) onLeave , cTomate::TOM_ENDE, str

/**
 * Tabellenende ohne Prompt (bei einfachen Parameterstufen)
 */
#define Tom_ENDE( ) \
               (Tom_FUNC) cTomate::_DummyEnd , 0 , NULL , NULL , cTomate::TOM_ENDE, NULL


/**.SC.***********************************************************************
*
*  MACRONAME:
*     Tom_LEVEL - Verweis auf naechste Eingabestufe
*     Tom_PARAM - Verweis auf naechste Tokenstufe
*
*  BESCHREIBUNG:
*     Mit diesen Elementar-Macros wird die Baumstruktur der Tomate realisiert,
*     mit Tom_LEVEL erreichte Eingabestufen muessen wieder explizit mit '.'
*     oder '/' verlassen werden.
*
*  AUFRUF:
*     Tom_LEVEL( tomtab, minlen, token )
*     Tom_PARAM( tomtab, minlen, token )
*
*  PARAMETER:
*     tomtab IN [Tom_TYPE *] - die Tom-Tabelle der naechsten Stufe
*     minlen IN [int] - signifikante Laenge
*     token IN [char *] - Tokenstring
*
**.EC.***********************************************************************/

/**
 * Verweis auf naechste Eingabestufe
 */
#define Tom_LEVEL( tomptr , min , token ) \
               (Tom_FUNC) cTomate::_Level , 0 , (void*)(tomptr) , NULL , min , token ,

/**
 * Verweis auf naechste Tokenstufe
 */
#define Tom_PARAM( tomptr , min , token ) \
               (Tom_FUNC) cTomate::_Param , 0 , (void*)(tomptr) , NULL , min , token ,


/**.SC.***********************************************************************
*
*  MACRONAME:
*     Tom_GLEVEL - Verweis auf naechste Eingabestufe (mit Gatefunktion)
*     Tom_GPARAM - Verweis auf naechste Tokenstufe (mit Gatefunktion)
*
*  BESCHREIBUNG:
*     Diese Macros sind Varianten von Tom_PARAM und Tom_LEVEL mit einer
*     Gate-Funktion, die nach erkennen des aktuellen Tokens immer auf-
*     gerufen wird, noch bevor die nachfolgende Tom-Tabelle bearbeitet
*     wird.
*
*  AUFRUF:
*     Tom_GLEVEL( tomtab, gate, minlen, token )
*     Tom_GPARAM( tomtab, gate, minlen, token )
*
*  PARAMETER:
*     tomtab IN [Tom_TYPE *] - die Tom-Tabelle der naechsten Stufe
*     gate IN [char *(*)(char*,Tom_TYPE*)] - Adresse der Gatefunktion
*     minlen IN [int] - signifikante Laenge
*     token IN [char *] - Tokenstring
*
*  BEMERKUNGEN:
*     Der Funktionswert NULL von gate hat, im Gegensatz zu anderen Gate-
*     funktionen, keinen unmittelbaren Abbruch zur Folge. Lediglich die
*     Textzeile wird geloescht. Definition der Funktion gate:
*
*     AUFRUF:
*        rest = gate( line , tt )
*
*     PARAMETER:
*        rest RESULT [char *] - noch nicht ausgewerteter Teil der ueber-
*           gebenen Eingabezeile, NULL verwirft nur die Eingabe.
*        line IN [char *] - Eingabezeile fuer Parameterauswertung, wird
*           i. d. R. immer zurueckgegeben.
*        tt IN [Tom_TYPE *] - Variable mit dem Tom-Tabellen-Eintrag, der
*           die Definition der Gate-Funktion enthaelt. Folgende Komponente
*           ist immer belegt:
*
*              tt->value = TOM_IDPARAM - beim Aufruf der Param-Funktion.
*              tt->value = TOM_IDLEVEL - beim Aufruf der Level-Funktion.
*
*           Es kann folgende Komponente (sinnvoll) geaendert werden:
*
*              tt->ptr1 [Tom_TYPE *] - Zeiger auf die nachgeschaltete
*                 Tom-Tabelle mit der Definition der Parameter- bzw.
*                 Eingabestufe, die erreicht werden soll. Default ist
*                 der Wert aus der Tabellen-Definition.
*
*     Bei Tom_LEVEL ist diese Gate-Funktion unabhaengig von via Tom_GATES
*     definierten Funktionen, d.h. um einen Level koennen sich bis zu drei
*     Gate-Funktionen tummeln. Damit kann man viele schweinische Dinge
*     machen, nicht?
*
**.EC.***********************************************************************/

#define Tom_GPARAM( tomptr , gate , min , token ) \
               (Tom_FUNC) cTomate::_Param , 0 , (void*)(tomptr) , (void*)(gate) , min , token ,

#define Tom_GLEVEL( tomptr , gate , min , token ) \
               (Tom_FUNC) cTomate::_Level , 0 , (void*)(tomptr) , (void*)(gate) , min , token ,


/**.SC.***********************************************************************
*
*  MACRONAME:
*     Tom_WITH - Verweis auf naechste Tokenstufe (mit besonderen Parametern)
*
*  BESCHREIBUNG:
*     Noch eine trickreiche Variante von Tom_PARAM mit der zwei (!) unter-
*     schiedliche Tokenstufen vermischt werden koennen: Mit dem aktuellen
*     Tabelleneintrag wird die Aktionsfunktion der mit tomtab nachfolgenden
*     Stufe aufgerufen!
*
*  AUFRUF:
*     Tom_WITH( value , ptr1 , tomtab, minlen, token )
*
*  PARAMETER:
*     value IN [int] - Tabelleneintrag 'value'
*     ptr1 IN [void*] - Tabelleneintrag 'ptr1'
*     tomtab IN [Tom_TYPE *] - die Tom-Tabelle der naechsten Stufe
*     minlen IN [int] - signifikante Laenge
*     token IN [char *] - Tokenstring
*
*  BEMERKUNGEN:
*     Es koennen in der nachgeschalteten Tabelle nur Aktionsfunktionen ver-
*     wendet werden, die sich am Parameter ptr2 = NULL nicht stoeren, egal
*     ob vom Benutzter oder intern definiert.
*
*
**.EC.***********************************************************************/

#define Tom_WITH( value , ptr1 , tomptr , min , token ) \
               (Tom_FUNC) cTomate::_With , (int)(value) , (void*)(ptr1) , (void*)(tomptr) , min , token ,


/**.SC.***********************************************************************
*
*  MACRONAME:
*     Tom_SET - Variable eines bestimmten Typs setzen
*     Tom_RESET - Bitmaske in Variable ruecksetzen
*
*  AUFRUF:
*     Tom_SET( type, ptr, minlen, token )
*     Tom_RESET( type, ptr, minlen, token )
*
*  PARAMETER:
*     type IN [int] - Variablentyp
*     ptr IN [void*] - Zeiger auf die Variable bzw. Variablenreferenz
*     minlen IN [int] - signifikante Laenge
*     token IN [char *] - Tokenstring
*
*  BEMERKUNGEN:
*     Die Typen _TEXT und _PTR koennen nicht veraendert werden. Beim Typ
*     _STR wird der gesamte Rest der Eingabezeile unabhaengig von der
*     Groesse des char-Feldes kopiert.
*     Tom_RESET ist nur fuer Variablen vom Typ _MASK definiert und unter-
*     scheidet sich von Tom_SET nur dadurch, dass der in Tom_MASK angegebene
*     Wert fuer 'value' negiert wird (_ON wird zu _OFF und umgekehrt).
*
**.EC.***********************************************************************/

#define Tom_SET( type , varptr , min , token ) \
               (Tom_FUNC) cTomate::_Set , (int)(type) , (void*)(varptr) , NULL , min , token ,

#define Tom_RESET( type , varptr , min , token ) \
               (Tom_FUNC) cTomate::_Reset , (int)(type) , (void*)(varptr) , NULL , min , token ,

#define Tom_SET_ENUM( tomptr , varptr , min , token ) \
               (Tom_FUNC) cTomate::_Set , (int)_ENUM_O , (void*)(varptr) , (void*)(tomptr) , min , token ,

/* ## Erweiterung ???
#define Tom_SET_MASK( tomptr , varptr , min , token ) \
               Tom_Set , (int)_MASK_O , (void*)(varptr) , (void*)(tomptr) , min , token ,

#define Tom_RESET_MASK( tomptr , varptr , min , token ) \
               Tom_Set , (int)_MASK_O , (void*)(varptr) , (void*)(tomptr) , min , token ,
*/


/**.SC.***********************************************************************
*
*  MACRONAME:
*     Tom_VIEW - Variable eines bestimmten Typs anzeigen
*     Tom_VIEW_ENUM - Enum-Variable anzeigen
*     Tom_VIEW_MASK - Bitmaske anzeigen
*
*  AUFRUF:
*     Tom_VIEW( type, ptr, minlen, token )
*     Tom_VIEW_ENUM( symbols, ptr, minlen, token )
*     Tom_VIEW_MASK( symbols, ptr, minlen, token )
*
*  PARAMETER:
*     type IN [int] - Variablentyp
*     symbols IN [Tom_TYPE*] - Tom-Tabelle mit den Symbolinformationen
*     ptr IN [void*] - Zeiger auf die Variable
*     minlen IN [int] - signifikante Laenge
*     token IN [char *] - Tokenstring
*
*  BEMERKUNGEN:
*     Ausser beim Typ _TEXT wird immer noch der vollstaendige Tokenname und
*     der Variablentyp mit ausgegeben.
*
**.EC.***********************************************************************/

#define Tom_VIEW( type , varptr , min , token ) \
               (Tom_FUNC) cTomate::_View , (int)(type) , (void*)(varptr) , NULL , min , token ,

#define Tom_VIEW_ENUM( tomptr , varptr , min , token ) \
               (Tom_FUNC) cTomate::_View , (int)_ENUM_O , (void*)(varptr) , (void*)(tomptr) , min , token ,

#define Tom_VIEW_MASK( tomptr , varptr , min , token ) \
               (Tom_FUNC) cTomate::_View , (int)_MASK_O , (void*)(varptr) , (void*)(tomptr) , min , token ,


/**.SC.***********************************************************************
*
*  MACRONAME:
*     Tom_CONST - Variable mit Konstante belegen
*
*  AUFRUF:
*     Tom_CONST( type, ptr, value, minlen, token )
*
*  PARAMETER:
*     type IN [int] - Variablentyp
*     ptr IN [void*] - Zeiger auf die Variable
*     value IN [???] - Konstante entsprechend dem Variablentyp
*     minlen IN [int] - signifikante Laenge
*     token IN [char *] - Tokenstring
*
*  BEMERKUNGEN:
*     Initialisierungen fuer _STR sind nicht moeglich. Alle Initialisierungs-
*     werte in 'value' werden als 'void*' abgespeichert, Reibungsverluste
*     massgeblicher Stellen sind bei der hin- und her-casterei moeglich!
*
**.EC.***********************************************************************/

#define Tom_CONST( type , varptr , value , min , token ) \
               (Tom_FUNC) cTomate::_Const , (int)(type) , (void*)(varptr) , (void*)(value) , min , token ,


/**.SC.***********************************************************************
*
*  MACRONAME:
*     Tom_ENUM - Komponente eines Enum-Typs definieren
*     Tom_MASK - Bitmaske eines Masken-Typs definieren
*
*  BESCHREIBUNG:
*     Eine Enum- oder Masken-Definition besteht aus einer Tom-Tabelle die
*     ausser dem Tom_ENDE() am Schluss nur aus Tom_ENUM- bzw. Tom_MASK-
*     Macros bestehen.
*
*  AUFRUF:
*     Tom_ENUM( value, minlen, token )
*     Tom_MASK( value, mask, minlen, token )
*
*  PARAMETER:
*     value IN [int] - Wert der Enum-Komponente
*     mask IN [unsigned int] - Bitmaske
*     minlen IN [int] - signifikante Laenge
*     token IN [char *] - Tokenstring
*
*  BESCHREIBUNG:
*     Fuer 'value' in Tom_MASK gibt's noch Konstanten: _ON und _OFF
*
**.EC.***********************************************************************/

#define Tom_ENUM( value , min , token ) \
               (Tom_FUNC) cTomate::_Dummy , (int)(value) , NULL , NULL , min , token ,

#define Tom_MASK( value , mask , min , token ) \
               (Tom_FUNC) cTomate::_Dummy , (int)(value) , (void*)(mask) , NULL , min , token ,


/**.SC.***********************************************************************
*
*  KONSTANTENNAME:
*     _ON - Bits in einer Maske setzen
*     _OFF - Bits in einer Maske ruecksetzen
*
**.EC.***********************************************************************/

#define _OFF   0
#define _ON   ~0


/**.SC.***********************************************************************
*
*  MACRONAME:
*     Tom_SCRIPT - Befehlssequenz abarbeiten
*     Tom_ALIAS - Token durch Befehlszeile ersetzen
*
*  BESCHREIBUNG:
*     'tomtab' ist der Level (!) von dem aus die Script-Befehle abgearbeitet
*     werden. Die Befehlsliste muss mit NULL enden.
*
*  AUFRUF:
*     Tom_SCRIPT( script, tomtab, minlen, token )
*     Tom_ALIAS( cmdline, minlen, token )
*
*  PARAMETER:
*     script IN [char **] - Befehlsliste, mit NULL abgeschlossen.
*     cmdline IN [char *] - Befehlszeile die nach dem Token weiter
*        ausgefuehrt werden soll.
*     tomtab IN [Tom_TYPE *] - Level (!) auf den sich die Befehle beziehen.
*     minlen IN [int] - signifikante Laenge
*     token IN [char *] - Tokenstring
*
**.EC.***********************************************************************/

#define Tom_SCRIPT( script , tomptr , min , token ) \
               (Tom_FUNC) cTomate::_Script , 0 , (void*)(script) , (void*)(tomptr) , min , token ,

#define Tom_ALIAS( cmdline , min , token ) \
               (Tom_FUNC) cTomate::_Alias , 0 , (void*)(cmdline) , NULL , min , token ,


/**.SC.***********************************************************************
*
*  MACRONAME:
*     Tom_PROTECT - Tabellenbereiche schuetzen
*
*  AUFRUF:
*     Tom_PROTECT( func )
*
*  PARAMETER:
*     func IN [char *(*)(char*,Tom_TYPE*)] - Adresse einer Benutzerfunktion
*        die an dieser Stelle bei *JEDEM* Abarbeiten einer Tom-Tabelle da-
*        rueber entscheidet, ob die nachfolgenden Tabelleneintraege beachtet
*        werden. Wird als Funktionsadresse NULL angegeben, dann gelten alle
*        eventuell bestehenden Sperren nicht mehr.
*
*  BEMERKUNGEN:
*     Die Definition der Funktion func entspricht folgendem Schema:
*
*     AUFRUF:
*        rest = func( line , tt )
*
*     PARAMETER:
*        rest RESULT [char *] - NULL sperrt die nachfolgenden Tabellen-
*           Eintraege, jeder andere Wert gibt sie frei.
*        line IN [char *] - Dummy-Parameter, garantiert nicht NULL.
*        tt IN [Tom_TYPE *] - Tom-Tabellen-Eintrag mit der Definition der
*           Schutzfunktion. Folgende Komponente ist immer fest belegt:
*
*              tt->value = TOM_IDPROTECT
*
**.EC.***********************************************************************/

#define Tom_PROTECT( func ) \
               (Tom_FUNC) func , cTomate::TOM_IDPROTECT , NULL , NULL , cTomate::TOM_PROTECT , NULL ,


/**.SC.***********************************************************************
*
*  MACRONAME:
*     Tom_USER - Benutzerfunktion ohne Parameter
*     Tom_USER_W   - ... mit int
*     Tom_USER_WW  - ... mit zwei int
*     Tom_USER_WP  - ... mit int und void*
*     Tom_USER_WPP - ... mit int und zwei void*
*     Tom_USER_P   - ... mit void*
*     Tom_USER_PP  - ... mit zwei void*
*
*  BESCHREIBUNG:
*     Es wird eine benutzerdefinierte Funktion aufgerufen:
*
*     AUFRUF:
*         rest = func( line , tt )
*
*     PARAMETER:
*         rest RESULT [char *] - noch nicht ausgewerteter Teil der ueber-
*            gebenen Eingabezeile ('line' bei Funktionen ohne Parameter
*            und NULL wenn alles verbraucht oder wegen einem Fehler ver-
*            worfen wurde).
*         line IN [char *] - Eingabezeile fuer Parameterauswertung.
*         tt IN [Tom_TYPE *] - Parameterstruktur aus der Tom-Tabelle, mit
*            den Initialisierungen wie im Konstruktionsmacro angegeben.
*
*     Der Aufruf der eigentlich zu testenden Funktionen erfolgt immer aus
*     solchen Benutzerfunktionen heraus.
*
*  AUFRUF:
*     Tom_USER( func, minlen, token )
*     Tom_USER_P( func, ptr1, minlen, token )
*     Tom_USER_PP( func, ptr1, ptr2, minlen, token )
*     Tom_USER_W( func, value, minlen, token )
*     Tom_USER_WP( func, value, ptr1, minlen, token )
*     Tom_USER_WPP( func, value, ptr1, ptr2, minlen, token )
*
*  PARAMETER:
*     func IN [char*(*)()] - Zeiger auf Benutzerfunktion
*     value IN [int] - Initialisierung fuer value-Komponente.
*     ptr1 IN [void*] - Initialisierung fuer ptr1-Komponente.
*     ptr2 IN [void*] - Initialisierung fuer ptr2-Komponente.
*     minlen IN [int] - signifikante Laenge
*     token IN [char *] - Tokenstring
*
**.EC.***********************************************************************/

#define Tom_USER( func , min , token ) \
               (Tom_FUNC) func , 0 , NULL , NULL , min , token ,

#define Tom_USER_W( func , value , min , token ) \
               (Tom_FUNC) func , (int)(value) , NULL , NULL , min , token ,

#define Tom_USER_WW( func , value , value2, min , token ) \
               (Tom_FUNC) func , (int)(value) , (void*)(int)(value2) , NULL , min , token ,

#define Tom_USER_WP( func , value , ptr1 , min , token ) \
               (Tom_FUNC) func , (int)(value) , (void*)(ptr1) , NULL , min , token ,

#define Tom_USER_WPP( func , value , ptr1 , ptr2 , min , token ) \
               (Tom_FUNC) func , (int)(value) , (void*)(ptr1) , (void*)(ptr2) , min , token ,

#define Tom_USER_P( func , ptr1 , min , token ) \
               (Tom_FUNC) func , 0 , (void*)(ptr1) , NULL , min , token ,

#define Tom_USER_PP( func , ptr1 , ptr2 , min , token ) \
               (Tom_FUNC) func , 0 , (void*)(ptr1) , (void*)(ptr2) , min , token ,


/**.SC.***********************************************************************
*
*  MACRONAME:
*     Tom_U     - alias fuer Tom_USER
*     Tom_UW    - alias fuer Tom_USER_W
*     Tom_UWW   - alias fuer Tom_USER_WW
*     Tom_UWP   - alias fuer Tom_USER_WP
*     Tom_UWPP  - alias fuer Tom_USER_WPP
*     Tom_UP    - alias fuer Tom_USER_P
*     Tom_UPP   - alias fuer Tom_USER_PP
*
**.EC.***********************************************************************/

//## Dokumentieren -->
#define Tom_SENUM( tomptr , varptr , min , token ) \
               (Tom_FUNC) cTomate::Tom_Set , (int)_ENUM_O , (void*)(varptr) , (void*)(tomptr) , min , token ,

#define Tom_VENUM( tomptr , varptr , min , token ) \
               (Tom_FUNC) cTomate::_View , (int)_ENUM_O , (void*)(varptr) , (void*)(tomptr) , min , token ,
//## Erweiterungen ---> _MASK_O

#define Tom_U( func , min , token ) \
               (Tom_FUNC) func , 0 , NULL , NULL , min , token ,

#define Tom_UW( func , value , min , token ) \
               (Tom_FUNC) func , (int)(value) , NULL , NULL , min , token ,

#define Tom_UWW( func , value , value2, min , token ) \
               (Tom_FUNC) func , (int)(value) , (void*)(int)(value2) , NULL , min , token ,

#define Tom_UWP( func , value , ptr1 , min , token ) \
               (Tom_FUNC) func , (int)(value) , (void*)(ptr1) , NULL , min , token ,

#define Tom_UWPP( func , value , ptr1 , ptr2 , min , token ) \
               (Tom_FUNC) func , (int)(value) , (void*)(ptr1) , (void*)(ptr2) , min , token ,

#define Tom_UP( func , ptr1 , min , token ) \
               (Tom_FUNC) func , 0 , (void*)(ptr1) , NULL , min , token ,

#define Tom_UPP( func , ptr1 , ptr2 , min , token ) \
               (Tom_FUNC) func , 0 , (void*)(ptr1) , (void*)(ptr2) , min , token ,



#endif

/*.EH.*/
