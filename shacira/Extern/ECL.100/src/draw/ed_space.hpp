/*.SH.*/

/*
 *  Headerfile for module ed_space
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  ed_space.cpp on Wednesday February 06 2002  15:28:49
 */

#ifndef __ed_space__
#define __ed_space__


// Headerfiles
// ===========================================================================

#include "base/eb_geo2d.hpp"
#include "draw/ed_object.hpp"
#include "draw/ed_matrix.hpp"
#include "draw/ed_device.hpp"


// ===========================================================================
// Definition cdSpace
// ---------------------------------------------------------------------------
//
// Definiert ein physikalisches Koordinatensystem (WORLD), das Operationen
// zur Darstellung von grafischen Objekten in phyiskalischen Koordinaten
// bietet. Diese werden ueber eine 3x3-Matrix in ein PAGE-System konvertiert,
// das anschliessend in geraeteabhaengige Koordinaten umgesetzt wird:
//
//   ^                             ^    +----+                 +----------->
//   |               | a b 0 |     |    |    |                 |    +----+
//   |  +-----+      | c d 0 |     |    |    |                 |    |    |
//   |  |     |      | x y 1 |     |    |    |                 |    |    |
//   |  +-----+     ===========>   |    |    |    ==========>  |    |    |
//   |                             |    +----+                 |    |    |
//   +----------->                 +----------->               V    +----+
//
//   WORLD                         PAGE                        LOGICAL
//   Physikalische                 Transformierte              Logische
//   Koordinaten                   Koordinaten                 Koordinaten
//
//   Physikalisch [mm]             Physikalisch [mm]           Logisch [*?]
//   double                        double                      long
//   +x => rechts                  +x => rechts                +x => *?
//   +y => oben                    +y => oben                  +y => *?
//
// Anmerkungen:
//
//  - Die Bedeutung der Koordinaten und die Orientierung der Achsen im
//    LOGICAL-System sind abhaengig vom aktuelle Mapping-Mode (vgl. *?):
//
//                   | +x     | +y     | Einheit
//       ------------+--------+--------+-----------
//        mmDirect   | rechts | unten  | Pixel
//        mmLoMetric | rechts | oben   | 1/10 mm
//        mmHiMetric | rechts | oben   | 1/100 mm
//
//  - Wird keine oder die identische Transformation gesetzt, sind die
//    Koordinatensystem WORLD und PAGE identisch
//
//  - Momentan wird als einzige physikalische Koordinateneinheit nur
//    Millimeter unterstuetzt, was sich zukuenftig aber aendern koennte.
//
//  cBase
//   +--cdSpace
//
// ===========================================================================

class cdMemorySpace;

class __ECL_DLLEXPORT__ cdSpace : public cBase {
   friend class cdMemorySpace;

public:

   // Konstruktor ueber Device
   inline cdSpace(cdDevice *dev) { init(dev); }
   // Copy-Konstruktor
   inline cdSpace(const cdSpace& other) { init(other); }
   // Destruktor
   virtual ~cdSpace();


   // Transformation
   // ==============

   // Transformationmatrix setzen
   cdMatrix setTransform(const cdMatrix& new_tmat);
   // Ruecksetzen der Transformationsmatrix auf Einheitsmatrix
   cdMatrix resetTransform();
   // Transformationmatrix erfragen
   const cdMatrix& getTransform() const;

   // Die folgenden Operationen werden mit der aktuellen
   // Transformationsmatrix verknuepft:

   // Gleichmaessige Skalierung durchfuehren
   void scale(double scale);
   // Unabhaengige Skalierung durchfuehren
   void scale(double scale_x, double scale_y);
   // Translation ueber Koordinatenpaar durchfuehren
   void translate(double dx, double dy);
   // Translation ueber Vektor durchfuehren
   void translate(const c2dVector& new_offset);
   // Rotation ueber Winkel (Bogenmass) durchfuehren
   void rotate(double angle);
   // Rotation ueber sin/cos-Werte des Winkels durchfuehren
   void rotate(double sin_angle, double cos_angle);


   // Koordinatenumwandlung
   // =====================

   // WORLD -> PAGE Transformation von Koordinaten
   inline void convWorldToPage(double& x, double& y)
      { tmat.trans(x, y); }
   // WORLD -> PAGE Transformation eines Punktes
   inline c2dPoint convWorldToPage(const c2dPoint& p)
      { return tmat.trans(p); }
   // WORLD -> PAGE Transformation eines Vektors
   inline c2dVector convWorldToPage(const c2dVector& v)
      { return tmat.trans(v); }


   // Position
   // ========

   // Aktuelle WORLD-Position erfragen
   const c2dPoint& getWorldPos() const
      { return pos; }


   virtual void beginDrawing();
   virtual cdDeviceStore *endDrawing();

   virtual void setColor(cdColor color);
   virtual void setBackColor(cdColor color);
   virtual void setFillColor(cdColor fillcolor);
   virtual void setFillPattern(char *pattern);
   virtual void setLineStyle(cdLineStyle linestyle);
   virtual void setLineWidth(long linewidth);
   virtual void setPattern(cdPattern pattern);
   virtual void setForeMix(cdMix mix);
   virtual void setBackMix(cdMix mix);

   virtual void setTextAlign(cdAlign horiz, cdAlign vert);
   virtual void setTextAngle(const c2dVector& dir);

   // Font erzeugen, auswaehlen und loeschen (mehrere Fonts moeglich!)
   virtual long createFont(const char *facename, int pointsize);
   virtual void selectFont(long font_id);
   virtual void deleteFont(long font_id);

   virtual void newFrame();
   virtual void moveTo(const c2dPoint& p);

   virtual void beginArea(bool boundary = true);
   virtual void endArea();

   virtual void draw(const cdObject* obj);
   virtual void draw(const cdObject& obj);
   virtual void draw(const cdMemorySpace *memory_space);
   virtual void draw(const c2dLine& l);
   virtual void draw(const c2dLineSeg& ls);
   virtual void draw(const c2dCircle& c);
   virtual void draw(const c2dArc& a);
   virtual void draw(const c2dBox& a);
   virtual void draw(const char *txt, int length = -1);

   // Zeichen- und Textgroessen erfragen (in mm)
   double queryAvgCharWidth() const;
   double queryAvgCharHeight() const;
   void queryAvgCharSize(double& width, double& height) const;
   double queryTextWidth(const char *text, int length = -1) const;
   double queryTextHeight(const char *text, int length = -1) const;

   cdDevice *getDevice() const
      { return dev; }


private:
   cdDevice *dev;       // Zugeordnetes Device
   cdMatrix tmat;       // Transformationsmatrix

   c2dPoint pos;        // Aktuelle Position in WORLD-Koordinaten
   bool newPos(const c2dPoint& p);
   void init(cdDevice *dev);
   void init(const cdSpace& other);

   long                    cur_fontid;       // Font
   cdColor                 cur_color;        // Farbe
   cdColor                 cur_backcolor;    // Hintergrundfarbe
   cdColor                 cur_fillcolor;    // Fuellfarbe
   long                    cur_linewidth;    // Linienbreite
   cdLineStyle::LINESTYLE  cur_linestyle;    // Linienstil
   cdPattern::PATTERN      cur_pattern;      // Pattern
   cdMix::MIX              cur_foremix;      // Fordergrund-Mix
   cdMix::MIX              cur_backmix;      // Hintergrund-Mix
   cdAlign::ALIGN          cur_halign;       // Horizontales Alignment
   cdAlign::ALIGN          cur_valign;       // Vertikales Alignment

};


// ===========================================================================
// Definition cdMemorySpace
// ---------------------------------------------------------------------------
//
//  cBase
//   +--cdSpace
//       +--cdMemorySpace
//
// ===========================================================================

class __ECL_DLLEXPORT__ cdMemorySpace : public cdSpace {
   friend class cdSpace;

public:
   inline cdMemorySpace() : cdSpace(0) { init(); }
   ~cdMemorySpace();

   cdMatrix setTransform(const cdMatrix& new_tmat);
   cdMatrix resetTransform();
   void scale(double scale);
   void scale(double scale_x, double scale_y);
   void translate(double dx, double dy);
   void translate(const c2dVector& new_offset);
   void rotate(double angle);
   void rotate(double sin_angle, double cos_angle);

   void beginDrawing();
   cdDeviceStore *endDrawing();

   void setColor(cdColor color);
   void setBackColor(cdColor color);
   void setFillColor(cdColor fillcolor);
   void setFillPattern(char *pattern);
   void setLineStyle(cdLineStyle linestyle);
   void setLineWidth(long linewidth);
   void setPattern(cdPattern pattern);
   void setForeMix(cdMix mix);
   void setBackMix(cdMix mix);

   void setTextAlign(cdAlign horiz, cdAlign vert);
   void setTextAngle(const c2dVector& dir);

   void selectFont(long font_id);
   void deleteFont(long font_id);

   void moveTo(const c2dPoint& p);

   void beginArea(bool boundary = true);
   void endArea();

   void draw(const c2dLine& l);
   void draw(const c2dLineSeg& ls);
   void draw(const c2dCircle& c);
   void draw(const c2dArc& a);
   void draw(const c2dBox& a);
   void draw(const char *txt, int length = -1);
   void draw(cdObject*obj)
      { cdSpace::draw(obj); }

private:
   cdSpaceStore *cur_storage;
   cdSpaceStore::ELEM *newElem() const
      { return cur_storage->newElem(); }

   void init();
   void replayAt(cdSpace *space, const c2dPoint& pos) const;

   // Konvertierung wird nicht benoetigt fuer Memory-Spaces
   virtual long onConvPhys2Log(double /*mm*/) const
      { return 0; }
   virtual double onConvLog2Phys(long /*w*/) const
      { return 0; }

   // Folgende Funktion deaktiviert, da sinnlos
   void draw(const cdMemorySpace *)
      { }

};


#endif

/*.EH.*/
