/*.SH.*/

/*
 *  Headerfile for module ed_base
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  ed_base.cpp on Saturday September 08 2001  14:23:52
 */

#ifndef __ed_base__
#define __ed_base__


// Headerfiles
// ===========================================================================

#include "base/eb_geo2d.hpp"

class cdVector;
class cdPoint;
class cdSize;
class cdRect;


// ===========================================================================
// Definition cdColor
// ---------------------------------------------------------------------------
//
//  cdColor
//
// ===========================================================================

class __ECL_DLLEXPORT__ cdColor {

public:
   enum COLOR {
      None, Black, Blue, Red, Pink, Green, Cyan, Yellow, Gray,
      DarkGray, DarkBlue, DarkRed, DarkPink, DarkGreen, DarkCyan, Brown, White,
      Background, Foreground, Undef
   };

   cdColor(COLOR c = None)
      { makeRGBC(color, c); }
   cdColor(unsigned char r, unsigned char g, unsigned char b)
      { makeRGBC(color, r, g, b); }

   operator COLOR() const
      { return COLOR(color.c); }

   bool operator==(const cdColor& other) const;
   bool operator!=(const cdColor& other) const
      { return !(*this == other); }

   // make cdColor object from OS specific code
   static cdColor fromOsVal(long os_val);

   // convert to OS specific code
   static long getOsVal(COLOR c);
   static long getOsVal(unsigned char r, unsigned char g, unsigned char b);
   long getOsVal() const;
   long getOsValRGB() const;

private:
   struct RGBC { unsigned char r, g, b, c; };
   RGBC color;

   static void makeRGBC(RGBC& rgbc, COLOR c);
   static void makeRGBC(RGBC& rgbc, unsigned char r, unsigned char g, unsigned char b);

};


// ===========================================================================
// Definition cdLineStyle
// ---------------------------------------------------------------------------
//
//  cdLineStyle
//
// ===========================================================================

class __ECL_DLLEXPORT__ cdLineStyle {

public:
   enum LINESTYLE {
      Null,       // Keine Linie
      Solid,      // Durchgezogene Linie
      Dot,        // [ ------- ]
      Dash,       // [ ....... ]
      DashDot     // [ _._._._ ]
   };

   cdLineStyle(LINESTYLE ls = Solid)
      { linestyle = ls; }
   operator LINESTYLE() const
      { return linestyle; }

   // convert to OS specific code
   static long getOsVal(LINESTYLE ls);
   long getOsVal() const
      { return getOsVal(linestyle); }

private:
   LINESTYLE linestyle;

};


// ===========================================================================
// Definition cdPattern
// ---------------------------------------------------------------------------
//
//  cdPattern
//
// ===========================================================================

class __ECL_DLLEXPORT__ cdPattern {

public:
   enum PATTERN {
      Null,       // Nicht gefuellt (Hintergrund scheint durch)
      Blank,      // Mit Papierfarbe gefuellt
      Solid,      // Mit Fuellfarbe gefuellt
      Cross,      // [ +++++ ]
      Hatch,      // [ xxxxx ]
      Vert,       // [ ||||| ]
      Horiz,      // [ ----- ]
      Diag1,      // [ \\\\\ ]
      Diag2       // [ ///// ]
   };

   cdPattern(PATTERN pat = Solid)
      { pattern = pat; }
   operator PATTERN() const
      { return pattern; }

   // convert to OS specific code
   static long getOsVal(PATTERN pat);
   long getOsVal() const
      { return getOsVal(pattern); }

private:
   PATTERN pattern;

};


// ===========================================================================
// Definition cdMix
// ---------------------------------------------------------------------------
//
//  cdMix
//
// ===========================================================================

class __ECL_DLLEXPORT__ cdMix {

public:
   enum MIX {
      Overpaint, Leavealone, And, Or, Xor
   };

   cdMix(MIX mix = Overpaint)
      { cdMix::mix = mix; }
   operator MIX() const
      { return mix; }

   // convert to OS specific code
   static long getOsVal(MIX mix);
   long getOsVal() const
      { return getOsVal(mix); }

private:
   MIX mix;

};


// ===========================================================================
// Definition cdAlign
// ---------------------------------------------------------------------------
//
//  cdAlign
//
// ===========================================================================

class __ECL_DLLEXPORT__ cdAlign {

public:
   enum ALIGN {
      Left, Center, Right,       // horizontal alignment
      Top, Half, Base, Bottom    // vertical alignment
   };

   cdAlign(ALIGN a = Left)
      { align = a; }
   operator ALIGN() const
      { return align; }

   // convert to OS specific code
   static long getOsVal(ALIGN a);
   long getOsVal() const
      { return getOsVal(align); }

private:
   ALIGN align;

};


// ===========================================================================
// Definition cdVector
// ---------------------------------------------------------------------------
//
//  cdVector
//
// ===========================================================================

class __ECL_DLLEXPORT__ cdVector {

public:
   int x, y;

   // Konstruktoren
   cdVector()
      { x = y = 0; }
   cdVector(int x, int y)
      { cdVector::x = x;
        cdVector::y = y; }
   cdVector(const cdVector& v)
      { x = v.x;
        y = v.y; }

   // Konstruktion von Vektoren aus spaeter definierten Klassen
   cdVector(const cdSize& p);
   cdVector(const cdPoint& p);

   // Addition/Subtraktion (cdVector x cdVector) => cdVector
   friend cdVector operator+(const cdVector& a, const cdVector& b)
      { return cdVector( a.x + b.x, a.y + b.y ); }
   friend cdVector operator-(const cdVector& a, const cdVector& b)
      { return cdVector( a.x - b.x, a.y - b.y ); }

   // Skalarprodukt (cdVector * cdVector) => int
   friend int operator*(const cdVector& a, const cdVector& b)
      { return a.x*b.x + a.y*b.y; }

   // Multiplikation/Division mit Skalar (cdVector x double) => cdVector
   friend cdVector operator*(const cdVector& a, double r)
      { return cdVector(int(a.x*r), int(a.y*r)); }
   friend cdVector operator/(const cdVector& a, double r)
      { return cdVector(int(a.x/r), int(a.y/r)); }

   // Multiplikation/Division mit Skalar (double x cdVector) => cdVector
   friend cdVector operator*(double r, const cdVector& a)
      { return cdVector(int(r*a.x), int(r*a.y)); }
   friend cdVector operator/(double r, const cdVector& a)
      { return cdVector(int(r/a.x), int(r/a.y)); }

   // Vorzeichenaenderung
   friend cdVector operator-(const cdVector& a)
      { return cdVector(-a.x, -a.y); }

   // Vergleich (cdVector x cdVector) => int
   friend bool operator==(const cdVector& a, const cdVector& b)
      { return a.x == b.x && a.y == b.y; }
   friend bool operator!=(const cdVector& a, const cdVector& b)
      { return a.x != b.x || a.y != b.y; }

   // Rotieren um -90 Grad
   void rotate()
      { int tmp = x; x = -y; y = tmp; }

   // Laenge des Vektors
   int getLengthSqr() const
      { return x*x + y*y; }
   double getLength() const
      { return sqrt(getLengthSqr()); }

   // Winkel (Bogenmass) zwischen zwei Vektoren
   double getAngle(const cdVector& v) const;

};


// ===========================================================================
// Definition cdPoint
// ---------------------------------------------------------------------------
//
//  cdPoint
//
// ===========================================================================

class __ECL_DLLEXPORT__ cdPoint {

public:
   int x, y;

   // Konstruktoren
   cdPoint()
      { x = y = 0; }
   cdPoint(int x, int y)
      { cdPoint::x = x;
        cdPoint::y = y; }
   cdPoint(const cdPoint& p)
      { x = p.x;
        y = p.y; }
   cdPoint(const cdVector& v)
      { x = v.x;
        y = v.y; }

   // Addition/Subtraktion (cdPoint x cdVector) => cdPoint
   friend cdPoint operator+(const cdPoint& p, const cdVector& v)
      { return cdPoint(p.x + v.x, p.y + v.y); }
   friend cdPoint operator-(const cdPoint& p, const cdVector& v)
      { return cdPoint(p.x - v.x, p.y - v.y); }

   // Addition/Subtraktion, Zuweisung (cdPoint x cdVector) => cdPoint
   cdPoint& operator+=(const cdVector& v)
      { x += v.x, y += v.y;
        return *this; }
   cdPoint& operator-=(const cdVector& v)
      { x -= v.x, y -= v.y;
        return *this; }

   // Differenz (cdPoint - cdPoint) => cdVector
   friend cdVector operator-(const cdPoint& a, const cdPoint& b)
      { return cdVector(a.x - b.x, a.y - b.y); }

   // Abstand (cdPoint x cdPoint) => double
   int getDistSqr(const cdPoint& p) const
      { return sqr(x - p.x) + sqr(y - p.y); }
   double getDist(const cdPoint& p) const
      { return sqrt(getDistSqr(p)); }

   // Vergleich (cdPoint x cdPoint) => int
   friend bool operator==(const cdPoint& a, const cdPoint& b)
      { return a.x == b.x && a.y == b.y; }
   friend bool operator!=(const cdPoint& a, const cdPoint& b)
      { return a.x != b.x || a.y != b.y; }

   bool isOrigin() const
      { return x == 0 && y == 0; }

};


// ===========================================================================
// Definition cdSize
// ---------------------------------------------------------------------------
//
//  cdSize
//
// ===========================================================================

class __ECL_DLLEXPORT__ cdSize {

public:
   int cx, cy;

   // Konstruktoren
   cdSize()
      { cx = cy = 0; }
   cdSize(int cx, int cy)
      { cdSize::cx = cx;
        cdSize::cy = cy; }
   cdSize(const cdSize& s)
      { cx = s.cx;
        cy = s.cy; }
   cdSize(const cdVector& v)
      { cx = v.x;
        cy = v.y; }

   // Addition/Subtraktion (cdSize x cdSize) => cdSize
   cdSize operator+(const cdSize& s) const
      { return cdSize(cx + s.cx, cy + s.cy); }
   cdSize operator-(const cdSize& s) const
      { return cdSize(cx - s.cx, cy - s.cy); }

   // Addition/Subtraktion, Zuweisung (cdSize x cdSize) => cdSize
   cdSize& operator+=(const cdSize& s)
      { cx += s.cx;
        cy += s.cy;
        return *this; }
   cdSize& operator-=(const cdSize& s)
      { cx -= s.cx;
        cy -= s.cy;
        return *this; }

   // Multiplikation/Division mit Skalar (cdSize x double) => cdSize
   friend cdSize operator*(const cdSize& s, double r)
      { return cdSize(int(s.cx*r), int(s.cy*r)); }
   friend cdSize operator/(const cdSize& s, double r)
      { return cdSize(int(s.cx/r), int(s.cy/r)); }

   // Multiplikation/Division mit Skalar (double x cdSize) => cdSize
   friend cdSize operator*(double r, const cdSize& s)
      { return cdSize(int(r*s.cx), int(r*s.cy)); }
   friend cdSize operator/(double r, const cdSize& s)
      { return cdSize(int(r/s.cx), int(r/s.cy)); }

   // Vorzeichenaenderung
   friend cdSize operator-(const cdSize& s)
      { return cdSize(-s.cx, -s.cy); }

   bool isNull() const
      { return cx == 0 && cy == 0; }

};


// ===========================================================================
// Definition cdRect
// ---------------------------------------------------------------------------
//
// Rechteck, gegeben durch zwei gegenueberliegende Punkte LB = links unten und
// RT = rechts oben). Zwei Koordinatensysteme werden automatisch unterschieden:
//
//    isMathCoord()    isWindowCoord()
//
//    ^                +------------>
//    |                |
//    |   +-----+RT    |   +-----+RT
//    |   |     |      |   |     |
//    | LB+-----+      | LB+-----+
//    |                |
//    +------------>   V
//
//  cdRect
//
// ===========================================================================

class __ECL_DLLEXPORT__ cdRect {

public:
   cdPoint lb, rt;

   cdRect()
      { lb.x = lb.y = rt.x = rt.y = 0; }

   // Rechteck aus Eckpunkten links unten und rechts oben
   cdRect(int x_left, int y_bottom, int x_right = 0, int y_top = 0)
      { lb.x = x_left; lb.y = y_bottom; rt.x = x_right; rt.y = y_top; }
   cdRect(const cdPoint& l_bottom, const cdPoint& r_top)
      { lb = l_bottom; rt = r_top; }

   // Rechteck aus Startpunkt (links unten) und Groesse
   cdRect(const cdPoint& l_bottom, const cdVector& size_vec);
   cdRect(const cdPoint& l_bottom, const cdSize& size, bool math_coord = true);

   // Addition (cdRect x cdRect) => cdRect
   friend cdRect operator+(const cdRect& r, const cdRect& s);

   // Addition, Zuweisung (cdRect x cdRect) => cdRect
   cdRect& operator+=(const cdRect& r);

   // Groesse des Rechteckes
   cdSize getSize() const;
   int getWidth() const;
   int getHeight() const;

   // Koordinaten der Seiten
   int getXLeft() const
      { return lb.x; }
   int getXRight() const
      { return rt.x; }
   int getYBottom() const
      { return lb.y; }
   int getYTop() const
      { return rt.y; }

   // Eckpunkte
   cdPoint getBottomLeft() const
      { return lb; }
   cdPoint getBottomRight() const
      { return cdPoint(rt.x, lb.y); }
   cdPoint getTopLeft() const
      { return cdPoint(lb.x, rt.y); }
   cdPoint getTopRight() const
      { return rt; }

   bool isEmpty() const
      { return lb == cdPoint() && rt == cdPoint(); }
   bool isMathCoord() const
      { return lb.y <= rt.y; }
   bool isWindowCoord() const
      { return lb.y >= rt.y; }

   void makeMathCoord();
   void makeWindowCoord();

};


// ===========================================================================
// Definition cdViewport
// ---------------------------------------------------------------------------
//
// Beschreibung eines Sichtrechtecks auf       y ^
// eine 2D-Szene, gegeben durch den Start-       |
// punkt (start) und einen Skalierungs-          |     +--------+
// faktor (scale). Der Startpunkt liegt          |     |        |
// bezueglich des Sichtrechteckes in der         |     |        |
// linken unteren Ecke.                          |     |        |
//                                               |     |        |
//                                               |     X--------+
//                                               |  start
//                                               |
//                                               +--------------------->
//                                             0/0                     x
//
//  cdViewport
//
// ===========================================================================

class __ECL_DLLEXPORT__ cdViewport {

public:
   c2dPoint start;
   double scale;

   cdViewport(const c2dPoint& start = c2dPoint(0,0), double scale = 1.0)
      { cdViewport::start = start; cdViewport::scale = scale; }

   // Translation (cdViewport x c2dVector) => cdViewport
   friend cdViewport operator+(const cdViewport& vp, const c2dVector& v)
      { return cdViewport(vp.start + v, vp.scale); }
   friend cdViewport operator-(const cdViewport& vp, const c2dVector& v)
      { return cdViewport(vp.start - v, vp.scale); }

   // Translation, Zuweisung (cdViewport x c2dVector) => cdViewport
   cdViewport& operator+=(const c2dVector& v)
      { start += v;
        return *this; }
   cdViewport& operator-=(const c2dVector& v)
      { start -= v;
        return *this; }

};


#endif

/*.EH.*/
