/*.SH.*/

/*
 *  Headerfile for module ed_device
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  ed_device.cpp on Thursday March 21 2002  15:50:49
 */

#ifndef __ed_device__
#define __ed_device__


// Headerfiles
// ===========================================================================

#include "base/eb_str.hpp"
#include "draw/ed_context.hpp"
#include "draw/ed_store.hpp"


// ===========================================================================
// Definition cdDevice
// ---------------------------------------------------------------------------
//
// Basisklasse fuer grafische Ausgabegeraete
//
// Definiert ein logisches Koordinatensystem (LOGICAL), das Operationen
// zur Darstellung von grafischen Objekten in logischen Koordinaten
// bietet.
//
//   ^    +----+                 +----------->                 +----------->
//   |    |    |                 |    +----+                   |    +----+
//   |    |    |                 |    |    |                   |    |    |
//   |    |    |                 |    |    |                   |    |    |
//   |    |    |    ==========>  |    |    |    ===========>   |    |    |
//   |    +----+                 |    |    |                   |    |    |
//   +----------->               V    +----+                   V    +----+
//
//   PAGE                        LOGICAL                       DEVICE
//   Transformierte              Logische                      Geraete-
//   Koordinaten                 Koordinaten                   Koordinaten
//
//   Physikalisch [mm]           Logisch [*?]                  Pixel
//   double                      long                          long
//   +x => rechts                +x => *?                      +x => rechts
//   +y => oben                  +y => *?                      +y => unten
//
// Anmerkungen:
//
//  - Die Bedeutung der Koordinaten und die Orientierung der Achsen im
//    LOGICAL-System sind abhaengig vom aktuelle Mapping-Mode (vgl. *?):
//
//                      | +x     | +y     | Einheit
//       ---------------+--------+--------+-----------
//        mmDirect      | rechts | unten  | Pixel
//        mmLoMetric    | rechts | oben   | 1/10 mm
//        mmHiMetric    | rechts | oben   | 1/100 mm
//        mmIsotropic   |  - benutzerspezifisch -
//        mmAnisotropic |  - benutzerspezifisch -
//
//  cBase
//   +--cdDevice
//
// ===========================================================================

class cdMemoryDevice;
class STOCK;
class CDC;

class __ECL_DLLEXPORT__ cdDevice : public cBase {

public:

   // Konstruktor
   inline cdDevice() { init(); }
   // Copy-Konstruktor
   inline cdDevice(const cdDevice& other) { init(other); }
   // Destruktor
   virtual ~cdDevice();


   // Allgemeines
   // ===========

   // Alle Einstellung auf Standardwerte zuruecksetzen
   virtual void reset();
   // Kontext an Ausgabegeraet binden
   virtual void bindContext(cdContext *ctxt);
   // Gebundenen Kontext erfragen
   inline void *getBoundContext() const
      { return context; }


   // Skalierung
   // ==========

   enum MAP_MODE {   // Abbildung zwischen logischen und Geraetekoordinaten:
      mmDirect,      //  - Direkte Abbildung auf Geraetekoordinaten
      mmLoMetric,    //  - Abbildung 1/10 mm -> Geraetekoordinaten
      mmHiMetric,    //  - Abbildung 1/100 mm -> Geraetekoordinaten
      mmIsotropic,   //  - Benutzerspezifische Abbildung (Seitenverhaeltnis 1:1)
      mmAnisotropic  //  - Benutzerspezifische Abbildung (freiers Seitenverhaeltnis)
   };

   // Abbildung zwischen logischen und Geraetekoordinaten einstellen
   void setMapMode(MAP_MODE mode);
   // Aktuelle Abbildung zwischen logischen und Geraetekoordinaten erfragen
   inline MAP_MODE getMapMode() const
      { return map_mode; }

   // Mit den folgenden Funktionen wird die Abbidlung zwischen logischen und Geraete-
   // koordinaten in den Mapping-Modi mmIsotropic und mmAnisotropic eingestellt:

   // Ursprung des logischen Koordinatensystems festlegen (in logischen Koordinaten)
   void setLogicalOrigin(int x, int y);
   // Ursprung des logischen Koordinatensystems ueber cdPoint festlegen (in logischen Koordinaten)
   void setLogicalOrigin(const cdPoint& origin);
   // Groesse des logischen Koordinatensystems festlegen (in logischen Koordinaten)
   void setLogicalExtend(int cx, int cy);
   // Groesse des logischen Koordinatensystems ueber cdSize festlegen (in logischen Koordinaten)
   void setLogicalExtend(const cdSize& size);

   // Ursprung des Geraetekoordinatensystems festlegen (in Geraetekoordinaten)
   void setDeviceOrigin(int x, int y);
   // Ursprung des Geraetekoordinatensystems ueber cdPoint festlegen (in Geraetekoordinaten)
   void setDeviceOrigin(const cdPoint& origin);
   // Groesse des Geraetekoordinatensystems festlegen (in Geraetekoordinaten)
   void setDeviceExtend(int cx, int cy);
   // Groesse des Geraetekoordinatensystems ueber cdSize festlegen (in Geraetekoordinaten)
   void setDeviceExtend(const cdSize& size);

   // Ursprung des logischen Koordinatensystems ermitteln
   cdPoint getLogicalOrigin() const;
   // Groesse des logischen Koordinatensystems ermitteln
   cdSize getLogicalExtend() const;
   // Ursprung des Geraetekoordinatensystems ermitteln
   cdPoint getDeviceOrigin() const;
   // Groesse des Geraetekoordinatensystems ermitteln
   cdSize getDeviceExtend() const;


   // Clipping
   // ========

   // Schnittmenge zwischen aktuellem Clip-Bereich und 'rect' bilden
   void intersectClipRect(const cdRect& rect);
   // Kleinstes umschliessendes Rechteck um aktuellen Clip-Bereich ermitteln
   cdRect getClipBox() const;
   // Liegt der Punkt 'point' innerhalb des aktuellen Clip-Bereichs?
   bool isVisible(const cdPoint& point);
   // Liegt irgend ein Teil von 'rect' innerhalb des aktuellen Clip-Bereichs?
   bool isVisible(const cdRect& rect);


   // Druckkontrolle
   // ==============

   // Seitenvorschub einfuegen
   virtual void newFrame();
   // Ausgabe in neues Dokument beginnen
   virtual void startDoc(const char *doc_name);
   // Ausgabe in Dokument beenden
   virtual long endDoc();
   // Ausgabe in Dokument abbrechen
   virtual void abortDoc();


   // Zeichenattribute (OS-spezifische Werte)
   // =======================================

   // Vordergrundfarbe setzen (erwartet OS-spezifische Werte)
   virtual void setColor(long color);
   // Hintergrundfarbe setzen (erwartet OS-spezifische Werte)
   virtual void setBackColor(long color);
   // Fuellfarbe setzen (erwartet OS-spezifische Werte)
   virtual void setFillColor(long fillcolor);
   // Fuellpattern setzen (erwartet OS-spezifische Werte)
   virtual void setFillPattern(char *pattern);
   // Linienstil setzen (erwartet OS-spezifische Werte)
   virtual void setLineStyle(long linestyle);
   // Linienbreite setzen (erwartet OS-spezifische Werte)
   virtual void setLineWidth(long linewidth);
   // Linienmuster setzen (erwartet OS-spezifische Werte)
   virtual void setPattern(long pattern);
   // Vordergrund-Mischmodus setzen (erwartet OS-spezifische Werte)
   virtual void setForeMix(long mix);
   // Hintergrund-Mischmodus setzen (erwartet OS-spezifische Werte)
   virtual void setBackMix(long mix);
   // Textausrichtung setzen (erwartet OS-spezifische Werte)
   virtual void setTextAlign(long horiz, long vert);
   // Zeichenwinkel fuer Texte setzen (erwartet OS-spezifische Werte)
   virtual void setTextAngle(long dir_x, long dir_y);


   // Zeichenattribute (ECL-spezifische Werte)
   // ========================================

   // Vordergrundfarbe setzen
   inline void setColor(const cdColor& color)
      { setColor(color.getOsVal()); }
   // Hintergrundfarbe setzen
   inline void setBackColor(const cdColor& color)
      { setBackColor(color.getOsVal()); }
   // Fuellfarbe setzen
   inline void setFillColor(const cdColor& fillcolor)
      { setFillColor(fillcolor.getOsVal()); }
   // Linienstil setzen
   inline void setLineStyle(const cdLineStyle& linestyle)
      { setLineStyle(linestyle.getOsVal()); }
   // Linienmuster setzen
   inline void setPattern(const cdPattern& pattern)
      { setPattern(pattern.getOsVal()); }
   // Vordergrund-Mischmodus setzen
   inline void setForeMix(const cdMix& mix)
      { setForeMix(mix.getOsVal()); }
   // Hintergrund-Mischmodus setzen
   inline void setBackMix(const cdMix& mix)
      { setBackMix(mix.getOsVal()); }
   // Textausrichtung setzen
   inline void setTextAlign(const cdAlign& horiz, const cdAlign& vert)
      { setTextAlign(horiz.getOsVal(), vert.getOsVal()); }


   // Schriftart erzeugen und ID ermitteln
   virtual long createFont(const char *facename, int pointsize);
   // Schriftart ueber ID auswaehlen
   virtual void selectFont(long font_id);
   // Schriftart freigeben
   virtual void deleteFont(long font_id);

   // Setze RECT fuer kuenftige Operationen auf 'bottom_left', 'top_right'
   virtual void setRect(const cdPoint& bottom_left, const cdPoint& top_right);
   // Setze XRECT fuer kuenftige Operationen auf 'bottom_right', 'top_left'
   virtual void setXRect(const cdPoint& bottom_right, const cdPoint& top_left);

   // Bewege CURSOR auf Position 'pos'
   virtual void moveTo(const cdPoint& pos);

   // Punkt an Position 'point' zeichnen
   virtual void drawPoint(const cdPoint& point);
   // Gerade von CURSOR bis 'line_end'
   virtual void drawLine(const cdPoint& line_end);
   // Kreis um 'center' mit 'radius'
   virtual void drawCircle(const cdPoint& center, long radius);
   // Ellipse innerhalb von RECT/XRECT
   virtual void drawEllipse();
   // Rechteck wie durch RECT/XRECT definiert
   virtual void drawRect();
   // Bogen im Uhrzeigersinn innerhalb RECT/XRECT von CURSOR bis 'arc_end'
   virtual void drawArcCW(const cdPoint& arc_end);
   // Bogen gegen Uhrzeigersinn innerhalb RECT/XRECT von CURSOR bis 'arc_end'
   virtual void drawArcCCW(const cdPoint& arc_end);
   // Text ab Cursor
   virtual void drawText(const char *txt, int length = -1);
   // Memory-Device an Position 'pos' einspielen
   virtual void drawFrom(const cdMemoryDevice *memory_device, const cdPoint& pos);

   // Beginn eines zu fuellenden Bereichs markieren
   virtual void beginArea(bool boundary);
   // Ende eines zu fuellenden Bereichs markieren
   virtual void endArea();

   // Durchschnittliche Zeichengroesse der aktuellen Schriftart erfragen
   void queryAvgCharSize(long& cx, long& cy) const;
   // Exakte Groesse des Strings 'txt' in der aktuellen Schriftart erfragen
   cdSize queryTextSize(const char *txt, int length = -1) const;
   // Exakte Breite des Strings 'txt' in der aktuellen Schriftart erfragen
   long queryTextWidth(const char *txt, int length = -1) const;
   // Exakte Hoehe des Strings 'txt' in der aktuellen Schriftart erfragen
   long queryTextHeight(const char *txt, int length = -1) const;

   // Bewege CURSOR auf Position 'x','y'
   inline void moveTo(int x, int y)
      { moveTo(cdPoint(x, y)); }
   // Punkt an Position 'x','y' zeichnen
   inline void drawPoint(int x, int y)
      { drawPoint(cdPoint(x, y)); }
   // Gerade von CURSOR bis 'x','y'
   inline void drawLine(int x, int y)
      { drawLine(cdPoint(x, y)); }
   // Kreis um 'x','y' mit 'radius'
   inline void drawCircle(int x, int y, long radius)
      { drawCircle(cdPoint(x, y), radius); }


   // Koordinatenumwandlung
   // =====================

   // PAGE -> LOGICAL Transformation eines Punktes
   cdPoint convPageToLog(const c2dPoint& p) const;
   // PAGE -> LOGICAL Transformation eines Vektors
   cdVector convPageToLog(const c2dVector& v) const;
   // PAGE -> LOGICAL Transformation eines Rechtecks
   cdRect convPageToLog(const c2dBox& b) const;

   // LOG -> PAGE Transformation eines Punktes
   c2dPoint convLogToPage(const cdPoint& p) const;
   // LOG -> PAGE Transformation eines Vektors
   c2dVector convLogToPage(const cdVector& v) const;
   // LOG -> PAGE Transformation eines Rechtecks
   c2dBox convLogToPage(const cdRect& r) const;

   // LOGICAL -> DEVICE Transformation eines Punktes
   cdPoint convLogToDev(const cdPoint& p) const;
   // LOGICAL -> DEVICE Transformation einer Groesse
   cdSize convLogToDev(const cdSize& s) const;
   // LOGICAL -> DEVICE Transformation eines Rechtecks
   cdRect convLogToDev(const cdRect& r) const;

   // DEVICE -> LOGICAL Transformation eines Punktes
   cdPoint convDevToLog(const cdPoint& p) const;
   // DEVICE -> LOGICAL Transformation einer Groesse
   cdSize convDevToLog(const cdSize& s) const;
   // DEVICE -> LOGICAL Transformation eines Rechtecks
   cdRect convDevToLog(const cdRect& r) const;


protected:

   // Einfacher Koordinatensatz (RECT = Achsparalleles Zeichenrechteck)
   cdPoint rect_bottom_left;     // - Unten links
   cdPoint rect_top_right;       // - Oben rechts
   // Erweiterter Koordinatensatz (XRECT = Nicht-achsparalleles Zeichenrechteck)
   cdPoint xrect_bottom_right;   // - Unten rechts
   cdPoint xrect_top_left;       // - Oben links

   // Ist XRECT aktiv?
   bool isXRect() const;

   #if defined __ECL_W32__
      void __setDC(CDC *dc);
      CDC *__getDC() const;
   #endif

private:

   #if defined __ECL_OS2__
      static unsigned long hab;
      unsigned long hdc;
      unsigned long hps;
      unsigned long font_ids;
      void *fonts;
      int font_sizes[32];
   #elif defined __ECL_W32__
      CDC *dc;
      STOCK *stock;
      cString font_names[32];
      int font_sizes[32];
   #endif

   // Intern: Initialisierung
   void init();
   // Intern: Initialisierung ueber anderes cdDevice
   void init(const cdDevice& other);

   // Aktuelle Abbildung zwischen logischen und Geraetekoordinaten
   MAP_MODE map_mode;
   // Zeiger auf aktuell an das Geraet gebundenen Kontext
   cdContext *context;

};


// ===========================================================================
// Definition cdRetainedDevice
// ---------------------------------------------------------------------------
//
// Geraet mit Speicher fuer Grafikprimitiven. Innerhalb einer beginDrawing/
// endDrawing-Klammer werden alle Operationen in ein cdStorage-Objekt aufge-
// zeichnet und koennen anschliessend ueber paintAt beliebig oft wieder abge-
// spielt werden. Ausserhalb einer beginDrawing/endDrawing-Klammer werden
// alle Operationen direkt an Methoden der Parent-Klasse weitergegeben.
//
//  cBase
//   +--cdDevice
//       +--cdRetainedDevice
//
// ===========================================================================

class __ECL_DLLEXPORT__ cdRetainedDevice : public cdDevice {

public:
   inline cdRetainedDevice() { init(); }
   inline cdRetainedDevice(const cdDevice& other) : cdDevice(other) { init(); }
   inline cdRetainedDevice(const cdRetainedDevice& other) : cdDevice(other) { init(); }
   ~cdRetainedDevice();

   // Der Aufrufer von endDrawing ist fuer das Freigeben des cdStorage-
   // Objektes verantwortlich!
   void beginDrawing();
   cdDeviceStore *endDrawing();

   virtual void paintAt(cdDeviceStore *elems, const cdPoint& pos);

   // Vordergrundfarbe setzen
   inline void setColor(const cdColor& color)
      { setColor(color.getOsVal()); }
   // Hintergrundfarbe setzen
   inline void setBackColor(const cdColor& color)
      { setBackColor(color.getOsVal()); }
   // Fuellfarbe setzen
   inline void setFillColor(const cdColor& fillcolor)
      { setFillColor(fillcolor.getOsVal()); }
   // Linienstil setzen
   inline void setLineStyle(const cdLineStyle& linestyle)
      { setLineStyle(linestyle.getOsVal()); }
   // Linienmuster setzen
   inline void setPattern(const cdPattern& pattern)
      { setPattern(pattern.getOsVal()); }
   // Vordergrund-Mischmodus setzen
   inline void setForeMix(const cdMix& mix)
      { setForeMix(mix.getOsVal()); }
   // Hintergrund-Mischmodus setzen
   inline void setBackMix(const cdMix& mix)
      { setBackMix(mix.getOsVal()); }
   // Textausrichtung setzen
   inline void setTextAlign(const cdAlign& horiz, const cdAlign& vert)
      { setTextAlign(horiz.getOsVal(), vert.getOsVal()); }

   void setColor(long color);
   void setBackColor(long color);
   void setFillColor(long fillcolor);
   void setFillPattern(char *pattern);
   void setLineStyle(long linestyle);
   void setLineWidth(long linewidth);
   void setPattern(long pattern);
   void setForeMix(long mix);
   void setBackMix(long mix);

   void setTextAlign(long horiz, long vert);
   void setTextAngle(long dir_x, long dir_y);

   void selectFont(long font_id);
   void deleteFont(long font_id);

   // Setze RECT fuer kuenftige Operationen auf 'bottom_left', 'top_right'
   void setRect(const cdPoint& bottom_left, const cdPoint& top_right);
   // Setze XRECT fuer kuenftige Operationen auf 'bottom_right', 'top_left'
   void setXRect(const cdPoint& bottom_right, const cdPoint& top_left);

   // Bewege CURSOR auf 'p'
   void moveTo(const cdPoint& p);

   // Gerade von CURSOR bis 'line_end'
   void drawLine(const cdPoint& line_end);
   // Kreis um 'center' mit 'radius'
   void drawCircle(const cdPoint& center, long radius);
   // Ellipse innerhalb von RECT/XRECT
   void drawEllipse();
   // Rechteck wie durch RECT/XRECT definiert
   void drawRect();
   // Bogen im Uhrzeigersinn innerhalb RECT/XRECT von CURSOR bis 'arc_end'
   void drawArcCW(const cdPoint& arc_end);
   // Bogen gegen Uhrzeigersinn innerhalb RECT/XRECT von CURSOR bis 'arc_end'
   void drawArcCCW(const cdPoint& arc_end);
   // Text ab Cursor
   void drawText(const char *txt, int length);

   void beginArea(bool boundary);
   void endArea();

private:
   cdDeviceStore *cur_storage;
   cdDeviceStore::ELEM *newElem() const
      { return cur_storage->newElem(); }

   void init();

};


// ===========================================================================
// Definition cdMemoryDevice
// ---------------------------------------------------------------------------
//
// Ein Memory-Device kann nur basierend auf einem realen (retained) Device
// angelegt werden und ist immer zu diesem kompatibel. Es merkt sich auto-
// matisch alle Ausgaben und kann diese in ein Retained-Device zurueckspielen.
//
// Alle Koordinaten sind Memory-Device-relativ.
//
//  cBase
//   +--cdDevice
//       +--cdRetainedDevice
//           +--cdMemoryDevice
//
// ===========================================================================

class __ECL_DLLEXPORT__ cdMemoryDevice : public cdRetainedDevice {
   friend class cdDevice;

public:
   inline cdMemoryDevice(cdDevice *compatible_device) : cdRetainedDevice(*compatible_device) { init(); }
   ~cdMemoryDevice();

   void beginDrawing();
   void endDrawing();

private:
   cdDeviceStore *elems;

   void init();

   // Zeichen der gespeicherten Ausgaben auf 'device'
   void replayAt(cdDevice *device, const cdPoint& pos) const;

   // paintAt-Funktion sinnlos, daher deaktiviert
   void paintAt(cdDeviceStore *, const cdPoint&)
      { }

};


#endif

/*.EH.*/
