/*.SH.*/

/*
 *  Headerfile for module ew_frames
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  ew_frames.cpp on Saturday December 29 2001  17:03:04
 */

#ifndef __ew_frames__
#define __ew_frames__


// Headerfiles
// ===========================================================================

#include "win/ew_windows.hpp"

class cwView;


// ===========================================================================
// cwFrame
// ---------------------------------------------------------------------------
//
// Anlegen eines Frames mit einem assoziierten View:
//
//    cwFrame frame;
//    cwMyView1 view1;
//    frame.setView(&view);
//    frame.create(res_id, 0);
//
// Anlegen eines Frames mit mehreren assoziierten Views:
//
//    cwFrame frame;
//    cwMyViewA view1;
//    cwMyViewB view2, view3;
//    frame.setView(&view1);
//    frame.addView(&view2, cwFrame::vpLeft, 250 /*pix*/);
//    frame.addView(&view3, cwFrame::vpBottom);
//    frame.create(res_id, 0);
//
// cBase
//  +--cwWindow
//      +--cwFrame
//
// ===========================================================================

class __ECL_DLLEXPORT__ cwFrame : public cwWindow {
   ELO_DECLARE(cwFrame,cwWindow)
   friend class ccwFrame;

public:

   // Konstruktor
   inline cwFrame() : cwWindow(0) { init(); }
   // Destruktor
   virtual ~cwFrame();


   // window-Styles
   // =============

   // Styles
   enum STYLES { wsStart = cwWindow::wsUser,
      wsCaption         = wsStart << 0,   // Fenster hat Titelzeile
      wsSysMenu         = wsStart << 1,   // Fenster hat Systemmenue
      wsMinimize        = wsStart << 2,   // Fenster hat Minimize-Knopf
      wsMaximize        = wsStart << 3,   // Fenster hat Maximize-Knopf
      wsUser            = wsStart << 4,   // Benutzerdefinierte Styles
      //
      // Kombinationen:
      wsMinMax          = wsMinimize|wsMaximize,      // Minimize- und Maximize-Knopf
      wsFrameCaption    = wsCaption|wsSysMenu,        // Titelzeile und Systemmenue
      wsFrameTitle      = wsFrameCaption|wsMinMax,    // Komplette Titelzeile
      wsFrameWindow     = wsBorderSize|wsFrameTitle,  // Normales Frame-Window
      //
      // Alte Namen (Kompatibilitaet):
      fsDockNone        = wsDockNone,
      fsDockLeft        = wsDockLeft,
      fsDockRight       = wsDockRight,
      fsDockTop         = wsDockTop,
      fsDockBottom      = wsDockBottom,
      fsDockAny         = wsDockAny
   };


   // Allgemeines
   // ===========

   // Erzeugen eines Frame-Windows
   void create(cwWindow *parent, int style, cString text, const cdRect& rect = cdRect());
   // Erzeugen eines Top-Level-Frame-Windows
   void create(int style, cString text, const cdRect& rect = cdRect());

   // Erzeugen eines Frame-Windows aus einer Resource
   void create(cwWindow *parent, const cResource& res, int style);
   // Erzeugen eines Top-Level-Frame-Windows aus einer Resource
   void create(const cResource& res, int style);

   // Layout neuberechnen (z.B. nach Hinzufuegen/Entfernen von Docking-Fenstern)
   void recalcLayout(bool notify = true);

   // Erlaubt das Frame irgendwo Andockfenster?
   inline bool isDockable() const
      { return !!(dock_style & wsDockAny); }


   // Views
   // =====

   // Hinweis: Split-Views und Tabbed-Views nicht mischbar!

   enum POSITION {
      vpMain,        // Kennung fuer Haupt-View
      vpSame,        // Tabbing:   Neuer View hinter dem Hauptview
      vpLeft,        // Splitting: Neuer View links vom Hauptview
      vpRight,       // Splitting: Neuer View rechts vom Hauptview
      vpTop,         // Splitting: Neuer View ueber dem Hauptview
      vpBottom       // Splitting: Neuer View unter dem Hauptview
   };

   // Primaeren View setzen (muss VOR cwFrame::create aufgerufen werden!!)
   void setView(cwView *view);
   // Zusaetzliche Split-Views einfuegen (muss VOR cwFrame::create aufgerufen werden!!)
   void addView(cwView *view, POSITION pos, int size);

   // Primaeren Tab-View setzen (muss VOR cwFrame::create aufgerufen werden!!)
   void setTabView(cwView *view, cString name, bool is_tab3d = true);
   // Zusaetzliche Tab-Views einfuegen (muss VOR cwFrame::create aufgerufen werden!!)
   void addTabView(cwView *view, cString name);

   // Anzahl Views ermitteln (incl. primaerer View)
   int getViewCount() const;
   // Views ueber Index erfragen (incl. primaerer View)
   cwView *getView(int index) const;
   // Zeiger auf primaeren View erfragen (oder 0, falls nicht definiert)
   cwView *getMainView() const;

   // Zeiger auf aktiven View ermitteln
   cwView *getActiveView() const;
   // Index des aktiven Views ermitteln
   int getActiveViewIndex() const;
   // Aktiven View ueber cwView-Objekt setzen
   void setActiveView(cwView *view);

   // Titel des Views erfragen
   cString getViewTitle(const cwView *view) const;
   // Titel des Views setzen
   void setViewTitle(cwView *view, cString title);


protected:

   // Hinzugefuegte Events
   // ====================

   // Wird aufgerufen, um die Frame-Views zu erzeugen
   // rc: true -> Meldung bearbeitet; false -> Default ausfuehren
   virtual bool onCreateViews(void *add_info);
   // Wird aufgerufen, um die Andockseiten zu setzen
   virtual void onSetDockSides(int sides, int os_sides);
   // Wird aufgerufen, um den Wechsel des aktuellen Views anzukuendigen (true = zulassen)
   virtual bool onViewChanging(cwView *cur_view);
   // Wird aufgerufen, um den Wechsel des aktuellen Views bekanntzugeben
   virtual void onViewChanged(cwView *prev_view, cwView *new_view);


   // Ueberschriebene Events
   // ======================

   // Fenster wird erzeugt
   // rc: true -> Erzeugen OK; false -> Nicht erzeugen
   bool onCreate();
   // Fenstererzeugung wird vorbereitet
   // rc: true -> Erzeugen OK; false -> Nicht erzeugen
   bool onPreCreate(void *add_data);

   // Befehl ausfuehren (von Menu, Control oder Accelerator)
   // rc: true -> Meldung bearbeitet; false -> Default ausfuehren
   bool onCommand(const cwCmdEvt& cmd);
   // Update Benutzerschnittstelle
   // rc: true -> Meldung bearbeitet; false -> Default ausfuehren
   bool onCommandUI(cwCmdUI& cmd);

   // Wird aufgerufen, wenn ein Kindfenster den Focus erhaelt
   void onChildActivated(cwWindow *win);

   // Wird aufgerufen, um die durch 'mask' spezifizierten Window-Styles zu ermitteln
   int onGetStyles(int mask) const;
   // Wird aufgerufen, um die OS-spezifischen Styles aus den ECL-Styles zu ermitteln
   void onMakeStyles(int styles, int os_styles[]) const;
   // Wird aufgerufen, um Window-Styles zu setzen (add) und zu entfernen (remove)
   void onModifyStyles(int add, int remove, int os_add[], int os_remove[]);


protected:

   // Dock-Style-Flags des Fensters
   int dock_style;

   // Interner Konstruktor
   cwFrame(void *wnd);


private:

   struct FRAMEINFO;
   FRAMEINFO *info;

   // Initialisierung
   void init();

   // Split-Views erzeugen
   bool createSplitViews(int view_count, void *add_info);
   // Tabbed-Views erzeugen
   bool createTabbedViews(int view_count, void *add_info);

   // Intern: Wird von ccwFrame aufgerufen, um den Wechsel des aktuellen Views anzukuendigen
   bool onViewChanging();
   // Intern: Wird von ccwFrame aufgerufen, um den Wechsel des aktuellen Views bekanntzugeben
   void onViewChanged();

};


// ===========================================================================
// cwMultiDocFrame
// ---------------------------------------------------------------------------
//
// cBase
//  +--cwWindow
//      +--cwFrame
//          +--cwMultiDocFrame
//
// ===========================================================================

class __ECL_DLLEXPORT__ cwMultiDocFrame : public cwFrame {
   ELO_DECLARE(cwMultiDocFrame,cwFrame)
   friend class ccwFrame;

public:

   // Konstruktor
   inline cwMultiDocFrame() : cwFrame(0) { init(); }
   // Destruktor
   virtual ~cwMultiDocFrame();


   // Allgemeines
   // ===========

   // Erzeugen eines Multiple-Document-Frame-Windows
   void create(int style, cString text, const cdRect& rect = cdRect());
   // Erzeugen eines Multiple-Document-Frame-Windows aus einer Resource
   void create(const cResource& res, int style);


   // Kindfenster
   // ===========

   enum TILE {
      tileHorz,      // Horizontale Anordnung
      tileVert       // Vertikale Anordnung
   };

   // Icon-Darstellung anordnen
   void arrange();
   // Kindfenster ueberlappend anordnen
   void cascade();
   // Kindfenster nebeneinander anordnen
   void tile(TILE tile);


protected:

   // Ueberschriebene Events
   // ======================

   // Befehl ausfuehren (von Menu, Control oder Accelerator)
   // rc: true -> Meldung bearbeitet; false -> Default ausfuehren
   bool onCommand(const cwCmdEvt& cmd);
   // Wird aufgerufen, um die Andockseiten zu setzen
   void onSetDockSides(int sides, int os_sides);

protected:

   // Interner Konstruktor
   cwMultiDocFrame(void *wnd);


private:

   // Initialisierung
   void init();

};


// ===========================================================================
// cwMultiDocChild
// ---------------------------------------------------------------------------
//
// cBase
//  +--cwWindow
//      +--cwFrame
//          +--cwMultiDocChild
//
// ===========================================================================

class __ECL_DLLEXPORT__ cwMultiDocChild : public cwFrame {
   ELO_DECLARE(cwMultiDocChild,cwFrame)
   friend class ccwFrame;

public:

   // Konstruktor
   inline cwMultiDocChild() : cwFrame(0) { init(); }
   // Destruktor
   virtual ~cwMultiDocChild();


   // Allgemeines
   // ===========

   // Erzeugen eines Multiple-Document-Child-Windows
   void create(cwMultiDocFrame *parent, int style, cString text, const cdRect& rect = cdRect());
   // Erzeugen eines Multiple-Document-Child-Windows aus einer Resource
   void create(cwMultiDocFrame *parent, const cResource& res, int style);

   // Ist das zugehoerige Frame ein dockbares Frame-Fenster?
   inline bool isParentDockable() const
      { return parent != 0 ? parent->isDockable() : false; }


protected:

   // Ueberschriebene Events
   // ======================

   // Befehl ausfuehren (von Menu, Control oder Accelerator)
   // rc: true -> Meldung bearbeitet; false -> Default ausfuehren
   bool onCommand(const cwCmdEvt& cmd);


protected:

   // Interner Konstruktor
   cwMultiDocChild(void *wnd);


private:

   // Zugehoeriges Multiple Document Frame Window
   cwMultiDocFrame *parent;

   // Initialisierung
   void init();

};


// ===========================================================================
// cwDockable
// ---------------------------------------------------------------------------
//
// Basisklasse fuer Fenster, die an ein Frame-Window "andockbar" sind.
//
// cBase
//  +--cwWindow
//      +--cwDockable
//
// ===========================================================================

class __ECL_DLLEXPORT__ cwDockable : public cwWindow {
   ELO_DECLARE(cwDockable,cwWindow)

public:

   // window-Styles
   // =============

   // Styles
   enum STYLES { wsStart = cwWindow::wsUser,
      wsUser            = wsStart << 0,   // Benutzerdefinierte Styles
      //
      // Alte Namen (Kompatibilitaet):
      dksAlignNone      = wsDockNone,
      dksAlignLeft      = wsDockLeft,
      dksAlignRight     = wsDockRight,
      dksAlignTop       = wsDockTop,
      dksAlignBottom    = wsDockBottom,
      dksAlignMask      = wsDockAny,
      //
      dsNone            = wsDockNone,
      dsLeft            = wsDockLeft,
      dsRight           = wsDockRight,
      dsTop             = wsDockTop,
      dsBottom          = wsDockBottom,
      dsAny             = wsDockAny
   };


   // Seiten
   // ======

   // Andockseiten setzen
   void setDockSides(int sides);
   // Aktuelle Andockseiten ermitteln
   int getDockSides() const;


   // Zustand
   // =======

   // Hinweis: Der 'ratio'-Parameter von dockWindow() gibt an, wo und in
   // welchem Verhaeltnis zum Gesamtbereich der angegebenen Seite das Fenster
   // angedockt wird. Beispiele:
   //
   //  - (dpLeft,60) = Links unten, Hoehe = 60% der Gesamthoehe
   //  - (dpLeft,-30) = Links oben, Hoehe = 30% der Gesamthoehe
   //  - (dpTop,-70) = Oben links, Breite = 70% der Gesamtbreite

   enum DOCK_POSITION {          // Andockpositionen im Frame-Window:
      dpLeft,                    //  - Links andocken
      dpRight,                   //  - Rechts andocken
      dpTop,                     //  - Oben andocken
      dpBottom                   //  - Unten andocken
   };

   // Window an gespeicherter Position am Parent andocken
   void dockWindow();
   // Window an Seite 'pos' von Parent andocken
   void dockWindow(DOCK_POSITION pos, int ratio = 0);
   // Window in "Schwebezustand" an gespeicherte Position
   void floatWindow();
   // Window in "Schwebezustand" an Position 'pos'
   void floatWindow(const cdPoint& pos);

   // Ist das Fenster gerade angedockt?
   bool isDocked() const;
   // Ist das Fenster gerade schwebend?
   bool isFloating() const;


protected:

   // Zusaetzliche Events
   // ===================

   // Wird aufgerufen, um die Andockseiten zu setzen
   virtual void onSetDockSides(int sides, int os_sides) = 0;


   // Ueberschriebene Events
   // ======================

   // Wird aufgerufen, um die durch 'mask' spezifizierten Window-Styles zu ermitteln
   int onGetStyles(int mask) const;
   // Wird aufgerufen, um die OS-spezifischen Styles aus den ECL-Styles zu ermitteln
   void onMakeStyles(int styles, int os_styles[]) const;
   // Wird aufgerufen, um Window-Styles zu setzen (add) und zu entfernen (remove)
   void onModifyStyles(int add, int remove, int os_add[], int os_remove[]);


protected:

   // Parent-Window
   cwFrame *_parent;

   // Interner Konstruktor
   cwDockable(void *wnd);
   // Destruktor
   virtual ~cwDockable();


private:

   // Initialisierung
   void init();

};


// ===========================================================================
// cwMiniFrame
// ---------------------------------------------------------------------------
//
// Diese Fensterklasse nimmt ein beliebiges Client-Fenster auf (z.B. ein
// Control) und "verpackt" es in ein schwebendes (oder alternativ andockbares)
// Mini-Frame-Fenster.
//
// cBase
//  +--cwWindow
//      +--cwDockable
//          +--cwMiniFrame
//
// ===========================================================================

class __ECL_DLLEXPORT__ cwMiniFrame : public cwDockable {
   ELO_DECLARE(cwMiniFrame,cwDockable)
   friend class ccwMiniFrame;

public:

   // Konstruktor
   inline cwMiniFrame() : cwDockable(0) { init(); }
   // Destruktor
   virtual ~cwMiniFrame();


   // Allgemeines
   // ===========

   // Erzeugen eines Floating-Windows (Variante 1)
   void create(cwFrame *parent, int style, cString text, const cdRect& rect = cdRect());
   // Erzeugen eines Floating-Windows aus einer Resource (Variante 2)
   void create(cwFrame *parent, const cResource& res, int style);

   // Client-Fenster setzen (nur bei Variante 1 erlaubt!)
   void setClient(cwWindow *win);
   // Client-Fenster erfragen (bei Variante 2 immer 0)
   inline cwWindow *getClient() const
      { return client; }


protected:

   // Zusaetzliche Events
   // ===================

   // Wird aufgerufen, wenn sich die Groesse des Mini-Frames aendert
   virtual void onSizeOrStateChange(bool floating);


   // Ueberschriebene Events
   // ======================

   // Fenster wird erzeugt
   // rc: true -> Erzeugen OK; false -> Nicht erzeugen
   bool onCreate();
   // Fenstererzeugung wird vorbereitet
   // rc: true -> Erzeugen OK; false -> Nicht erzeugen
   bool onPreCreate(void *add_data);
   // Befehl ausfuehren (von Menu, Control oder Accelerator)
   bool onCommand(const cwCmdEvt& cmd);
   // Update Benutzerschnittstelle
   bool onCommandUI(cwCmdUI& cmd);
   // Wird aufgerufen, um den Zeiger auf die ELO-Aktionsbeschreibung zu ermitteln
   cEloActionDescription *onGetWindowActionDescription(const cEloSelection *selection) const;

   // Wird aufgerufen, um die Andockseiten zu setzen
   void onSetDockSides(int sides, int os_sides);


protected:

   // Interner Konstruktor
   cwMiniFrame(void *wnd);


private:

   // Client-Fenster (fuer Variante mit einem Client);
   // fuer die Variante mit einem Dialog ist 'client' = 0
   cwWindow *client;

   // Initialisierung
   void init();

};


#endif

/*.EH.*/
