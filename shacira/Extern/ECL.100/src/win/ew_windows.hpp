/*.SH.*/

/*
 *  Headerfile for module ew_windows
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  ew_windows.cpp on Wednesday April 10 2002  23:05:07
 */

#ifndef __ew_windows__
#define __ew_windows__


// Headerfiles
// ===========================================================================

#include "base/eb_elo.hpp"
#include "base/eb_event.hpp"
#include "base/eb_err.hpp"
#include "win/ew_commands.hpp"


// Forward-Deklarationen
// ===========================================================================

class cwMenu;


// ===========================================================================
// Definition cwWindow
// ---------------------------------------------------------------------------
//
// cEloBase
//  +--cEloElement
//      +--cwWindow
//
// ===========================================================================

class __ECL_DLLEXPORT__ cwWindow : public cEloElement, public cEventSource {
   ELO_DECLARE(cwWindow,cEloElement)
   friend class ccwWindow;

public:

   enum { NOVAL = -2147483647 };


   // Allgemeines
   // ===========

   // Destruktor
   virtual ~cwWindow();

   // Mit bestehendem Fenster verknuepfen
   void attach(cwWindow *parent, int id);
   // Zerstoeren des Fensters
   void destroy();

   // Fenster-ID ermitteln
   int getId() const;
   // Ist das Fenster angelegt?
   bool isCreated() const;

   // Parent des Fensters setzen
   void setParent(cwWindow *new_parent);
   // Parent des Fensters ermitteln (oder 0)
   cwWindow *getParent() const;

   // Zugeordnetes Menu setzen
   void setMenu(cwMenu *new_menu);
   // Zugeordnetes Menu ermitteln (oder 0)
   cwMenu *getMenu() const;

   // Aktives Kindfenster ermitteln (oder 0)
   cwWindow *getActiveChild() const;


   // window-Flags
   // ============

   // Flags
   enum FLAGS {
      wflNone           = 0x00000000,   // Kein Flag
      wflAutoDelete     = 0x00000001,   // Objekt automatisch 'delete'en?
      wflInNotebook     = 0x00000002,   // In Notizbuch eingefuegt?
      wflWasRefreshed   = 0x00000004,   // Refresh erfolgreich durchgefuehrt?
      wflWasAttached    = 0x00000008,   // cwWindow per Attach erzeugt?
      wflIsAView        = 0x00000010,   // Ist aktuelles Fenster ein cwView?
      wflHasFocus       = 0x00000020,   // Hat das Fenster momentan den Eingabefocus?
      wflUser           = 0x00000040,   // Offset fuer benutzerdef. Flags
      //
      // Alte Bezeichner, nicht mehr verwenden!
      wflIsSource       = 0x00000000,   // Source-Emphasis aktiviert?
      wflIsTarget       = 0x00000000,   // Target-Emphasis aktiviert?
      wflIsFrameCtl     = 0x00000000,   // Als Frame-Control eingefuegt?
      wflInClose        = 0x00000000,   // Fenster schliessen aktiv?
      wflForceRefresh   = 0x00000000,   // Refresh unbedingt notwendig?
      wflWasStored      = 0x00000000    // Store erfolgreich durchgefuehrt?
   };

   // Alle aktuellen Window-Flags ermitteln
   inline int getFlags() const
      { return flags; }
   // Bestimmte aktuelle Window-Flags ermitteln
   inline int getFlags(int mask) const
      { return flags & mask; }
   // Bestimmte Window-Flags setzen
   inline void setFlags(int mask, bool set = true)
      { onSetFlags(mask, set); }


   // window-Styles
   // =============

   // Styles
   enum STYLES {
      wsNone            = 0x00000000,  // Kein Style
      wsDisabled        = 0x00000001,  // Fenster gesperrt (keine Eingaben moeglich)
      wsVisible         = 0x00000002,  // Fenster sichtbar
      wsChild           = 0x00000004,  // Verwendung als Kind eines anderen Fensters
      wsPopup           = 0x00000008,  // Verwendung als eigenstaendiges Fensters
      wsScrollHorz      = 0x00000010,  // Fenster hat horizontalen Scrollbar
      wsScrollVert      = 0x00000020,  // Fenster hat vertikalen Scrollbar
      wsBorder          = 0x00000040,  // Fenster hat duennen Rahmen
      wsBorderThick     = 0x00000080,  // Fenster hat dicken Rahmen
      wsBorderSize      = 0x00000100,  // Fenster hat Rahmen zum Aendern der Groesse
      wsTabStop         = 0x00000200,  // Fenster hat vertikalen Scrollbar
      wsReserved1       = 0x00000400,  // Reserviert fuer Erweiterungen
      wsReserved2       = 0x00000800,  // Reserviert fuer Erweiterungen
      wsDockLeft        = 0x00001000,  // Docken links erlaubt
      wsDockRight       = 0x00002000,  // Docken rechts erlaubt
      wsDockTop         = 0x00004000,  // Docken oben erlaubt
      wsDockBottom      = 0x00008000,  // Docken unten erlaubt
      wsUser            = 0x00010000,  // Offset fuer benutzerdef. Styles
      //
      // Kombinationen:
      wsDockNone        = 0,                          // Keine Andockfenster erlaubt
      wsDockHorz        = wsDockLeft|wsDockRight,     // Docken horizontal erlaubt
      wsDockVert        = wsDockTop|wsDockBottom,     // Docken Vertikal erlaubt
      wsDockAny         = wsDockHorz|wsDockVert       // Docken ueberall erlaubt
   };

   // Aktuelle Window-Styles ermitteln
   int getStyles(int mask = ~0) const;
   // Bestimmte Window-Styles setzen (add) und ruecksetzen (remove)
   void modifyStyles(int add, int remove);


   // Events
   // ======

   // Event-IDs dieser Klasse
   enum EVENTS { evtFirst = cEventSource::evtUser,
      evtFocusGained,         // (EVFUNC)    Tastaturfokus erhalten
      evtFocusLost,           // (EVFUNC)    Tastaturfokus verloren
      evtWindowCreated,       // (EVFUNC)    Fenster erzeugt
      evtWindowDestroyed,     // (EVFUNC)    Fenster zerstoert
      evtWindowRefreshed,     // (EVFUNC)    Fensterinhalt aktualisiert
      evtWindowStored,        // (EVFUNC)    Fensterinhalt gespeichert
      evtWindowDiscarded,     // (EVFUNC)    Fensterinhalt verworfen
      evtContextMenu,         // (EVFUNC_II) Kontextmenu anzeigen
      evtUser                 // Ab hier benutzerdefinierte Events
   };

   // Benutzerdefinierte Kennung
   // ==========================

   // Setzt die benutzerdefinierte Fenster-Kennung
   void setUserId(int id);
   // Liest die benutzerdefinierte Fenster-Kennung
   int getUserId() const;


   // Window-Text
   // ===========

   // Fenstertext setzen (flacker-optimiert)
   void setText(const cString& text);
   // Fenstertext ermitteln
   cString getText() const;


   // Position/Groesse
   // ================

   // Fenster mittig zu anderem Fenster oder bildschirmmittig plazieren
   void center(cwWindow *other = NULL); // war: Center()

   // Groesse des Fensters ermitteln
   cdSize getSize() const;
   // Groesse des Arbeitsbereichs (Client) ermitteln
   cdSize getClientSize() const;

   // Position des Fensters relativ zum Screen ermitteln
   cdRect getRect() const;
   // Position des Arbeitsbereichs (Client) relativ zum Rahmen ermitteln
   cdRect getClientRect() const;

   // Groesse des Fensters aendern (Startpunkt bleibt erhalten)
   void setSize(const cdSize& size);
   // Position und Groesse des Fensters aendern
   void setRect(const cdRect& rect);


   // "Angeklebte" Fenster
   // ====================
   // Anmerkung: Momentan max. ein Fenster erlaubt und nur an stpTop

   enum STICK_POS {
      stpTop,           // Fremdfenster oben anhaengen
      stpBottom,        // - reserviert -
      stpLeft,          // - reserviert -
      stpRight          // - reserviert -
   };

   // Fenster 'win' an Position 'pos' des aktuellen Fensters "ankleben"
   void setSticky(cwWindow *win, STICK_POS pos = stpTop);
   // Zuletzt an Position 'pos' angeklebtes Fenster ermitteln
   cwWindow *getSticky(STICK_POS pos = stpTop) const;


   // Koordinaten
   // ===========

   // Punkt von Fenster- in Schirmkoordinaten umrechnen
   void convWin2Screen(cdPoint& point);
   // Rechteck von Fenster- in Schirmkoordinaten umrechnen
   void convWin2Screen(cdRect& rect);

   // Punkt von Schirm- in Fensterkoordinaten umrechnen
   void convScreen2Win(cdPoint& point);
   // Rechteck von Schirm- in Fensterkoordinaten umrechnen
   void convScreen2Win(cdRect& rect);


   // Presentation Parameter
   // ======================

   enum PPARAMS {
      ppFont,
      ppFgndColor,
      ppBkgndColor
   };

   // Presentation-Parameter (Color) setzen
   void setPresParam(PPARAMS pp, cdColor value);
   // Presentation-Parameter (String) setzen
   void setPresParam(PPARAMS pp, cString value);
   // Presentation-Paramter vom Fenster loeschen
   void removePresParam(PPARAMS pp);

   // Prueft, ob ein Presentation-Paramter gesetzt ist
   bool isPresParamSet(PPARAMS pp) const;
   // Presentation-Parameter (Color) erfragen; liefert false, falls nicht gesetzt
   bool getPresParam(PPARAMS pp, cdColor& value) const;
   // Presentation-Parameter (String) erfragen; liefert false, falls nicht gesetzt
   bool getPresParam(PPARAMS pp, cString& value) const;


   // Erlaubnisfunktionen
   // ===================
   // Liefert ein Fenster bei onAllowClose() false zurueck, wird der laufende
   // Vorgang des Schliessens unterbrochen. Durch Aufrufen der onResumeClose-
   // Methode des durch den notify-Zeiger gegebenen Fensters kann der unter-
   // brochene Vorgang fortgesetzt werden

   // Blaettern zu Sibling erlauben?
   bool allowTurn();
   // Abbruch mit Speichern erlauben?
   bool allowStore();
   // Abbruch ohne Speichern erlauben?
   bool allowDiscard();
   // Schliessen des Fensters erlauben?
   bool allowClose(cwWindow *notify);


   // Inhalt aktualisieren/speichern
   // ==============================
   // Die refresh bzw. store-Methoden der Basisklassen rufen den entspr.
   // Event onRefresh bzw. onStore aller Kindfenster auf. Falls alle
   // Kindfenster true liefern, wird das wasRefreshed- bzw. wasStored-
   // Flag gesetzt.

   // Fensterinhalt aktualisieren (false -> Abbruch)
   bool refresh();
   // Fensterinhalt (zurueck)speichern (false -> Abbruch)
   bool store();
   // Fensterinhalt verwerfen (false -> Abbruch)
   bool discard();


   // Timer
   // =====

   // Timer 'id' starten (0 < id < 10000)
   bool startTimer(int id, int ms);
   // Timer 'id' anhalten (0 < id < 10000)
   void stopTimer(int id);


   // Scrolling
   // =========

   enum BAR {
      barHorz  = cwCmdScroll::barHorz, // Kennzeichnet den horizontalen Standard-Scrollbalken
      barVert  = cwCmdScroll::barHorz  // Kennzeichnet den vertikalen Standard-Scrollbalken
   };

   // Aktuelle Position, Scrollbereich und Seitengroesse von Scrollbalken 'bar' erfragen
   bool getScrollBarInfo(BAR bar, int *pos = 0, int *min = 0, int *max = 0, int *page = 0, int *track = 0) const;
   // Scrollbereich, Seitengroesse und aktuelle Position von Scrollbalken 'bar' einstellen
   void setScrollBarInfo(BAR bar, int pos = NOVAL, int min = NOVAL, int max = NOVAL, int page = NOVAL, bool redraw = true);

   // Aktuelle statische Position des Scrollbalken 'bar' ermitteln
   inline int getScrollPos(BAR bar) const
      { int pos = 0; getScrollBarInfo(bar, &pos); return pos; }
   // Aktuelle Position des Scrollbalkens 'bar' waehrend der Benutzerinteraktion ermitteln
   inline int getScrollTrackPos(BAR bar) const
      { int track_pos = 0; getScrollBarInfo(bar, 0, 0, 0, 0, &track_pos); return track_pos; }
   // Aktuellen Minimalwert des Scrollbereichs von Scrollbalken 'bar' ermitteln
   inline int getScrollRangeMin(BAR bar) const
      { int min = 0; getScrollBarInfo(bar, 0, &min); return min; }
   // Aktuellen Maximalwert des Scrollbereichs von Scrollbalken 'bar' ermitteln
   inline int getScrollRangeMax(BAR bar) const
      { int max = 0; getScrollBarInfo(bar, 0, 0, &max); return max; }
   // Aktuellen Seitengroesse bezueglich des Scrollbereichs von Scrollbalken 'bar' ermitteln
   inline int getScrollPageSize(BAR bar) const
      { int page = 0; getScrollBarInfo(bar, 0, 0, 0, &page); return page; }

   // Statische Position von Scrollbalken 'bar' einstellen
   inline void setScrollPos(BAR bar, int pos, bool redraw = true)
      { setScrollBarInfo(bar, pos, NOVAL, NOVAL, NOVAL, redraw); }
   // Scrollbereich von Scrollbalken 'bar' einstellen
   inline void setScrollRange(BAR bar, int min, int max, bool redraw = true)
      { setScrollBarInfo(bar, NOVAL, min, max, NOVAL, redraw); }
   // Seitengroesse bezeuglich des Scrollbereichs von Scrollbalken 'bar' einstellen
   inline void setScrollPageSize(BAR bar, int page, bool redraw = true)
      { setScrollBarInfo(bar, NOVAL, NOVAL, NOVAL, page, redraw); }

   // Scrollbalken 'bar' anzeigen
   inline void showScrollBar(BAR bar)
      { setScrollBarVisible(bar, true); }
   // Scrollbalken 'bar' verbergen
   inline void hideScrollBar(BAR bar)
      { setScrollBarVisible(bar, false); }

   // Sichtbarkeit der Scrollbalken steuern (true = anzeigen; false = verbergen)
   void setScrollBarVisible(int bar_mask, bool on = true);
   // Freigabestatus der Scrollbalken steuern (true = freigeben; false = sperren)
   void setScrollBarEnable(int bar_mask, bool enable = true);

   // Client-Bereich des Fenster um 'dx' und 'dy' (in Geraetekoordinaten) scrollen
   // Scrollrichtungen: fuer 'dx': Links < 0 < Rechts, fuer 'dy': Oben < 0 < Unten
   // 'rect': Zeiger auf optionalen Scrollbereich (in Geraetekoordinaten)
   // 'clip_rect': Zeiger auf optionalen Clip-Bereich (in Geraetekoordinaten)
   void scrollWindow(int dx, int dy, const cdRect *rect = 0, const cdRect *clip_rect = 0);
   // Client-Bereich um 'dx' und 'dy' scrollen (wie oben, jedoch mit cdRect-Referenzen)
   void scrollWindow(int dx, int dy, const cdRect& rect, const cdRect& clip_rect);


   // Elemente und Operationen (ELO)
   // ==============================

   // Ermoeglicht das Fenster eine ELO-Element-Selektion?
   bool hasWindowElemSelection() const;
   // Aktuelle ELO-Element-Selektion des Fensters in 'selection' ermitteln
   // Liefert false, falls keine Selektion ermittelt werden kann
   bool updateWindowElemSelection(cEloSelection& selection) const;
   // Aktuelle ELO-Element-Selektion des Fensters in eigenes Selektionsobjekt ermitteln
   // Liefert false, falls keine Selektion ermittelt werden kann
   bool updateWindowElemSelection();
   // Zeiger auf ein aktuelles ELO-Selektionsobjekt liefern
   // Liefert 0, wenn kein eigenes Selektionsobjekt vorhanden ist
   cEloSelection *getWindowElemSelection();
   // Zeiger auf die ELO-Aktionsbeschreibung liefern
   cEloActionDescription *getWindowActionDescription(const cEloSelection *selection) const;


   // Systeminformation
   // =================

   // Groesse des Bildschirms (Aufloesung) erfragen
   static cdRect getScreenRect();
   // Groesse des Desktops (nutzbarer Bereich des Bildschirms) erfragen
   static cdRect getDesktopRect();


   // Sonstiges
   // =========
   // Die folgenden Funktionen wirken auf das aktuelle Fenster oder
   // wahlweise auf ein (direktes) Kindfenster, gegeben ueber 'child_id'

   // Fenster anzeigen
   void show(int child_id = -1);
   // Fenster verbergen
   void hide(int child_id = -1);
   // Fenster invalidieren (Neuzeichnen erzwingen)
   void invalidate(int child_id = -1, bool erase_bkgnd = true);
   // Rechteckigen Bereich (in Client-Koordinaten) invalidieren
   void invalidate(const cdRect& rect, bool erase_bkgnd = true);
   // Update ausloesen (wenn noetig)
   void update(int child_id = -1);
   // Update erzwingen (invalidate + update)
   void forceUpdate(int child_id = -1, bool erase_bkgnd = true);
   // Update auf recteckigem Bereich (in Client-Koordinaten) erzwingen
   void forceUpdate(const cdRect& rect, bool erase_bkgnd = true);
   // Fenster aktivieren
   void activate(int child_id = -1);
   // Tastaturfokus setzen und evtl. Fenster aktivieren
   void setFocus(int child_id = -1);

   // Fenstersichtbarkeit steuern (true = anzeigen; false = verbergen)
   void setVisible(bool on = true, int child_id = -1);
   // Freigabestatus steuern (true = freigeben; false = sperren)
   void setEnable(bool enable = true, int child_id = -1);
   // Redraw-Status steuern (true = zeichnen; false = nicht zeichnen)
   void setRedraw(bool redraw = true, int child_id = -1);

   // Enable-Flag erfragen
   bool isEnabled(int child_id = -1) const;
   // ??? In OS/2-Doku nachlesen!
   bool isShowing(int child_id = -1) const;
   // ??? In OS/2-Doku nachlesen!
   bool isVisible(int child_id = -1) const;

   // Kommando synchron senden
   int sendCommand(const cwCmd& cmd);
   // Kommando asynchron senden
   bool postCommand(const cwCmd& cmd);

   // Aktueller Zustand "Einfuege-Modus" (Insert-Taste) erfragen
   static bool getInsertMode();
   // Zustand fuer "Einfuege-Modus" (Insert-Taste) setzen
   static bool setInsertMode(bool value);


   // Message-Boxen
   // =============

   // Art der Message-Box
   enum MB_STYLE {
      mbsQuery,      // Fehler (Yes, No, Cancel)
      mbsInfo,       // Information (Ok)
      mbsWarning,    // Warnung (Ok)
      mbsError,      // Fehler (Ok)
      mbsErrRetry,   // Fehler (Retry, Ignore, Cancel)
      mbsFatal       // Fehler (Ok)
   };

   // Ergebnis der Message-Box-Abfrage
   enum MB_RES {
      mbrOk,         // Ok (Meldung akzeptieren)
      mbrCancel,     // Cancel (Vorgang abbrechen)
      mbrRetry,      // Retry (Vorgang wiederholen)
      mbrIgnore,     // Ignore (Fehler ignorieren, Vorgang fortsetzen)
      mbrYes,        // Yes (Frage positiv beantworten)
      mbrNo          // No (Frage negativ beantworten)
   };

   // Allgemeine Messagebox (statische Variante)
   static MB_RES showMsg(const cwWindow *owner, const cString& title, const cString& text, MB_STYLE style);
   // Information anzeigen (statische Variante)
   static MB_RES showInfo(const cwWindow *owner, const cString& text);
   // Warnung anzeigen (statische Variante)
   static MB_RES showWarning(const cwWindow *owner, const cString& text);
   // Fehlermeldung des cErrBase-Objektes anzeigen (statische Variante)
   static MB_RES showError(const cwWindow *owner, const cErrBase& err, const cString& add_info = 0);
   // Fehler anzeigen (statische Variante)
   static MB_RES showError(const cwWindow *owner, const cString& text);
   // Fatalen Fehler anzeigen (statische Variante)
   static MB_RES showFatal(const cwWindow *owner, const cString& text);
   // Rueckfrage anzeigen (statische Variante)
   static MB_RES showQuery(const cwWindow *owner, const cString& text);

   // Allgemeine Messagebox (fenstergebundene Variante)
   inline MB_RES showMsg(const cString& title, const cString& text, MB_STYLE style) const
      { return showMsg(this, title, text, style); }
   // Information anzeigen (fenstergebundene Variante)
   inline MB_RES showInfo(const cString& text) const
      { return showInfo(this, text); }
   // Warnung anzeigen (fenstergebundene Variante)
   inline MB_RES showWarning(const cString& text) const
      { return showWarning(this, text); }
   // Fehlermeldung des cErrBase-Objektes anzeigen (statische Variante)
   inline MB_RES showError(const cErrBase& err, const cString& add_info = 0)
      { return showError(this, err, add_info); }
   // Fehler anzeigen (fenstergebundene Variante)
   inline MB_RES showError(const cString& text) const
      { return showError(this, text); }
   // Fatalen Fehler anzeigen (fenstergebundene Variante)
   inline MB_RES showFatal(const cString& text) const
      { return showFatal(this, text); }
   // Rueckfrage anzeigen (fenstergebundene Variante)
   inline MB_RES showQuery(const cString& text) const
      { return showQuery(this, text); }


protected:

   // Zusaetzliche Events
   // ===================

   // Wird aufgerufen, um bestimmte Window-Flags zu setzen
   virtual void onSetFlags(int mask, bool set);

   // Wird aufgerufen, um die durch 'mask' spezifizierten Window-Styles zu ermitteln
   virtual int onGetStyles(int mask) const;
   // Wird aufgerufen, um die OS-spezifischen Styles aus den ECL-Styles zu ermitteln
   virtual void onMakeStyles(int styles, int os_styles[]) const;
   // Wird aufgerufen, um Window-Styles zu setzen (add) und zu entfernen (remove)
   virtual void onModifyStyles(int add, int remove, int os_add[], int os_remove[]);

   // Fenster wird erzeugt
   // rc: true -> Erzeugen OK; false -> Nicht erzeugen
   virtual bool onCreate();
   // Fenstererzeugung wird vorbereitet
   // rc: true -> Erzeugen OK; false -> Nicht erzeugen
   virtual bool onPreCreate(void *add_data);
   // Attach mit Wrapper-Objekt durchfuehren
   virtual void onAttach(int id, void *wnd);
   // Fenster wird zerstoert
   virtual void onDestroy();
   // Groesse geaendert
   virtual void onSize(int cx, int cy);
   // Taste gedrueckt
   virtual void onChar(cwCmdChar& cmd);
   // Maustaste gedrueckt
   // rc: true -> Meldung bearbeitet; false -> Default ausfuehren
   virtual bool onMouseClick(const cwCmdMouse& cmd);
   // Mausbewegung
   // rc: true -> Meldung bearbeitet; false -> Default ausfuehren
   virtual bool onMouseMove(const cwCmdMouse& cmd);
   // Befehl ausfuehren (von Menu, Control oder Accelerator)
   // rc: true -> Meldung bearbeitet; false -> Default ausfuehren
   virtual bool onCommand(const cwCmdEvt& cmd); // war:
   // Update Benutzerschnittstelle
   // rc: true -> Meldung bearbeitet; false -> Default ausfuehren
   virtual bool onCommandUI(cwCmdUI& cmd);
   // Kontextmenu anzeigen
   // rc: true -> Meldung bearbeitet; false -> Default ausfuehren
   virtual bool onContextMenu(const cwCmdPosition& cmd);
   // Wird aufgerufen, wenn eine Aktion an einem Scrollbar ausgeloest wurde
   virtual void onScroll(const cwCmdScroll& cmd);

   // Entscheiden, ob das cwCmdChar-Kommando weiterverteilt werden soll
   virtual bool onDispatchChar(const cwCmdChar& cmd);
   // Entscheiden, ob das cwCmdMouse-Kommando weiterverteilt werden soll
   virtual bool onDispatchMouseClick(const cwCmdMouse& cmd);

   // Wird aufgerufen, wenn Fenster den Focus erhaelt
   virtual void onGainFocus();
   // Wird aufgerufen, wenn Fenster den Focus verliert
   virtual void onLoseFocus();

   // Wird aufgerufen, wenn ein Kindfenster den Focus erhaelt
   virtual void onChildActivated(cwWindow *win);

   // Inhalt refreshen (false -> Abbruch)
   virtual bool onRefresh(); // war: RefreshEvt()
   // Inhalt speichern (false -> Abbruch)
   virtual bool onStore(); // war: StoreEvt()
   // Inhalt verwerfen (false -> Abbruch)
   virtual bool onDiscard();
   // Beenden eines unterbrochenen "Schliessen"-Vorgangs
   virtual void onResumeClose(); // war: ResumeClose

   // Blaettern zu Sibling erlauben?
   virtual bool onAllowTurn(); // war: AllowTurnEvt()
   // Abbruch mit Speichern erlauben?
   virtual bool onAllowStore(); // war: AllowStoreEvt()
   // Abbruch ohne Speichern erlauben?
   virtual bool onAllowDiscard(); // war: AllowDiscardEvt()
   // Schliessen des Fensters erlauben?
   virtual bool onAllowClose(cwWindow *notify); // war: AllowCloseEvt()

   // Wird aufgerufen, wenn Timer 'id' ablaeuft (true -> Timer anhalten)
   virtual bool onTimer(int id);

   // Wird aufgerufen, wenn eine Drag-Operation das Fenster erreicht
   virtual bool onDragEnter(cwCmdDrag& cmd);
   // Wird aufgerufen, wenn eine Drag-Operation ueber dem Fenster ablaeuft
   virtual bool onDragOver(cwCmdDrag& cmd);
   // Wird aufgerufen, wenn eine Drag-Scroll-Operation ueber dem Fenster ablaeuft
   virtual bool onDragScroll(cwCmdDrag& cmd);
   // Wird aufgerufen, wenn eine Drag-Operation das Fenster verlaesst
   virtual bool onDragLeave();
   // Wird aufgerufen, wenn ein Drop ueber dem Fenster veranlasst wurde
   virtual bool onDrop(cwCmdDrop& cmd);

   // Wird aufgerufen, wenn sich der Presentation-Parameter 'pp' geaendert hat
   virtual void onPresParamChanged(PPARAMS pp);
   // Wird aufgerufen, wenn der Presentation-Parameter 'pp' entfernt wurde
   virtual void onPresParamRemoved(PPARAMS pp);

   // Wird aufgerufen, um zu erfragen, ob eine Element-Selektion moeglich ist
   virtual bool onHasWindowElemSelection() const;
   // Wird aufgerufen, um die aktuelle Element-Selektion zu ermitteln
   virtual bool onUpdateWindowElemSelection(cEloSelection& selection) const;
   // Wird aufgerufen, um den Zeiger auf ein aktuelles Selektionsobjekt zu ermitteln
   virtual cEloSelection *onGetWindowElemSelection();
   // Wird aufgerufen, um den Zeiger auf die ELO-Aktionsbeschreibung zu ermitteln
   virtual cEloActionDescription *onGetWindowActionDescription(const cEloSelection *selection) const;


   // Verzoegerte Ausfuehrung
   // =======================

   enum  { ediStart = 0,
      ediUser,          // ab hier Erweiterungen
   };

   // Operation verzoegert ausfuehren (0 <= id < 10000)
   void execDelayed(int id, void *data = 0, int ms_delay = -1);
   // Verzoegertes Ausfuehren einer Operation
   virtual void onExecDelayed(int id, void *data);


protected:
   void *_wnd;       // Zeiger auf Wrapper-Objekt


   // ECL/win Internas
   // ================
   // Die 'create'- bzw. 'attach'-Methoden aller abgeleiteten Klassen
   // muessen diese Basisvarianten in cwWindow aufrufen!

   // Interner Konstruktor
   cwWindow(void *wnd);
   // Erzeugen des Fensters (Intern)
   void create(cwWindow *parent);

   // Trennen vom Wrapper
   void __disconnect();
   // Eigenen Zeiger auf Wrapper-Objekt ermitteln
   void *__getWnd();
   const void *__getWnd() const;
   // Zeiger auf Wrapper-Objekt ermitteln
   static void *__getWnd(cwWindow *window);
   static const void *__getWnd(const cwWindow *window);

   // Verzoegertes Attachieren...
   void __attachDelayed();
   // Presentation Parameter erfragen
   void *__getPresParam();
   // Aktives Kindfenster setzen
   void __setActive(cwWindow *wnd);


private:

   // Aktuelle Window-Flags
   int flags;

   // Zusatzinformationen
   struct ADD_INFO;
   ADD_INFO *info;


public:

   // Alter Bezeichner fuer getRect, nicht mehr benutzen!
   inline cdRect getPos() const { return getRect(); }
   // Alter Bezeichner fuer getClientRect, nicht mehr benutzen!
   inline cdRect getClientPos() const { return getClientRect(); }
   // Alter Bezeichner fuer setRect, nicht mehr benutzen!
   inline void setPos(const cdRect& rect) { setRect(rect); }

};


#endif

/*.EH.*/
