/*.SH.*/

/*
 *  Headerfile for module ew_controls
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  ew_controls.cpp on Wednesday April 10 2002  23:08:21
 */

#ifndef __ew_controls__
#define __ew_controls__


// Headerfiles
// ===========================================================================

#include "store/es_store.hpp"
#include "store/es_query.hpp"
#include "win/ew_windows.hpp"


// ===========================================================================
// Definition cwControl
// ---------------------------------------------------------------------------
//
// Ein cwControl kann nicht direkt erzeugt werden, dies ist nur ueber eine
// der abgeleiteten Klassen wie cwButton oder cwEntry moeglich.
//
// cBase
//  +--cwWindow
//      +--cwControl
//
// ===========================================================================

class __ECL_DLLEXPORT__ cwControl : public cwWindow {
   ELO_DECLARE(cwControl,cwWindow)

public:

   // Allgemeines
   // ===========

   // Destruktor
   virtual ~cwControl();

   // Mit bestehendem Fenster verknuepfen
   void attach(cwWindow *parent, int id, csStorage *store = 0, csQuery *query = 0);


   // window-Flags
   // ============

   // Flags
   enum FLAGS { wflStart = cwWindow::wflUser,
      wflHasChanged     = wflStart << 0,  // Feldinhalt hat sich geaendert
      wflIsReadOnly     = wflStart << 1,  // Feldinhalt ist schreibgeschuetzt
      wflInsertMode     = wflStart << 2,  // Merker-Flag fuer Insert-Mode
      wflDelStorage     = wflStart << 3,  // Storage-Objekt loeschen?
      wflDelQuery       = wflStart << 4,  // Abfrageobjekt loeschen?
      wflInQuery        = wflStart << 5,  // Abfrage momentan aktiv?
      wflQueryStarted   = wflStart << 6,  // Abfrage aktiv und gestartet?
      wflInhValShown    = wflStart << 7,  // Defaultwert angezeigt?
      wflInhValMark     = wflStart << 8,  // Defaultwert-Markierung aktiv?
      wflErrFormat      = wflStart << 9,  // Format-Fehler? (Kein Store moeglich)
      wflEatEnterKey    = wflStart << 10, // Taste ENTER verschlucken (jedoch: Event erzeugen)
      wflEatEscKey      = wflStart << 11, // Taste ESC verschlucken (jedoch: Event erzeugen)
      wflEatNavKeys     = wflStart << 12, // Navigationstasten verschlucken (jedoch: Event erzeugen)
      wflUser           = wflStart << 13  // Benutzerdefinierte Flags
   };


   // Events
   // ======

   // Event-IDs dieser Klasse
   enum EVENTS { evtFirst = cwWindow::evtUser,
      evtHelpRequested,       // (EVFUNC)   Kontexthilfe angefordert (F1)
      evtDetailRequested,     // (EVFUNC)   Detailauswahl angefordert (F2)
      evtStorageModified,     // (EVFUNC_P) Inhalt der Storage geaendert
      evtStorageSet,          // (EVFUNC_P) Neue Storage gesetzt
      evtStorageRemoved,      // (EVFUNC_P) Bisherige Storage entfernt
      evtEnterKeyPressed,     // (EVFUNC)   Enter-Taste gedrueckt
      evtEscKeyPressed,       // (EVFUNC)   Escape-Taste gedrueckt
      evtNavKeyPressed,       // (EVFUNC_I) Navigations-Taste gedrueckt
      evtUser                 // Ab hier benutzerdefinierte Events
   };


   // Fehlerverarbeitung
   // ==================

   enum DATAERR {
      derrNone,         // Kein Fehler
      derrNotNull,      // Feld darf nicht leer sein
      derrFormat,       // Fehlerhaftes Format
      derrRead,         // Lesefehler
      derrWrite         // Schreibfehler
   };


   // Gebundene Daten
   // ===============

   // Hat Control ein csStorage zugeordnet?
   inline bool hasStorage() const
      { return store != 0; }
   // Liefert das zugeordnete Datenobjekt
   inline csStorage *getStorage() const
      { return store; }

   // Gebundenes Datenobjekt wechseln
   void setStorage(csStorage *store);
   // Bindung an Datenobjekt entfernen
   void removeStorage();

   // Typ des gebundenen Datenobjektes erfragen
   inline csStorage::TYPE getStorageType() const
      { return store ? store->getType() : csStorage::tNone; }
   // Ist das gebundene Datenobjekt Read-Only (keine Aenderungen moeglich)?
   bool isStorageReadOnly() const;

   // Ist das NULL-Flag des gebundenen Datenobjektes gesetzt?
   inline bool isStorageNull() const
      { return store ? store->isNull() : false; }
   // NULL-Flag des gebundenen Datenobjektes setzen
   inline void setStorageNull()
      { if ( store ) store->setNull(); }

   // Ermittelt den int-Wert
   inline bool getStorageVal(int& buf) const
      { return store ? store->get(buf) : false; }
   // Ermittelt den double-Wert
   inline bool getStorageVal(double& buf) const
      { return store ? store->get(buf) : false; }
   // Ermittelt den cTime-Wert
   inline bool getStorageVal(cTime& buf) const
      { return store ? store->get(buf) : false; }
   // Ermittelt den cDate-Wert
   inline bool getStorageVal(cDate& buf) const
      { return store ? store->get(buf) : false; }
   // Ermittelt den char-Wert
   inline bool getStorageVal(char& buf) const
      { return store ? store->get(buf) : false; }
   // Ermittelt den cString-Wert
   inline bool getStorageVal(cString& buf) const
      { return store ? store->get(buf) : false; }
   // Wert in anderes csStorage-Objekt uebernehmen
   bool getStorageVal(csStorage *other) const;

   // int-Wert schreiben
   inline bool putStorageVal(int buf)
      { return store ? store->put(buf) : false; }
   // double-Wert schreiben
   inline bool putStorageVal(double buf)
      { return store ? store->put(buf) : false; }
   // cTime-Wert schreiben
   inline bool putStorageVal(cTime buf)
      { return store ? store->put(buf) : false; }
   // cDate-Wert schreiben
   inline bool putStorageVal(cDate buf)
      { return store ? store->put(buf) : false; }
   // char-Wert schreiben
   inline bool putStorageVal(char buf)
      { return store ? store->put(buf) : false; }
   // cString-Wert schreiben
   inline bool putStorageVal(const char *buf)
      { return store ? store->put(buf) : false; }
   // Wert aus anderem csStorage-Objekt uebernehmen
   bool putStorageVal(const csStorage *other);


   // Abfrage
   // =======

   // Hat das Control eine csQuery zugeordnet?
   inline bool hasQuery() const
      { return query != 0; }
   // Wird die Abfrage gerade bearbeitet?
   inline bool inQuery() const
      { return !!getFlags(wflInQuery); }
   // Liefert die zugeordnete Abfrage
   inline csQuery *getQuery() const
      { return query; }
   // Abfrage erneut durchfuehren
   inline bool requery()
      { return onRequery(); }

   // Abfrage wechseln
   void setQuery(csQuery *query);
   // Abfrage entfernen
   void removeQuery();


   // Ererbte Werte
   // =============
   // Der ererbte Wert eines Controls wird immer dann angezeigt, wenn das
   // Control einen entsprechenden 'undefinierten' Zustand hat. Dies ist
   // z.B. bei einem Eingabefeld der Fall, wenn das Feld leer ist, bei einer
   // CheckBox, wenn sie den Zustand 'Indeterminiert' hat. Die Erkennung
   // dieses Zustands sowie die Art und Weise der Visualisierung des er-
   // erbten Wertes bleibt dem jeweiligen Control ueberlassen.

   // Hat das Control einen ererbten Wert?
   bool hasInheritedValue() const;
   // Liefert den zugeordneten ererbten Wert
   cString getInheritedValue() const;
   // Ist die (optische) Markierung eingeschaltet?
   bool isMarkedAsInheritedValue() const;
   // Anzeige des ererbten Wertes aktualisieren
   void refreshInheritedValue(bool force_refresh = false);

   // Setzt den zugeordneten ererbten cString-Wert
   void setInheritedValue(cString val);
   // Setzt den zugeordneten ererbten Wert auf den Wert des csStorage-Objektes
   void setInheritedValue(csStorage *val);
   // Setzt den zugeordneten ererbten char-Wert
   void setInheritedValue(char val);
   // Setzt den zugeordneten ererbten int-Wert
   void setInheritedValue(int val, bool thsnd_sep = true);
   // Setzt den zugeordneten ererbten double-Wert
   void setInheritedValue(double val, int prec = -1, bool thsnd_sep = true);
   // Loescht den zugeordneten ererbten Wert
   void clearInheritedValue();


   // Sonstiges
   // =========

   // Changed-Flag loeschen (Control als unveraendert markieren)
   inline void clearChanged()
      { onClearChanged(); }
   // Zustand des Changed-Flags erfragen
   inline bool getChanged() const
      { return onGetChanged(); }
   // ReadOnly-Zustand setzen
   inline void setReadOnly(bool ro_state)
      { onSetReadOnly(ro_state); }
   // ReadOnly-Zustand erfragen
   inline bool getReadOnly() const
      { return onGetReadOnly(); }


protected:

   // Zusaetzliche Events
   // ===================

   // Kontexthilfe zum Control wurde angefordert
   virtual void onHelpRequest();
   // Detailauswahl zum Control wurde angefordert
   virtual void onDetailRequest();
   // Die Enter-Taste wurde gedrueckt
   virtual void onEnterKey();
   // Die Escape-Taste wurde gedrueckt
   virtual void onEscapeKey();
   // Eine Navigationstaste wurde gedrueckt
   virtual void onNavKey(int vk_code);

   // Wird aufgerufen, wenn die Storage geloescht wird
   virtual void onEventDestructStorage(void *p1);
   // Wird aufgerufen, wenn die Query geloescht wird
   virtual void onEventDestructQuery(void *p1);
   // Wird aufgerufen, wenn sich das gebundene Datenobjekt geaendert hat
   virtual void onEventModified();

   // Wird aufgerufen bei derrNotNull
   virtual bool onErrorNotNull();
   // Wird aufgerufen bei derrFormat
   virtual bool onErrorFormat();
   // Wird aufgerufen bei derrRead
   virtual bool onErrorRead();
   // Wird aufgerufen bei derrWrite
   virtual bool onErrorWrite();
   // Feld als ungueltig markieren
   virtual void onErrorMark(bool mark);

   // Daten des Controls refreshen
   virtual bool onRefreshCtl(csStorage *store);
   // Abfrage des Controls erneut durchfuehren
   virtual bool onRequeryCtl(csQuery *query);
   // Daten des Controls pruefen
   virtual DATAERR onCheckCtl(csStorage *store);
   // Daten des Controls speichern
   virtual DATAERR onStoreCtl(csStorage *store);

   // Wird aufgerufen, nachdem das Storage-Objekt gesetzt wurde
   virtual void onSetStorage(csStorage *store);
   // Wird aufgerufen, bevor das Storage-Objekt entfernt wird
   virtual void onRemoveStorage(csStorage *store);

   // Wird aufgerufen, nachdem das Query-Objekt gesetzt wurde
   virtual void onSetQuery(csQuery *query);
   // Wird aufgerufen, bevor das Query-Objekt entfernt wird
   virtual void onRemoveQuery(csQuery *query);
   // Wird aufgerufen, um die Abfrage erneut durchzufuehren
   virtual bool onRequery();

   // Wird aufgerufen, um die (optische) Markierung fuer ererbte Werte einzuschalten
   virtual void onShowInheritedMark();
   // Wird aufgerufen, um die (optische) Markierung fuer ererbte Werte auszuschalten
   virtual void onHideInheritedMark();
   // Wird aufgerufen, um den aktuellen ererbten Wert anzuzeigen
   virtual void onShowInheritedVal();
   // Wird aufgerufen, um die Anzeige des ererbten Wertes zu beenden
   virtual void onHideInheritedVal();
   // Wird aufgerufen um festzustellen, ob das Control einen ueberschriebenen Wert hat
   virtual bool onIsInheritedValOverridden();

   // Changed-Flag loeschen (Control als unveraendert markieren)
   virtual void onClearChanged();
   // Zustand des Changed-Flags erfragen
   virtual bool onGetChanged() const;

   // ReadOnly-Zustand setzen
   virtual void onSetReadOnly(bool ro_state);
   // ReadOnly-Zustand erfragen
   virtual bool onGetReadOnly() const;


   // Ueberschriebene Events
   // ======================

   // Inhalt refreshen (false -> Abbruch)
   bool onRefresh(); // war: RefreshEvt()
   // Inhalt speichern (false -> Abbruch)
   bool onStore(); // war: StoreEvt()
   // Taste gedrueckt
   void onChar(cwCmdChar& cmd);
   // Blaettern zu Sibling erlauben?
   bool onAllowTurn(); // war: AllowTurnEvt()
   // Abbruch mit Speichern erlauben?
   bool onAllowStore(); // war: AllowStoreEvt()
   // Wird aufgerufen, wenn Fenster den Focus erhaelt
   void onGainFocus();
   // Wird aufgerufen, wenn Fenster den Focus verliert
   void onLoseFocus();

   // Entscheiden, ob das cwCmdChar-Kommando weiterverteilt werden soll
   bool onDispatchChar(const cwCmdChar& cmd);


   // Verzoegerte Ausfuehrung
   // =======================

   enum  { ediStart = cwWindow::ediUser,
      ediSetQuery,      // Verzoegerte Ausfuehrung von setQuery
      ediUser,          // ab hier Erweiterungen
   };

   // Verzoegertes Ausfuehren einer Operation
   void onExecDelayed(int id, void *data);


protected:

   // Interner Konstruktor
   cwControl(void *wnd);
   // Control erzeugen (Intern)
   void create(cwWindow *parent, int id, csStorage *store = 0, csQuery *query = 0);


private:

   csStorage *store;    // Gebundenes Datenobjekt
   csQuery *query;      // Zugeordnete Abfrage
   cString defval;      // Standardwert ("inherited value")

   // Intern: Verzoegerte Ausfuehrung von setQuery
   void execSetQuery(csQuery *query);

};


#endif

/*.EH.*/
