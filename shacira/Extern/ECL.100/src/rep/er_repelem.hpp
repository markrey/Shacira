/*.SH.*/

/*
 *  Headerfile for module er_repelem
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  er_repelem.cpp on Thursday March 21 2002  19:34:33
 */

#ifndef __er_repelem__
#define __er_repelem__

extern const double Rep_RowSpc;

// Headerfiles
// ===========================================================================

#include "base/eb_str.hpp"
#include "draw/ed_space.hpp"

c2dSize __ECL_DLLEXPORT__ QueryTextSize( cdSpace *space, const char *text, double width, double row_spc);
c2dSize __ECL_DLLEXPORT__ DrawTextAt( cdSpace *space, c2dPoint pos, const char *text, double width, double row_spc );
c2dSize __ECL_DLLEXPORT__ QueryAvgCharSize( cdSpace *space);

// ===========================================================================
// Definition cRepElem
// ---------------------------------------------------------------------------
//
// Basisklasse fuer alle Komponenten eines Reports
//
// Ein cRepElem ist ein rechteckiger Bereich innerhalb eines Reports mit den
// Attributen:
//    Ausrichtung des Inhaltes
//    Rahmenart und Abstand des Rahmens vom Inhalt
//    Groesse (fest vorgegeben, dynamisch (je nach Inhalt) oder zoombar
//    Abstand zum naechsten Element
//
// Methoden:
//    QuerySize : Erfragt den (vermutlich) benoetigten Platz
//    QueryActSize: Erfragt den tatsaechlich benoetigten Platz
//    SetSize: Weist dem Element eine feste Groesse zu
//    Restart: Nachricht fuer Elemente mit 'Gedaechtnis':
//                Neuanfang (true) / Neue Seite (false)
//    Draw:    Element soll sich zeigen. Diese Methode nennt die Position
//             der linken oberen Ecke an der das Element gezeichnet werden
//             soll. Das Element muss (!) diese Position zur rechten unteren
//             Ecke weiterruecken.
//    PageBreak: Methode, die ggf. einen Seitenumbruch durchfuehrt. Hier (im
//             cRepElem) nur als Durchreiche zum Besitzer realisert. D.h.,
//             das cRepElem laesst seinen Besitzer ggf. den Seitenumbruch durch-
//             fuehren.
//
// cBase
//  +--cRepElem
//
// ===========================================================================

class __ECL_DLLEXPORT__ cRepElem : /*public cSaveDynStorage,*/ public cBase {
   friend class cRepGroup;

public:
   enum WHERE { NONE=0, LEFT=1, RIGHT=2,
                VERTICAL=LEFT|RIGHT, H_CENTER=VERTICAL,
                TOP=4, TOPLEFT, TOPRIGHT, TOPVERTICAL,
                BOTTOM=8, BOTTOMLEFT, BOTTOMRIGHT, BOTTOMVERTICAL, BOTTOMTOP,

                TOPCENTER=TOPVERTICAL, BOTTOMCENTER=BOTTOMVERTICAL,
                HORIZONTAL=TOP|BOTTOM, V_CENTER=HORIZONTAL,
                ALL=HORIZONTAL|VERTICAL,
                CENTER=H_CENTER|V_CENTER
              };
   enum FLOWCTRL { NOWRAP, WRAP };

   // Klassenparameter
   static double default_frame_dist;      // Voreinstellung: Abstand des Rahmens vom Feldinhalt
   static cdLineStyle default_line_type;  // Voreinstellung: Linienart
   static FLOWCTRL default_flow;          // Voreinstellung: Umbruch erlaubt
   cRepGroup*owner;                       // Besitzer des Feldes
   c2dSize wanted_size;                   // Durch Inhalt bestimmte Groesse
   c2dSize act_size;                      // tatsaechliche Groesse
   bool zoomable;                         // Feld darf vergroessert werden
   bool handle_break;                     // Element erkennt selbst, ob es noch auf
                                          // die aktuelle Seite passt
   WHERE align;
   WHERE frame;
   cdLineStyle line_type;                 // Linienart
   FLOWCTRL flow;
   double frame_dist;                     // Abstand des Rahmens zum Inhalt
   c2dSize  dist;                         // Abstand zum Vorgaenger in mm
   double size;                           // Groesse in mm (Breite bzw. Hoehe)

   static void setDefaultFrameDist(double dfd);
   static double getDefaultFrameDist();

   inline cRepElem(cRepGroup* owner = 0,
                   double size = 0,
                   WHERE align = NONE,
                   WHERE frame = NONE,
                   const c2dSize& dist = c2dSize(0,0))
   {
      init(owner, size, align, frame, dist);
   }

   virtual ~cRepElem();
   bool Align(c2dPoint& pos, double x_corr = 0, bool corr_pos = true);
   virtual bool /*out*/ PageBreak(bool& out, bool force, cdSpace *space, c2dPoint& pos);
   virtual void Draw(bool& out, cdSpace *space, c2dPoint& pos);
   virtual c2dSize& QuerySize(cdSpace *space);
   virtual c2dSize& QueryActSize(cdSpace *space);
   virtual void SetSize(const c2dSize& s);
   virtual void Restart(bool full);

   bool AdjacentToFrameBottom() const;
   bool AdjacentToFrameTop() const;
   bool AdjacentToFrameRight() const;
   bool AdjacentToFrameLeft() const;

private:
   cRepElem *prev, *next;
   void init(cRepGroup* owner, double size, WHERE align, WHERE frame, const c2dSize& dist);

};


// ===========================================================================
// Definition cRepNewPage
// ---------------------------------------------------------------------------
//
// Erzwingt einen Seitenvorschub.
//
// cBase
//  +--cRepElem
//      +--cRepNewPage
//
// ===========================================================================

class __ECL_DLLEXPORT__ cRepNewPage : public cRepElem {

public:
   inline cRepNewPage(cRepGroup* owner) :
      cRepElem(owner)
   {
      handle_break = true;
   }

   void Draw(bool& out, cdSpace *space, c2dPoint& pos);

};


// ===========================================================================
// Definition cRepGroup
// ---------------------------------------------------------------------------
//
// cRepGroup ist eine geordnete Sammlung von RepElems. Eine cRepGroup
// beinhaltet eine Liste von Reportelementen und kann diese entweder
// negeneinander (horizontal == true) oder untereinander darstellen. Eine
// cRepGroup, deren Elemente untereinander dargestellt werden, unterstuetzt
// autom. den Seitenumbruch, d.h. vor der Anzeige jedes Elementes innerhalb
// der Gruppe wird geprueft, ob es auf der akt. Seite noch Platz findet.
//
// cBase
//  +--cRepElem
//      +--cRepGroup
//
// ===========================================================================

class __ECL_DLLEXPORT__ cRepGroup : public cRepElem {

public:
   long font_idx;

   inline cRepGroup(cRepGroup* owner = NULL,
                    bool horz = true,
                    double size = 0,
                    WHERE align = NONE,
                    WHERE frame = NONE,
                    const c2dSize& dist = c2dSize(0,0)) :
      cRepElem(owner, size, align, frame, dist)
   {
      init(owner, horz);
   }

  ~cRepGroup();

   virtual bool AddField(cRepElem *elem);
   virtual bool RemoveField(cRepElem *elem);
   virtual bool HasTitle() const { return false; }
   virtual void Draw(bool& out, cdSpace *space, c2dPoint& pos);
   virtual c2dSize& QuerySize(cdSpace *space);
   virtual void SetSize(const c2dSize& s);
   virtual void SetFont(int font_idx) { cRepGroup::font_idx = font_idx; }

   cRepElem *GetFirst() const { return first; }
   cRepElem *GetNext(cRepElem *elem) const { return elem ? elem->next : NULL; }

   bool IsHorizontal() const { return horizontal; }
   bool IsVertical() const { return !horizontal; }

protected:
   bool     horizontal;
   c2dSize    zoom_ext;

private:
   cRepElem *first, *last;
   void init(cRepGroup* owner, bool horz);

};


// ===========================================================================
// Definition cRepLine
// ---------------------------------------------------------------------------
//
// cRepLine ist ein Synonym fuer eine cRepGroup mit horizontal (nebeneinander)
// angeordneten Report-Elementen.
//
// cBase
//  +--cRepElem
//      +--cRepGroup
//          +--cRepLine
//
// ===========================================================================

class __ECL_DLLEXPORT__ cRepLine : public cRepGroup {

public:
   inline cRepLine(cRepGroup *owner,
                   long font_idx = 0,
                   double line_spacing = 0,
                   WHERE align = cRepElem::NONE,
                   WHERE frame = cRepElem::NONE) :
      cRepGroup(owner, true, 0, align, frame, c2dSize(0,line_spacing))
   {
      cRepLine::font_idx = font_idx;
   }

};


// ===========================================================================
// Definition cRepColumn
// ---------------------------------------------------------------------------
//
// cRepColumn ist ein Synonym fuer eine cRepGroup mit vertikal (untereinander)
// angeordneten Report-Elementen.
//
// cBase
//  +--cRepElem
//      +--cRepGroup
//          +--cRepColumn
//
// ===========================================================================

class __ECL_DLLEXPORT__ cRepColumn : public cRepGroup {

public:
   inline cRepColumn(cRepGroup *owner,
                     long font_idx = 0,
                     double col_spacing = 0,
                     WHERE align = cRepElem::NONE,
                     WHERE frame = cRepElem::NONE) :
      cRepGroup(owner, false, 0, align, frame, c2dSize(col_spacing,0))
   {
      cRepColumn::font_idx = font_idx;
   }

};


// ===========================================================================
// Definition cRepTable
// ---------------------------------------------------------------------------
//
// cRepTable ist ein Synonym fuer eine cRepGroup mit vertikal (untereinander)
// angeordneten Report-Elementen, bei denen das erste Element der Gruppe auf
// jeder neuen Report-Seite wiederholt wird, solange die cRepGroup noch nicht
// vollstaendig ausgegeben ist.
//
// cBase
//  +--cRepElem
//      +--cRepGroup
//          +--cRepTable
//
// ===========================================================================

class __ECL_DLLEXPORT__ cRepTable : public cRepGroup {

public:
   inline cRepTable(cRepGroup *owner,
                    cRepElem *title,
                    double size = 0,
                    WHERE align = NONE,
                    WHERE frame = NONE) :
      cRepGroup(owner, false, size, align, frame, c2dSize(0,0))
   {
      handle_break = true;
      AddField(title);
   }

   inline bool HasTitle() const
      { return true; }

};


// ===========================================================================
// Definition cRepText
// ---------------------------------------------------------------------------
//
// cBase
//  +--cRepElem
//      +--cRepText
//
// ===========================================================================

class __ECL_DLLEXPORT__ cRepText : public cRepElem {
   friend class cRepChgText;

public:
   static   long *font_ids;   // IDs aller registrierten Fonts
   static   long font_num;    // Anzahl registrierter Fonts
   long     font_idx;         // Index in FontIDs-Tabelle

   static void RegisterFontIDs(long *ids, int count);

protected:
   cString* text;             // Text
   c2dSize  avg_char_size;    // mittlere Zeichengroesse
   bool     multiline;        // Umbruch auf mehrere Zeilen durchfuehren ?
   int      estim_line_count; // Geschaetzte Anzahl Zeilen, falls Multiline
   c2dSize  act_textsize;     // vom Text beanspruchter Platz

public:
   int      prec;             // Nachkommastellen fuer dez. Tabulator

   cRepText(cRepGroup* owner, cString* text, long font_idx = 0, double size = 0,
            WHERE align = NONE, WHERE frame = NONE, const c2dSize& dist = c2dSize(0,0)) :
      cRepElem(owner, size, align, frame, dist),
      act_textsize(-1, -1)
   {
      init(owner, text, font_idx, size);
   }
   ~cRepText();

   void DrawText( bool out, cdSpace *space, c2dPoint& pos, double x_corr, cString text );
   virtual void PrepDraw(cdSpace *space);
   virtual bool /*changed*/ GetValue( void ) { return false;};
   virtual c2dSize& QuerySize(cdSpace *space);
   virtual void Draw( bool& out, cdSpace *space, c2dPoint& pos );

private:
   void init(cRepGroup *owner, cString *text, long font_idx, double size);

};


// ===========================================================================
// Definition cRepStatText
// ---------------------------------------------------------------------------
//
// cBase
//  +--cRepElem
//      +--cRepText
//          +--cRepStatText
//
// ===========================================================================

class __ECL_DLLEXPORT__ cRepStatText : public cRepText {
public:
   inline cRepStatText(cRepGroup* owner,
                       const cString& text,
                       long font_idx = 0,
                       double size = 0,
                       WHERE align = NONE,
                       WHERE frame = NONE,
                       const c2dSize& dist = c2dSize(0,0)) :
      cRepText(owner, new0 cString(text), font_idx, size, align, frame, dist)
   { }

   virtual ~cRepStatText() { delete text; }
};


// ===========================================================================
// Definition cRepVarText
// ---------------------------------------------------------------------------
//
// cBase
//  +--cRepElem
//      +--cRepText
//          +--cRepVarText
//
// ===========================================================================

class __ECL_DLLEXPORT__ cRepVarText : public cRepText {
public:
   inline cRepVarText(cRepGroup *owner,
                      cString *text,
                      long font_idx = 0,
                      double size = 0,
                      WHERE align = NONE,
                      WHERE frame = NONE,
                      const c2dSize& dist = c2dSize(0,0)) :
      cRepText(owner, text, font_idx, size, align, frame, dist)
   { }

   virtual bool /*changed*/ GetValue( void );
   virtual void Draw( bool& out, cdSpace *space, c2dPoint& pos );
};


// ===========================================================================
// Definition cRepVariable
// ---------------------------------------------------------------------------
//
// cBase
//  +--cRepElem
//      +--cRepText
//          +--cRepVariable
//
// ===========================================================================

class __ECL_DLLEXPORT__ cRepVariable : public cRepText {

public:
   typedef cString (*VAL_FUNC_PTR)();

   inline cRepVariable(cRepGroup *_owner,
                       VAL_FUNC_PTR _func_ptr,
                       long _font_id = 0,
                       double _size = 0,
                       WHERE _align = NONE,
                       WHERE _frame = NONE,
                       const c2dSize& _dist = c2dSize(0,0)) :
      cRepText(_owner, &value, _font_id, _size, _align, _frame, _dist)
   {
      func_ptr = _func_ptr;
   }

   inline cRepVariable(cRepGroup *_owner,
                       long _font_id = 0,
                       double _size = 0,
                       WHERE _align = NONE,
                       WHERE _frame = NONE,
                       const c2dSize& _dist = c2dSize(0,0)) :
      cRepText(_owner, &value, _font_id, _size, _align, _frame, _dist)
   {
      func_ptr = NULL;
   }

   bool /*changed*/ GetValue();

protected:
   VAL_FUNC_PTR func_ptr;
   cString value;

};


// ===========================================================================
// Definition cRepAbstract
// ---------------------------------------------------------------------------
//
// Elemente dieser Klasse haben selbst keinen Platzbedarf im Report und dienen
// lediglich Verwaltungszwecken. Das cRepAbstract-Element wird an einer be-
// stimmten Stelle im Report eingebunden und aktiviert zum Zeitpunkt des
// Report-Aufbaus zeitsynchron an der Stelle der Definition seine Action()-
// Methode.
//
// cBase
//  +--cRepElem
//      +--cRepAbstract
//
// ===========================================================================

class __ECL_DLLEXPORT__ cRepAbstract : public cRepElem {

public:
   inline cRepAbstract(cRepGroup *_owner) :
      cRepElem(_owner, 0, NONE, NONE, c2dSize(0,0))
   { }

   void Draw(bool& out, cdSpace *space, c2dPoint& pos);

   virtual void Action() = 0;

};


// ===========================================================================
// Definition cRepChgText
// ---------------------------------------------------------------------------
//
// Ueber dieses Element kann der Wert eines beliebigen cRepText-Elementes
// synchron zum Aufbau des gesamten Reports manipuliert werden.
//
// cBase
//  +--cRepElem
//      +--cRepAbstract
//          +--cRepChgText
//
// ===========================================================================

class __ECL_DLLEXPORT__ cRepChgText : public cRepAbstract {

public:
   inline cRepChgText(cRepGroup *_owner, cRepText *_text_elem, const cString& _value) :
      cRepAbstract(_owner)
   {
      text_elem = _text_elem;
      value = _value;
   }

   void Action();

protected:
   cRepText *text_elem;
   cString value;

};


// ===========================================================================
// Definition cRepGraphic
// ---------------------------------------------------------------------------
//
// cBase
//  +--cRepElem
//      +--cRepGraphic
//
// ===========================================================================

struct MYPOINTL {
   long x, y;
};

class __ECL_DLLEXPORT__ cRepGraphic : public cRepElem {

public:
   cRepGraphic(cRepGroup* _owner, WHERE _align = NONE, WHERE _frame = NONE,
      const c2dSize& _dist = c2dSize(0,0)) :
      cRepElem(_owner, 0, _align, _frame,  _dist)
   {
      width = height = 0;
   }

   bool /*changed*/ GetValue() { return false;};
   c2dSize& QuerySize(cdSpace *space);
   void Draw(bool& out, cdSpace *space, c2dPoint& pos);

   // Faellt weg:
   void Move(int, int) { }
   void Line(int, int) { }
   void Text(const char *) { }
   void PolyLine(int, MYPOINTL *) { }
   void Polygon(int, MYPOINTL *, bool) { }
   void SetTextAlign(int, int) { }
   void SetCharAngle(int, int) { }
   void SelectFont(cdSpace *, const char *, int) { }

protected:
   cdMemorySpace mem_space;
   double width, height;

};


#endif

/*.EH.*/
