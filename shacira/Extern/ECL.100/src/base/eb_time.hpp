/*.SH.*/

/*
 *  Headerfile for module eb_time
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  eb_time.cpp on Monday March 25 2002  16:44:54
 */

#ifndef __eb_time__
#define __eb_time__


// Headerdateien
// ===========================================================================

#include <time.h> /* wg. time_t */

#include "base/eb_base.hpp"
#include "base/eb_str.hpp"

class cDateTime;

// ===========================================================================
// Declaration cDate
// ---------------------------------------------------------------------------
//
// cBase
//  +--cDate - Datum (an Tagen orientiert)
//
// ===========================================================================

class __ECL_DLLEXPORT__ cDate : public cBase {

public:
   // Datum ueber aktuelles Datum erzeugen
   cDate();
   // Datum ueber julianisches Datum erzeugen
   cDate(long jd);
   // Datum ueber Tag, Monat und Jahr erzeugen (Jahreszahl 2- oder 4-stellig)
   cDate(int year, int month, int day);
   // Datum ueber KW und Jahr erzeugen
   cDate(int year, int week);
   // Datum ueber Textform erzeugen (bei weekyr=true wird KW/JJJJ angenommen)
   cDate(const char *str, bool weekyr = false);

   // Datum ueber cDateTime erzeugen
   cDate(const cDateTime &other);
   // Zuweisungsoperator (cDateTime)
   cDate &operator=(const cDateTime &other);

   // Tag ermitteln (1..31)
   int getDay() const;
   // Monat ermitteln (1..12)
   int getMonth() const;
   // Jahr ermitteln (nur 4-stellig)
   int getYear() const;
   // Liefert das Standard-Textformat (TT.MM.JJJJ)
   cString getStr() const;


   // Woche
   // =====

   // Wochentag ermitteln (0..6, 0 = Montag)
   int getWeekday() const
      { return jd % 7; }
   // Aufzaehlung aller Wochentage
   enum WEEKDAY {
      wdayMonday    = 0,
      wdayTuesday   = 1,
      wdayWednesday = 2,
      wdayThursday  = 3,
      wdayFriday    = 4,
      wdaySaturday  = 5,
      wdaySunday    = 6,
   };

   // Kalenderwoche
   int getWeek() const;
   // Liefert das Standard-Textformat der Kalenderwoche (KW WW/JJJJ)
   cString getWeekStr() const
      { return cStringf("KW %02d/%04d", getWeek(), getYear()); }


   // Vergleichsoperatoren
   // ====================

   // Vergleichsoperatoren (Direktvergleich des Julianischen Datums)
   int operator==(const cDate& other) const
      { return jd == other.jd; }
   int operator!=(const cDate& other) const
      { return jd != other.jd; }
   int operator<(const cDate& other) const
      { return jd < other.jd; }
   int operator<=(const cDate& other) const
      { return jd < other.jd; }
   int operator>(const cDate& other) const
      { return jd < other.jd; }
   int operator>=(const cDate& other) const
      { return jd < other.jd; }


   // Abstaende zwischen Daten
   // ========================

   // Tage zwischen zwei Daten
   int operator-(const cDate& other) const
      { return (jd - other.jd); }
   // Tage zwischen zwei Daten
   int getDaysTo(const cDate& other) const
      { return (jd - other.jd); }
   // Wochen zwischen zwei Daten
   int getWeeksTo(const cDate& other) const
      { return (jd - other.jd) / 7; }
   // Monate zwischen zwei Daten
   int getMonthsTo(const cDate& other) const
      { return getYearsTo(other)*12 + (getMonth()-other.getMonth()); }
   // Jahre zwischen zwei Daten
   int getYearsTo(const cDate& other) const
      { return getYear()-other.getYear(); }


   // Datumsarithmetik
   // ================

   // Tage von Datum subtrahieren
   cDate operator-(int days) const
      { return cDate(jd - days); }
   // Tage zu Datum addieren
   cDate operator+(int days) const
      { return cDate(jd + days); }
   // Tage zu Datum addieren
   cDate addDays(int days) const
      { return cDate(jd + days); }
   // Wochen zu Datum addieren
   cDate addWeeks(int weeks) const
      { return cDate(jd + weeks * 7); }
   // Monate zu Datum addieren
   cDate addMonths(int months) const;
   // Jahre zu Datum addieren
   cDate addYears(int years) const
      { return addMonths(years * 12); }


   // Julianisches Datum
   // ==================

   // julianisches Datum (fuer 12:00h)
   long getJulianDate() const
      { return jd; }
   // Umrechnung Kalender -> Julianisches Datum
   static long getJulianDate(int year, int month, int day);
   // Umrechnung Julianisches Datum -> Kalender
   static void getCalendar(long jd, int &year, int &month, int &day);


   // Maskieren
   // =========

   enum MASKS {
      mskYear  = 0x0020,
      mskMonth = 0x0010,
      mskDay   = 0x0008,
   };

   // Liefert das maskierte Datum (Komponenten mit 'false' haben Defaultwerte)
   cDate getMasked(bool year, bool month, bool day) const;
   // Liefert das maskierte Datum (Bitmaske, Bits 5..3 = YMD)
   cDate getMasked(int mask) const;


   // Umwandlung
   // ==========

   // Umwandlung cDate <- time_t
   static cDate conv(const time_t& tstamp);
   // Umwandlung time_t <- cDate
   static time_t conv(const cDate& date);


   // Sonstiges
   // =========

   // Tag im Jahr ermitteln (0..364/365)
   int getYearDay() const;
   // Laenge des Monats (28..31)
   int getMonthLength() const;
   static int getMonthLength(int year, int month);
   // Laenge des Jahres (365..366)
   int getYearLength() const;
   static int getYearLength(int year);

   // Monat als String
   cString getMonthStr() const
      { return getMonthStr(getMonth()); }
   static cString getMonthStr(int month);

   // Wochentag als String
   cString getWeekdayStr() const
      { return getWeekdayStr(getWeekday()); }
   static cString getWeekdayStr(int weekday);


private:
   // interne Darstellung: "Julianisches Datum", am 01.01.4713 v.Chr., 12:00h
   // beginnt die Zaehlung mit 0. (Der 01.01.2000, 12:00h ist 2451545.0 JD)
	long jd;
};


// ===========================================================================
// Declaration cTime
// ---------------------------------------------------------------------------
//
// cBase
//  +--cTime - Uhrzeit (an Sekunden orientiert)
//
// ===========================================================================

class __ECL_DLLEXPORT__ cTime : public cBase {

public:
   // Uhrzeit ueber aktuelle Uhrzeit erzeugen
   cTime();
   // Uhrzeit ueber Sekunden seit Mitternacht erzeugen
   cTime(int daysec);
   // Uhrzeit ueber Stunde, Minute und Sekunde erzeugen
   cTime(int hour, int min, int sec = 0);
   // Uhrzeit ueber Textform erzeugen
   cTime(const char *str);

   // Uhrzeit ueber cDateTime erzeugen
   cTime(const cDateTime &other);
   // Zuweisungsoperatoren
   cTime &operator=(const cDateTime &other);

   // Stunde ermitteln (0..23)
   int getHour() const
      { return (ts % TIC_DAY) / TIC_HOUR; }
   // Minute ermitteln (0..59)
   int getMin() const
      { return (ts % TIC_HOUR) / TIC_MIN; }
   // Sekunde ermitteln (0..59)
   int getSec() const
      { return (ts % TIC_MIN) / TIC_SEC; }
   // Liefert das Standard-Textformat (HH:MM:SS)
   cString getStr() const
      { return cStringf("%02d:%02d:%02d", getHour(), getMin(), getSec()); }


   // Vergleichsoperatoren
   // ====================

   // Vergleichsoperatoren (Direktvergleich der internen Darstellung)
   int operator==(const cTime& other) const
      { return ts == other.ts; }
   int operator!=(const cTime& other) const
      { return ts != other.ts; }
   int operator<(const cTime& other) const
      { return ts < other.ts; }
   int operator<=(const cTime& other) const
      { return ts < other.ts; }
   int operator>(const cTime& other) const
      { return ts < other.ts; }
   int operator>=(const cTime& other) const
      { return ts < other.ts; }


   // Abstaende zwischen Uhrzeiten
   // ============================

   // Sekunden zwischen zwei Uhrzeiten
   int operator-(const cTime& other) const
      { return (ts - other.ts); }
   // Sekunden zwischen zwei Uhrzeiten
   int getSecsTo(const cTime& other) const
      { return (ts - other.ts); }
   // Minuten zwischen zwei Uhrzeiten
   int getMinsTo(const cTime& other) const
      { return (ts - other.ts) / 60; }
   // Stunden zwischen zwei Uhrzeiten
   int getHoursTo(const cTime& other) const
      { return (ts - other.ts) / 3600; }


   // Uhrzeitarithmetik
   // =================

   // Sekunden von Uhrzeit subtrahieren
   cTime operator-(int secs) const
      { return cTime(ts - secs); }
   // Sekunden zu Uhrzeit addieren
   cTime operator+(int secs) const
      { return cTime(ts + secs); }
   // Sekunden zu Uhrzeit addieren
   cTime addSecs(int secs) const
      { return cTime(ts + secs); }
   // Minuten zu Uhrzeit addieren
   cTime addMins(int mins) const
      { return cTime(ts + mins * 60); }
   // Stunden zu Uhrzeit addieren
   cTime addHours(int hours) const
      { return cTime(ts + hours * 3600); }


   // Maskieren
   // =========

   enum MASKS {
      mskHour  = 0x0004,
      mskMin   = 0x0002,
      mskSec   = 0x0001
   };

   // Liefert die maskierte Uhrzeit (Komponenten mit 'false' haben Defaultwerte)
   cTime getMasked(bool hour, bool min, bool sec) const;
   // Liefert die maskierte Uhrzeit (Bitmaske, Bits 2..0 = HMS)
   cTime getMasked(int mask) const;


   // Umwandlung
   // ==========

   // Umwandlung cTime <- time_t
   static cTime conv(const time_t& tstamp);
   // Umwandlung time_t <- cTime
   static time_t conv(const cTime& time);


   // Sonstiges
   // =========

   // Sekunde am Tag ermitteln (0..86399)
   int getDaySec() const
      { return ts; }

private:
   enum {
      TIC_SEC = 1,
      TIC_MIN = TIC_SEC * 60,
      TIC_HOUR = TIC_MIN * 60,
      TIC_DAY = TIC_HOUR *24
   };
   int ts;
};


// ===========================================================================
// Declaration cDateTime
// ---------------------------------------------------------------------------
//
// cBase
//  +--cDateTime - Zeitstempel (Datum und Uhrzeit)
//
// ===========================================================================

class __ECL_DLLEXPORT__ cDateTime : public cBase {

public:
   // Initialisierung ueber aktuelles Datum/Uhrzeit
   cDateTime() :
      date(),time() {}
   // Initialisierung ueber direkte Angabe (Jahreszahl 2- oder 4-stellig)
   cDateTime(int year, int month, int day, int hour, int min, int sec=0) :
      date(year,month,day),time(hour,min,sec) {}
   // Initialisierung ueber cDate und cTime
   cDateTime(const cDate &d, const cTime &t) :
      date(d),time(t) {}
   // Initialisierung ueber time_t
   cDateTime(time_t time);
   // Initialisierung ueber Julianisches Datum
   cDateTime(double jd);

   // Initialisierung ueber cDate & 00:00:00h
   cDateTime(const cDate &d) :
      date(d),time((int)0) {}
   // Zuweisungsoperator cDate & 00:00:00h
   cDateTime &operator=(const cDate &other)
      { *this = cDateTime(other); return *this; }

   // Initialisierung ueber cTime & aktuelles Datum
   cDateTime(const cTime &t) :
      date(),time(t) {}
   // Zuweisungsoperator cTime & aktuelles Datum
   cDateTime &operator=(const cTime &other)
      { *this = cDateTime(other); return *this; }

   // Zeitstempel ueber Textform erzeugen
   cDateTime(const char *str);
   // Liefert das Standard-Textformat (TT.MM.JJJJ HH:MM:SS)
   cString getStr() const
      { return date.getStr() + " " + time.getStr(); }


   // Datum
   // =====

   // Datumskomponente ermitteln
   const cDate &getDate() const
      { return date; }
   // Tag ermitteln (1..31)
   int getDay() const
      { return date.getDay(); }
   // Monat ermitteln (1..12)
   int getMonth() const
      { return date.getMonth(); }
   // Jahr ermitteln (nur 4-stellig)
   int getYear() const
      { return date.getYear(); }
   // Liefert das Standard-Textformat des Datums (TT.MM.JJJJ)
   cString getDateStr() const
      { return date.getStr(); }


   // Zeit
   // ====

   const cTime &getTime() const
      { return time; }
   // Stunde ermitteln (0..24)
   int getHour() const
      { return time.getHour(); }
   // Minute ermitteln (0..59)
   int getMin() const
      { return time.getMin(); }
   // Sekunde ermitteln (0..59)
   int getSec() const
      { return time.getSec(); }
   // Liefert das Standard-Textformat der Uhrzeit (HH:MM:SS)
   cString getTimeStr() const
      { return time.getSec(); }


   // Vergleichsoperatoren
   // ====================

   int operator==(const cDateTime& other) const
      { return (*this - other) == 0; }
   int operator!=(const cDateTime& other) const
      { return (*this - other) != 0; }
   int operator<(const cDateTime& other) const
      { return (*this - other) < 0; }
   int operator<=(const cDateTime& other) const
      { return (*this - other) <= 0; }
   int operator>(const cDateTime& other) const
      { return (*this - other) > 0; }
   int operator>=(const cDateTime& other) const
      { return (*this - other) >= 0; }


   // Abstaende zwischen Zeitstempeln
   // ===============================

   // Sekunden zwischen zwei Zeitstempeln
   long operator-(const cDateTime& other) const
      { return (date - other.date) * 86400 + (time - other.time); }
   // Sekunden zwischen zwei Zeitstempeln
   long getSecsTo(const cDateTime& other) const
      { return (*this - other); }
   // Minuten zwischen zwei Zeitstempeln
   long getMinsTo(const cDateTime& other) const
      { return (*this - other) / 60; }
   // Stunden zwischen zwei Zeitstempeln
   long getHoursTo(const cDateTime& other) const
      { return (*this - other) / 3600; }
   // Tage zwischen zwei Zeitstempeln
   int getDaysTo(const cDateTime& other) const
      { return date - other.date; }
   // Wochen zwischen zwei Zeitstempeln
   int getWeeksTo(const cDateTime& other) const
      { return (date - other.date) / 7; }
   // Monate zwischen zwei Zeitstempeln
   int getMonthsTo(const cDateTime& other) const
      { return date.getMonthsTo(other.date); }
   // Jahre zwischen zwei Zeitstempeln
   int getYearsTo(const cDateTime& other) const
      { return date.getYearsTo(other.date); }


   // Zeitstempelarithmetik
   // =====================

   // Sekunden zum Zeitstempel addieren
   cDateTime addSecs(long secs) const;
   // Minuten zum Zeitstempel addieren
   cDateTime addMins(long mins) const
      { return addSecs(mins * 60); }
   // Stunden zum Zeitstempel addieren
   cDateTime addHours(long hours) const
      { return addSecs(hours * 3600); }
   // Tage zum Zeitstempel addieren
   cDateTime addDays(int days) const
      { return cDateTime(date + days, time); }
   // Wochen zum Zeitstempel addieren
   cDateTime addWeeks(int weeks) const
      { return addDays(weeks * 7); }
   // Monate zum Zeitstempel addieren
   cDateTime addMonths(int months) const
      { return cDateTime(date.addMonths(months),time); }
   // Jahre zum Zeitstempel addieren
   cDateTime addYears(int years) const
      { return addMonths(years * 12); }


   // Julianisches Datum (incl. Uhrzeit)
   // ==================================

   // Julianisches Datum
   double getJulianDate() const
      { return (double)time.getDaySec()/86400 + date.getJulianDate() - 0.5; }


   // Maskieren
   // =========

   enum MASKS {
      mskYear  = 0x0020,
      mskMonth = 0x0010,
      mskDay   = 0x0008,
      mskHour  = 0x0004,
      mskMin   = 0x0002,
      mskSec   = 0x0001
   };

   // Liefert den maskierten Zeitstempel (Komponenten mit 'false' haben Defaultwerte)
   cDateTime getMasked(bool year, bool month, bool day, bool hour, bool min, bool sec) const
      { return cDateTime( getDate().getMasked(year, month, day),
                          getTime().getMasked(hour, min, sec) ); }
   // Liefert den maskierten Zeitstempel (Bitmaske, Bits 5..0 = YMDHMS)
   cDateTime getMasked(int mask) const
      { return cDateTime( getDate().getMasked(mask),
                          getTime().getMasked(mask) ); }


   // Umwandlung
   // ==========

   // Umwandlung cDateTime <- time_t
   static cDateTime conv(const time_t& tstamp);
   // Umwandlung time_t <- cDateTime
   static time_t conv(const cDateTime& datetime);


private:
   cDate date;
   cTime time;
};


#endif

/*.EH.*/
