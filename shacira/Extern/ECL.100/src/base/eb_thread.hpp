/*.SH.*/

/*
 *  Headerfile for module eb_thread
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  eb_thread.cpp on Thursday December 27 2001  20:25:14
 */

#ifndef __eb_thread__
#define __eb_thread__


// Headerfiles
// ===========================================================================

#include "base/eb_err.hpp"
#include "base/eb_except.hpp"
#include "base/eb_sema.hpp"
#include "base/eb_store.hpp"


// ===========================================================================
// cThread
// ---------------------------------------------------------------------------
//
// Jedes Thread-Objekt durchlaeuft folgende Zustaende in dieser Reihenfolge:
//
//    tsCreated      - Thread-Objekt angelegt, Thread noch nicht gestartet
//
//    tsStarted      - Thread gestartet, laeuft noch nicht
//
//    tsRunning      - Thread laeuft (onEnter, onMain, onLeave)
//
// und landet schließlich bei einem der folgenden Zustaende:
//
//    tsTerminated   - Thread normal zu Ende gelaufen
//                     Kann bei Bedarf nochmal gestartet werden
//
//    tsWaitForEnd   - Thread-Objekt geloescht, bevor Thread zu Ende gelaufen
//                     Destruktor wird bis zum Thread-Ende verzoegert
//
// Beispiele:
//
//    static cThread t; // Statisches Thread-Objekt
//    void f1()
//    {
//       t.start(); // Thread starten
//       ...
//       // Thread laeuft irgendwann zu Ende (tsTerminated), t lebt noch.
//       ...
//       t.waitFor(); // Sicheres Warten auf Thread-Ende
//       ...
//       t.start(cThread::teEnd); // Thread nochmal starten (mit Blocking)
//    }
//
//    void f2()
//    {
//       cThread t; // Automatisches Thread-Objekt
//       t.start();
//       ...
//       // f2() wird blockiert, bis Thread terminiert (tsWaitForEnd)
//       // ACHTUNG: Virtuelle Funktionen werden nicht mehr aufgerufen!!!
//    }
//
//    void f3()
//    {
//       cThread t; // Automatisches Thread-Objekt
//       t.start(cThread::teEnd); // Besser: Warten auf Thread-Ende
//    }
//
//    void f4()
//    {
//       cThread *t = new cThread(cThread::tdAutoDel);
//       t->start();
//       // Tatsaechliches delete von t erst nach Thread-Ende
//    }
//
// Der Zustand tsWaitForEnd fuehrt unweigerlich zur Loeschung des Thread-
// Objektes.
//
// cBase
//  +--cThread
//
// ===========================================================================

class __ECL_DLLEXPORT__ cThread : public cBase {
   friend void __ECL_THREADLNK__ BaseThread(void *);
   friend class cwThread;

public:

   // Konstruktoren
   // =============

   enum AUTO_DEL {   // Auto-Delete
      tdAutoDel,     //  - Auto-Delete aktiv (nur bei dynamischen Objekten!!!)
      tdNoAutoDel    //  - Auto-Delete nicht aktiv
   };

   // Konstruiere normalen (secondary) Thread
   cThread(AUTO_DEL _auto_del = tdNoAutoDel);
   // Konstruiere normalen (secondary) Thread mit Angabe der Stack-Groese
   cThread(int _stacksize, AUTO_DEL _auto_del = tdNoAutoDel);
   // Konstruiere Main-Thread
   cThread(int _argc, char **_argv);
   // Destruktor
   virtual ~cThread();


   // Allgemeines
   // ===========

   enum EVENT {      // Moegliche Thread-Events:
      teNone,        //  - Kein Event (d.h. nicht warten)
      teStart,       //  - Thread gestartet, onEnter durchlaufen, naechster Aufruf onMain
      teEnd          //  - Thread ist beendet, letzter Aufruf war onLeave
   };

   // Thread starten mit Parameteruebergabe
   bool start(void *extra, EVENT wait_event = teNone);
   // Thread starten ohne Parameteruebergabe
   bool start(EVENT wait_event = teNone);

   // Auf Event warten
   void waitFor(EVENT event = teEnd);

   // Liefert den Returncode von onMain
   int getRC() const
      { return rc; }
   // Liefert die ID des Threads
   inline int getThreadId() const
      { return tid; }

   // Liefert die ID des aktuellen Threads
   static int getCurrentThreadId();
   // Liefert die ID des aktuellen Prozesses
   static int getCurrentProcessId();


   // Aktueller Zustand
   // =================

   enum STATE {      // Zustaende des Thread-Objektes:
      tsCreated,     //  - Thread-Objekt angelegt, Thread noch nicht gestartet
      tsStarted,     //  - Thread gestartet, laeuft noch nicht
      tsRunning,     //  - Thread laeuft (onEnter, onMain, onLeave)
      tsTerminated,  //  - Thread normal zu Ende gelaufen
      tsWaitForEnd   //  - Destruktor verzoegert bis zum Thread-Ende
   };

   // Aktuellen Zustand erfragen
   STATE getState() const
      { return state; }
   // Ist der Thread am Laufen?
   bool isRunning() const
      { return state != tsCreated && state != tsTerminated; }


   // Main-Thread
   // ===========

   // Ist dieser Thread der Haupt-Thread des Prozesses?
   bool isMainThread() const;
   // Zeiger auf Main-Thread des Prozesses liefern
   static cThread *getMainThread();
   // Anzahl Kommandozeilenargumente
   int getArgCount() const
      { return argc; }
   // Zeiger auf Kommoandozeilenargument
   const char *getArgValue(int arg) const
      { return arg < argc ? argv[arg] : NULL; }


   // Phasen der Thread-Bearbeitung
   // =============================
   // Die folgenden Methoden werden _ausschliesslich_ von der Basisklasse aufge-
   // rufen, um bestimmte Phasen der Thread-Bearbeitung durchzufuehren.

   enum { RC_KILL = 99 };    // Wird an onLeave() bei Abschuss des Threads uebergeben

   // Bei diesem Event kann sich der Thread initialisieren
   virtual bool onEnter(void *extra);
   // onMain-Funktion des Threads
   virtual int onMain(void *extra);
   // Bei diesem Event kann sich der Thread deinitialisieren
   virtual void onLeave(int rc);


   // Exceptions
   // ==========
   // Liefert onException false, wird die Exception-Behandlung mit dem naechsten
   // Handler fortgesetzt. Bei true werden keine weiteren Handler mehr aufgerufen

   // Wird bei auftretender Exception aufgerufen
   virtual bool onException(cException *exception);


   // Prioritaet
   // ==========

   enum CLASS { pcNoChange, pcIdle, pcRegular, pcCritical, pcServer };
   enum LEVEL { plNoChange, plIdle, plLow, plBelowNormal, plNormal, plAboveNormal, plHigh, plTimeCritical };

   // Liefert die Prioritaetsstufe innerhalb der -Klasse
   LEVEL getPriority();
   // Liefert die Prioritaetsklasse
   CLASS getPriorityClass();
   // Setzt Prioritaetsstufe und Klasse
   bool setPriority(LEVEL lvl, CLASS cls = pcNoChange);


   // Suspendierung
   // =============

   // Aktuellen Thread fuer bestimmte Zeit suspendieren
   static bool sleep(int ms);
   // Thread (gewaltsam) beenden
   bool kill(bool wait = false);


protected:

   // Events
   // ======

   // Wird aufgerufen, um die Methode 'start' zu realisieren
   virtual bool onStart(void *extra, int stacksize);
   // Wird aufgerufen, um die Methode 'kill' zu realisieren
   virtual bool onKill();

   // Wird aufgerufen, um die Thread-Initialisierung zu realisieren
   virtual void onThreadInit();
   // Wird aufgerufen, um die eigentliche Thread-Funktion zu realisieren
   virtual int onThreadRun();
   // Wird aufgerufen, um den Thread zu beenden
   static void onThreadExit(cThread *thread);


private:

   static cThread *main_thread;
   int argc;                     // Anzahl Kommandozeilen-Argumente (Main-Thread)
   char **argv;                  // Zeiger auf Argument-Vektor (Main-Thread)

   int tid;                      // Thread-ID dieses Threads
   STATE state;                  // Aktueller Zustand des Threads
   AUTO_DEL auto_del;            // Automatisches delete bei Thread-Ende?
   int guard_count;              // Zaehlt Anzahl der 'Guard Page Violations'
   int rc;                       // Returncode von onMain

   int stacksize;                // Stackgroesse
   void *init_data;              // Initialisierungsdaten (Parameter von start())

   cEventSem sync_start;         // Wartesemaphore fuer Thread-Start
   cEventSem sync_end;           // Wartesemaphore fuer Thread-Beendigung

   #if defined __ECL_OS2__
      // not needed
   #elif defined __ECL_W32__
      void *hnd;
   #endif

};


#endif

/*.EH.*/
