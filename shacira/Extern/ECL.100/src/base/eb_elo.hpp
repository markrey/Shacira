/*.SH.*/

/*
 *  Headerfile for module eb_elo
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  eb_elo.cpp on Friday January 25 2002  16:30:30
 */

#ifndef __eb_elo__
#define __eb_elo__


// Headerfiles
// ===========================================================================

#include "base/eb_object.hpp"
#include "base/eb_str.hpp"


// Forward-Deklarationen
// ===========================================================================

class cEloElementDescription;
class cEloActionDescription;
class cEloSelection;
class cEloOperation;
class cEloOperationManager;
class cEloDescriptionManager;


// Runtime-Type-Information (light)
// ===========================================================================

// Veraltete Namen (aus Kompatibilitaetsgruenden):
#define ELO_DECLARE(CLASS,BASECLASS) ECL_DECLARE(CLASS,BASECLASS)
#define ELO_CAST(CLASS,PTREXPR)      ECL_CAST(CLASS,PTREXPR)
#define ELO_ISKINDOF(CLASS)          ECL_ISKINDOF(CLASS)


// ===========================================================================
// Definition cEloBase
// ---------------------------------------------------------------------------
//
// Basisklasse fuer Elemente, Operationen und Aktionen sowie fuer
// Beschreibungsobjekte.
//
// Mit getSignature() kann die eindeutige Signatur des ELO-Objektes
// (technisch ein einfacher cString) ermittelt werden. Die Signatur kann
// fuer verschiedene Zwecke eingesetzt werden, zum Beispiel:
//
//  - Bestimmen des Typs eines Elementes, einer Operation oder Aktion
//    UNABHAENGIG von der zur Implementierung verwendeten Klasse
//
//  - Indizieren in ein Online-Hilfesystem
//
// Weitere definierte Eigenschaften sind: (Nicht alle der folgenden Eigen-
// schaften sind bei jedem Objekttyp sinnvoll!)
//
//  - getType(): Ermittelt den primaeren Typ des ELO-Objektes (die in diesem
//    Modul definierten Klassen).
//
//  - getKey(): Ermittelt den eindeutigen (textuellen) Schluesselwert des
//    ELO-Objektes. Dieser kann zum Wiederauffinden des Objektes benutzt
//    werden. Der Schluesselwert kann auch aus mehreren Teilschluesseln
//    zusammengesetzt sein; die einzelnen Teilschluessel sind dann durch
//    Komma voneinander abgetrennt.
//
//  - getName(): Ermittelt einen als Objektnamen benutzbaren, kurzen Text.
//    Bei einem Mitarbeiter-Datensatz koennte das Objektname z.B. aus der
//    Kombination Vorname + Nachname bestehen.
//
//  - getDescr(): Ermittelt einen als Objektbeschreibung benutzbaren,
//    moeglicherweise laengeren Text. Bei einem Mitarbeiter-Datensatz koennte
//    die Objektbeschreibung z.B. aus der Kombination Vorname + Nachname +
//    Wohnort + Strasse + Telefon bestehen.
//
//  - getBitmapId(): Ermittelt die ID oder den Index eines Sinnbildes (Icon
//    oder Bitmap), das den Datensatz beschreibt.
//
// cEclObject
//  +--cEloBase
//
// ===========================================================================

class __ECL_DLLEXPORT__ cEloBase : public cEclObject {
   ECL_DECLARE(cEloBase,cEclObject)

public:

   // Virtueller Destruktor (Wichtig bei Mehrfachvererbung!)
   virtual ~cEloBase();


   // ELO-Signatur
   // ============

   // Eindeutige Signatur des ELO-Objektes erfragen
   cString getSignature() const;


   // ELO-Objekttypen
   // ===============

   enum ELO_TYPE {
      etElement,              // Selektierbares Element
      etOperation,            // Operation
      etAction,               // Aktionsobjekt
      etElementDescription,   // Beschreibung von Elementen
      etActionDescription,    // Beschreibung von Aktionen
      etOperationManager,     // Manager von Operationen
      etActionManager,        // Manager von Aktionen
      etDescriptionManager    // Manager von Beschreibungen
   };

   // Typ des ELO-Objektes erfragen
   ELO_TYPE getType() const;

   // Ist das ELO-Objekt ein selektierbares Element?
   inline bool isElement() const
      { return getType() == etElement; }
   // Ist das ELO-Objekt eine Operation?
   inline bool isOperation() const
      { return getType() == etOperation; }
   // Ist das ELO-Objekt eine Aktion?
   inline bool isAction() const
      { return getType() == etAction; }
   // Ist das ELO-Objekt eine Elementbeschreibung?
   inline bool isElementDescription() const
      { return getType() == etElementDescription; }
   // Ist das ELO-Objekt eine Aktionsbeschreibung?
   inline bool isActionDescription() const
      { return getType() == etActionDescription; }
   // Ist das ELO-Objekt ein Manager von Operationen?
   inline bool isOperationManager() const
      { return getType() == etOperationManager; }
   // Ist das ELO-Objekt ein Manager von Aktionen?
   inline bool isActionManager() const
      { return getType() == etActionManager; }
   // Ist das ELO-Objekt ein Manager von Beschreibungen?
   inline bool isDescriptionManager() const
      { return getType() == etDescriptionManager; }


   // Allgemeine Eigenschaften
   // ========================

   enum BITMAP_STYLE {
      bsDefault,              // Default-Bitmap
      bsActive,               // Bitmap fuer "Objekt aktiv"
      bsLink                  // Bitmap fuer "Objekt ist Link"
   };

   // Eindeutigen (textuellen) Schluessel des ELO-Objektes erfragen
   cString getKey() const;
   // Teilschluessel erfragen (als String)
   cString getKeyPart(int part) const;
   // Teilschluessel erfragen (als int)
   int getKeyPartInt(int part) const;

   // Name des ELO-Objektes erfragen
   cString getName() const;
   // Textuelle Beschreibung des ELO-Objektes erfragen
   cString getDescr() const;
   // ID oder Index des assoziierten Symbols erfragen (-1 = kein Symbol)
   int getBitmapId(BITMAP_STYLE bs = bsDefault) const;


protected:

   // Events
   // ======

   // Wird aufgerufen, um das ELO-Objekt zu initialisieren
   virtual void onInitialize() = 0;

   // Wird aufgerufen, um die eindeutige Signatur des ELO-Objektes zu erfragen
   virtual cString onGetSignature() const = 0;
   // Wird aufgerufen, um den Typ des ELO-Objektes zu erfragen
   virtual ELO_TYPE onGetType() const = 0;

   // Wird aufgerufen, um den eindeutigen (textuellen) Schluessel des ELO-Objektes zu erfragen
   virtual cString onGetKey() const = 0;
   // Wird aufgerufen, um den Namen des ELO-Objektes zu erfragen
   virtual cString onGetName() const = 0;
   // Wird aufgerufen, um die textuelle Beschreibung des ELO-Objektes zu erfragen
   virtual cString onGetDescr() const = 0;
   // Wird aufgerufen, um die ID oder den Index des assoziierten Symbols zu erfragen
   virtual int onGetBitmapId(BITMAP_STYLE bs) const;

};


// ===========================================================================
// Definition cEloElement
// ---------------------------------------------------------------------------
//
// Basisklasse fuer selektierbare Elemente. Elemente sind in der Regel fuer
// den Anwender einer Anwendung identifizierbare Objekte, d.h. er kann sie
// zum Beispiel mit der Maus anklicken. Jedem solchen Element kann eine Menge
// von Operationen zugeordnet werden, die ueber eine Aktion (des Anwenders)
// ausgeloest werden.
//
// cEclObject
//  +--cEloBase
//      +--cEloElement
//
// ===========================================================================

class __ECL_DLLEXPORT__ cEloElement : public cEloBase {
   ECL_DECLARE(cEloElement,cEloBase)

public:

   // Konstruktor ueber Elementbeschreibung (direkt)
   cEloElement(const cEloElementDescription *elem_descr = 0);
   // Konstruktor ueber Elementbeschreibung (indirekt ueber Signatur)
   cEloElement(const cEloDescriptionManager *descr_manager, cString descr_sig);


   // Operationen
   // ===========

   // Unterstuetzt das Element die Operation mit Signatur 'sig_op'?
   bool supportsOperation(cString op_sig, cEloElement *target = 0) const;
   // Zeiger auf Operation mit Signatur 'sig_op' ermitteln
   cEloOperation *getOperation(cString op_sig) const;


   // Elementbeschreibung
   // ===================

   // Aktuelle Elementbeschreibung erfragen
   const cEloElementDescription *getElemDescr() const;


protected:

   // Elementbeschreibung
   // ===================

   // Nachtraegliches Setzen oder Ueberschreiben der Elementbeschreibung (direkt)
   void setElemDescr(const cEloElementDescription *elem_descr);
   // Nachtraegliches Setzen oder Ueberschreiben der Elementbeschreibung (indirekt)
   void setElemDescr(const cEloDescriptionManager *descr_manager, cString descr_sig);


protected:

   // Ueberschriebene Events
   // ======================

   // Wird aufgerufen, um das ELO-Objekt zu initialisieren
   void onInitialize();

   // Wird aufgerufen, um die eindeutige Signatur des ELO-Objektes zu erfragen
   cString onGetSignature() const;
   // Wird aufgerufen, um den Typ des ELO-Objektes zu erfragen
   ELO_TYPE onGetType() const;

   // Wird aufgerufen, um den eindeutigen (textuellen) Schluessel des ELO-Objektes zu erfragen
   cString onGetKey() const;
   // Wird aufgerufen, um den Namen des ELO-Objektes zu erfragen
   cString onGetName() const;
   // Wird aufgerufen, um die textuelle Beschreibung des ELO-Objektes zu erfragen
   cString onGetDescr() const;


private:

   // Assoziierte Elementbeschreibung
   const cEloElementDescription *elem_descr;

};


// ===========================================================================
// Definition cEloAction
// ---------------------------------------------------------------------------
//
// Basisklasse fuer Aktionsobjekte. Aktionen kapseln alle Arten von Eingaben
// durch den Benutzer: Menues und Toolbars sowie Tastatur- und Mauseingaben.
// Jede moegliche Aktion wird mit einem cEloActionDescription-Objekt be-
// schrieben, welches auch die Verbindung zu den Operationen herstellt.
//
// Wenn der Benutzer eine Aktion initiiert (z.B. durch Aufklappen eines Menus
// oder Anzeigen eines Toolbars), werden die fuer die aktuelle Selektion
// gueltigen Operationen anhand deren Signaturen ermittelt und dem Benutzer
// zur Auswahl angeboten.
//
// cEclObject
//  +--cEloBase
//      +--cEloAction
//
// ===========================================================================

class __ECL_DLLEXPORT__ cEloAction : public cEloBase {
   ECL_DECLARE(cEloAction,cEloBase)

public:

   // Konstruktor ueber Aktionsbeschreibung (direkt)
   cEloAction(const cEloActionDescription *action_descr);
   // Konstruktor ueber Aktionsbeschreibung (indirekt ueber Signatur)
   cEloAction(const cEloDescriptionManager *descr_manager, cString descr_sig);

   // Ist das Objekt mit ID 'id' ein cEloOperation-Objekt?
   bool isOperation(int id) const;
   // Ist die Operation mit ID 'id' enabled?
   bool isOperationEnabled(int id, cEloSelection *selection = 0, int sub_op = -1) const;
   // Assoziierte Operation mit ID 'id' ermitteln (0 bei Fehler)
   cEloOperation *getOperation(int id) const;

   // Zugeordnete Aktionsbeschreibung ermitteln
   inline const cEloActionDescription *getActionDescription() const
      { return action_descr; }

   // Anzeigen der Aenderung der Selektion
   void reflectSelectionChange(cEloSelection *selection);


protected:

   // Hinzugefuegte Events
   // ====================

   // Wird aufgerufen, wenn sich die aktuelle Selektion geaendert hat
   virtual void onSelectionChanged(cEloSelection *selection) = 0;


   // Ueberschriebene Events
   // ======================

   // Wird aufgerufen, um den Typ des ELO-Objektes zu erfragen
   ELO_TYPE onGetType() const
      { return etAction; }
   // Wird aufgerufen, um den eindeutigen (textuellen) Schluessel des ELO-Objektes zu erfragen
   cString onGetKey() const
      { return cString(); }
   // Wird aufgerufen, um den Namen des ELO-Objektes zu erfragen
   cString onGetName() const
      { return cString(); }
   // Wird aufgerufen, um die textuelle Beschreibung des ELO-Objektes zu erfragen
   cString onGetDescr() const
      { return cString(); }
   // Wird aufgerufen, um die eindeutige Signatur des ELO-Objektes zu erfragen
   cString onGetSignature() const
      { return __getClassName(); }


private:

   // Assoziierte Aktionsbeschreibung
   const cEloActionDescription *action_descr;

};


// ===========================================================================
// Definition cEloActionStatic
// ---------------------------------------------------------------------------
//
// Statische Aktionen sind in der Regel sichtbaren Bildschirmelementen
// zugeordnet (z.B. Frame-Menues oder Toolbars), die - ganz oder teilweise -
// fuer eine laengere Zeit sichtbar sind. Statische Aktionen werden normaler-
// weise von cEloActionManager-Objekten erzeugt und verwaltet.
//
// cEclObject
//  +--cEloBase
//      +--cEloAction
//          +--cEloActionStatic
//
// ===========================================================================

class __ECL_DLLEXPORT__ cEloActionStatic : public cEloAction {
   ECL_DECLARE(cEloActionStatic,cEloAction)

public:

   // Konstruktor ueber Aktionsbeschreibung (direkt)
   cEloActionStatic(const cEloActionDescription *action_descr);
   // Konstruktor ueber Aktionsbeschreibung (indirekt ueber Signatur)
   cEloActionStatic(const cEloDescriptionManager *descr_manager, cString descr_sig);

};


// ===========================================================================
// Definition cEloActionDynamic
// ---------------------------------------------------------------------------
//
// Dynamische Aktionen sind entweder keinen sichtbaren Bildschirmelementen
// zugeordnet oder diese sind nur fuer die Dauer einer Benutzerinteraktion
// sichtbar (z.B. Kontextmenues). Das dynamische Aktionsobjekt wird erzeugt,
// mit dem Bildschirmelement verknuepft und geloescht, wenn die Operation
// ausgewaehlt wurde.
//
// cEclObject
//  +--cEloBase
//      +--cEloAction
//          +--cEloActionDynamic
//
// ===========================================================================

class __ECL_DLLEXPORT__ cEloActionDynamic : public cEloAction {
   ECL_DECLARE(cEloActionDynamic,cEloAction)

public:

   // Konstruktor ueber Aktionsbeschreibung (direkt)
   cEloActionDynamic(const cEloActionDescription *action_descr);
   // Konstruktor ueber Aktionsbeschreibung (indirekt ueber Signatur)
   cEloActionDynamic(const cEloDescriptionManager *descr_manager, cString descr_sig);

};


// ===========================================================================
// Definition cEloOperation
// ---------------------------------------------------------------------------
//
// Basisklasse fuer Operationen, die auf Elementen arbeiten. Wenn ein Element
// selektiert wird, werden die diesem Element zugeordneten Operationen
// aktiviert (d.h. sichtbar oder aktiv in einem Menu oder einem Toolbar).
// Werden mehrere Elemente selektiert, wird die Menge der aktiven Operationen
// auf die von allen selektierten Elementen unterstuetzte Operationsmenge
// beschraenkt.
//
// Operationen werden von Operationsmanagern (cEloOperationManager) erzeugt
// und verwaltet, die als zentrale Instanzen innerhalb eines logischen
// (Sub-)systems fuer eine zusammengehoerende Menge von Operationen
// zustaendig sind.
//
// Eine Operation besteht aus n Teil-Operationen, die dynamisch erzeugt
// werden koennen (typischerweise ist n = 1). Beispiele:
//
//    n = 1                        | n >= 0
//   ------------------------------+------------------------------
//    File->Open                   | File->(RecentFileList)
//    Edit->Copy                   | Create->(CurrentTypeList)
//    Window->Cascade              | Window->(CurrentWindowList)
//
// Bei allen Funktionen, die ein 'sub_operation'-Parameter erhalten, gilt:
//
//  - Wenn sub_operation < 0, ist der Haupteintrag gemeint
//  - Wenn sub_operation >= 0, ist der spezifizierte Untereintrag gemeint
//
// Flags zur Steuerung der Operation:
//
//  - isStatic()
//    Ist dieses Flag gesetzt, wird die Operation unabhaengig von der
//    aktuellen Auswahl angeboten. Statische Operation werden ueber eine
//    spezielle exec-Methode ausgefuehrt.
//
//  - isVisible()
//    Dieses Flag steuert die Sichtbarkeit der Operation: Unsichtbare Opera-
//    tionen werden in keinem Menu oder Toolbar angezeigt, koennen aber
//    dennoch (intern) verwendet werden. Sichtbare Operationen werden auf die
//    folgende Art angezeigt:
//
//     * Frame Menus: Die Operation wird stets angezeigt. Kann sie aufgrund
//       der aktuellen Selektionsmenge nicht ausgefuehrt werden, wird sie
//       "grau" dargestellt.
//
//     * Context Menus: Die Operation wird nur angezeigt, wenn sie aufgrund
//       der aktuellen Selektionsmenge auch ausgefuehrt werden kann.
//
//  - isEnabled()
//    Ueber dieses Flag kann festgelegt werden, ob die Operation aktuell zu-
//    gaengig (enabled) ist oder nicht (disabled). Nicht zugaengige Opera-
//    tionen werden (abhaengig von isVisible) zwar angezeigt, koennen aber
//    nicht ausgewaehlt werden (sind in Menues z.B. "ausgegraut").
//
//  - isChecked()
//    Ueber das isChecked()-Flag kann festgelegt werden, ob die Operation
//    aktuell ein Checkmark anzeigt oder nicht. In Menues wird der "Checked"-
//    Zustand z.B. ueber einen speziellen "Haken" angezeigt.
//
//  - isCheckable()
//    Ob eine Operation prinzipiell "Checkable" ist, wird ueber dieses Flag
//    gesteuert. Sollte es geliefert werden, ist das Flag unabhaengig von der
//    aktuellen Selektion fuer die Operation gueltig.
//
// Zum Ausfuehren von der Operation wird die virtuelle Methode onExecOperation
// aufgerufen. Die ableitende Klasse muss die Operation fuer alle Elemente der
// Selektion ausfuehren. Alternativ kann onExecOperation auch fuer einzelne
// Elemente benutzt werden (zweite Variante).
//
// cEclObject
//  +--cEloBase
//      +--cEloElement
//
// ===========================================================================

class __ECL_DLLEXPORT__ cEloOperation : public cEloBase {
   ECL_DECLARE(cEloOperation,cEloBase)

public:

   // Konstruktor
   cEloOperation();


   // Allgemeines
   // ===========

   // Erlaubt die Operation Teil-Operationen? (Default: false)
   bool hasSubOperations(const cEloSelection *selection = 0) const;
   // Aktuelle Anzahl Teil-Operationen erfragen (Default: 1)
   int getSubOperationCount(const cEloSelection *selection = 0) const;
   // Unterstuetzt die Operation ein spezifisches 'target' auf 'selected_elem'?
   bool supportsTarget(const cEloElement *selected_elem, cEloElement *target) const;

   // Statische Operation ausfuehren
   void execOperation(cEloElement *target = 0);
   // (Teil-)Operation auf eine Elementmenge anwenden
   void execOperation(cEloSelection *selection, int sub_operation = -1, cEloElement *target = 0);


   // Attribute
   // =========

   // Default Objekt-ID der Operation ermitteln
   int getDefaultObjectId() const;
   // Text fuer Menueeintraege (Shortcut-Praefix "&")
   cString getMenuText(const cEloSelection *selection = 0, int sub_operation = -1) const;
   // Hilfetext fuer Statuszeile oder Bubble-Help
   cString getHelpText(const cEloSelection *selection = 0, int sub_operation = -1) const;
   // Index in Online-Hilfesystem (-1 = Keine Hilfe)
   int getHelpId(const cEloSelection *selection = 0, int sub_operation = -1) const;


   // Steuerflags
   // ===========

   // Ist die Operation statisch?
   bool isStatic() const;
   // Wird die (Teil-)Operation angezeigt?
   bool isVisible(const cEloSelection *sel = 0, int sub_op = -1, cEloElement *target = 0) const;
   // Ist die (Teil-)Operation "enabled" (zugaengig fuer Benutzer)?
   bool isEnabled(const cEloSelection *sel = 0, int sub_op = -1, cEloElement *target = 0) const;
   // Ist die (Teil-)Operation "checked" (speziell markiert)?
   bool isChecked(const cEloSelection *sel = 0, int sub_op = -1, cEloElement *target = 0) const;
   // Erlaubt die (Teil-)Operation spezielle Markierungen?
   bool isCheckable(const cEloSelection *sel = 0, int sub_op = -1, cEloElement *target = 0) const;


protected:

   // Hinzugefuegte Events
   // ====================

   // Wird aufgerufen, um eine statische Operation auszufuehren
   virtual void onExecOperation(cEloElement *target);
   // Wird aufgerufen, um die Operation auf alle Elemente der Selektion auszufuehren
   virtual void onExecOperation(cEloSelection *selection, int sub_operation, cEloElement *target);
   // Wird aufgerufen, um die Operation auf ein einzelnes Element auszufuehren
   virtual void onExecOperation(cEloElement *elem, int sub_operation, cEloElement *target);

   // Wird aufgerufen, um zu bestimmen, ob die Operationen Teil-Operationen erlaubt
   virtual bool onGetSubOperations(const cEloSelection *selection) const;
   // Wird aufgerufen, um die aktuelle Anzahl Teil-Operationen zu erfragen
   virtual int onGetSubOperationCount(const cEloSelection *selection) const;
   // Wird aufgerufen, um zu pruefen, ob die Operation ein spezifisches Target Unterstuetzt
   virtual bool onSupportsTarget(const cEloElement *selected_elem, cEloElement *target) const;

   // Wird aufgerufen, um die default Objekt-ID der Operation ermitteln
   virtual int onGetDefaultObjectId() const;
   // Wird aufgerufen, um den Text fuer Menueeintraege zu erfragen
   virtual cString onGetMenuText(const cEloSelection *selection, int sub_operation) const = 0;
   // Wird aufgerufen, um den Hilfetext fuer die Statuszeile zu erfragen
   virtual cString onGetHelpText(const cEloSelection *selection, int sub_operation) const = 0;
   // Wird aufgerufen, um den Index in das Online-Hilfesystem zu erfragen
   virtual int onGetHelpId(const cEloSelection *selection, int sub_operation) const;

   // Wird aufgerufen, um zu pruefen, ob die Operation statisch ist
   virtual bool onGetStaticFlag() const;
   // Wird aufgerufen, um zu pruefen, ob die (Teil-)Operation angezeigt wird
   virtual bool onGetVisibleFlag(const cEloSelection *sel, int sub_op, cEloElement *target) const;
   // Wird aufgerufen, um zu pruefen, ob die (Teil-)Operation "enabled" (zugaengig fuer Benutzer) ist
   virtual bool onGetEnabledFlag(const cEloSelection *sel, int sub_op, cEloElement *target) const;
   // Wird aufgerufen, um zu pruefen, ob die (Teil-)Operation "checked" (speziell markiert) ist
   virtual bool onGetCheckedFlag(const cEloSelection *sel, int sub_op, cEloElement *target) const;
   // Wird aufgerufen, um zu pruefen ob die (Teil-)Operation spezielle Markierungen erlaubt
   virtual bool onGetCheckableFlag(const cEloSelection *sel, int sub_op, cEloElement *target) const;


   // Ueberschriebene Events
   // ======================

   // Wird aufgerufen, um das ELO-Objekt zu initialisieren
   void onInitialize();

   // Wird aufgerufen, um den Typ des ELO-Objektes zu erfragen
   ELO_TYPE onGetType() const;
   // Wird aufgerufen, um den eindeutigen (textuellen) Schluessel des ELO-Objektes zu erfragen
   cString onGetKey() const;
   // Wird aufgerufen, um den Namen des ELO-Objektes zu erfragen
   cString onGetName() const;
   // Wird aufgerufen, um die textuelle Beschreibung des ELO-Objektes zu erfragen
   cString onGetDescr() const;


protected:

   // Operation bereits initialisiert?
   bool was_initialized;


public:

   // ALTER BEZEICHNER! NICHT MEHR VERWENDEN! (Flags der Operation erfragen)
   int getFlags(const cEloSelection *selection = 0, int sub_operation = 0) const;

protected:

   enum FLAGS {                     // ALTE BEZEICHNER! NICHT MEHR VERWENDEN!
      ofStatic       = 0x00000001,  // Operation statisch (stets verfuegbar)?
      ofVisible      = 0x00000002,  // Operation angezeigt (sichtbar im Menue)?
      ofEnabled      = 0x00000004,  // Operation "enabled" (zugaengig fuer Benutzer)?
      ofChecked      = 0x00000008,  // Operation "checked" (speziell markiert)?
      ofCheckable    = 0x00000100,  // Spezielle Markierung ("Checkmark") moeglich?
      ofUser         = 0x00010000
   };

   // ALTER BEZEICHNER! NICHT MEHR VERWENDEN! Wird aufgerufen, um die Flags der Operation zu erfragen
   virtual int onGetFlags(const cEloSelection *selection, int sub_operation) const;

};


// ===========================================================================
// Definition cEloDescription
// ---------------------------------------------------------------------------
//
// Basisklasse fuer Beschreibungsobjekte von Elementen und Aktionen.
//
// cEclObject
//  +--cEloBase
//      +--cEloDescription
//
// ===========================================================================

class __ECL_DLLEXPORT__ cEloDescription : public cEloBase {
   ECL_DECLARE(cEloDescription,cEloBase)

public:

   // Konstruktor
   cEloDescription();
   // Destruktor
   ~cEloDescription();


protected:

   // Assoziierte Beschreibungen
   // ==========================

   // Anzahl assoziierter Beschreibungen ermitteln
   int getDescriptionCount() const;
   // Assoziierte Beschreibung mit Index 'index' ermitteln
   cEloDescription *getDescription(int index) const;
   // Assoziierte Beschreibung hinzufuegen
   void addDescription(cEloDescription *descr);
   // Assoziierte Beschreibung entfernen
   void removeDescription(cEloDescription *descr);


   // Ueberschriebene Events
   // ======================

   // Wird aufgerufen, um den eindeutigen (textuellen) Schluessel des ELO-Objektes zu erfragen
   cString onGetKey() const
      { return getSignature(); }
   // Wird aufgerufen, um den Namen des ELO-Objektes zu erfragen
   cString onGetName() const
      { return getKey(); }
   // Wird aufgerufen, um die textuelle Beschreibung des ELO-Objektes zu erfragen
   cString onGetDescr() const
      { return getName(); }
   // Wird aufgerufen, um die eindeutige Signatur des ELO-Objektes zu erfragen
   cString onGetSignature() const
      { return __getClassName(); }


private:

   // Zeiger auf die geordnete Liste assoziierter Beschreibungen (oder 0)
   struct ASSOCIATED_DESCRIPTIONS;
   ASSOCIATED_DESCRIPTIONS *descriptions;

};


// ===========================================================================
// Definition cEloElementDescription
// ---------------------------------------------------------------------------
//
// Basisklasse fuer Beschreibungsobjekte von Elementen, Operationen und
// Aktionen.
//
// cEclObject
//  +--cEloBase
//      +--cEloDescription
//          +--cEloElementDescription
//
// ===========================================================================

class __ECL_DLLEXPORT__ cEloElementDescription : public cEloDescription {
   ECL_DECLARE(cEloElementDescription,cEloDescription)

public:

   // Konstruktor
   cEloElementDescription();
   // Destruktor
   ~cEloElementDescription();


   // Registrierte Operationen
   // ========================

   // Unterstuetzt das Element die Operation mit Signatur 'sig_op'?
   bool supportsOperation(cString op_sig) const;
   // Zeiger auf Operation mit Signatur 'sig_op' ermitteln
   cEloOperation *getOperation(cString op_sig) const;


protected:

   // Deklaration der Verwandschaft: this erbt alles von 'elem_descr'
   void inheritFrom(cEloElementDescription *elem_descr);
   // Registrieren einer Operation
   void registerOperation(cEloOperation *op);
   // Registrieren einer Operation ueber Operation-Manager
   void registerOperation(cEloOperationManager *op_manager, cString op_sig);


   // Ueberschriebene Events
   // ======================

   // Wird aufgerufen, um den Typ des ELO-Objektes zu erfragen
   ELO_TYPE onGetType() const
      { return etElementDescription; }


private:

   // Zeiger auf die assoziative Liste registrierter Operationen (oder 0)
   struct REGISTERED_OPERATIONS;
   REGISTERED_OPERATIONS *operations;

};


// ===========================================================================
// Definition cEloActionDescription
// ---------------------------------------------------------------------------
//
// ...
//
// Jedem zur Aktionsbeschreibung assozierten Objekt kann eine benutzer-
// spezifische Kennung gegeben werden, z.B. die Resource-ID im Menusystem.
//
// cEclObject
//  +--cEloBase
//      +--cEloDescription
//          +--cEloActionDescription
//
// ===========================================================================

class __ECL_DLLEXPORT__ cEloActionDescription : public cEloDescription {
   ECL_DECLARE(cEloActionDescription,cEloDescription)

public:

   // Konstruktor
   cEloActionDescription();
   // Destruktor
   ~cEloActionDescription();


   // Assoziierte Objekte
   // ===================

   // Anzahl assoziierter Objekte ermitteln
   int getObjectCount() const;
   // User-ID des Objektes an Position 'index' ermitteln
   int getObjectID(int index) const;

   // Ist das Objekt an Position (oder mit ID) 'index_or_id' ein cEloOperation-Objekt?
   bool isOperation(int index_or_id, bool by_id = false) const;
   // Ist das Objekt an Position (oder mit ID) 'index_or_id' ein cEloActionDescription-Objekt?
   bool isSubDescription(int index_or_id, bool by_id = false) const;
   // Soll das Objekt an Position (oder mit ID) 'index_or_id' als Defaultobjekt markiert werden?
   bool isDefault(int index_or_id, bool by_id = false) const;
   // Soll dem Objekt an Position (oder mit ID) 'index_or_id' eine Trennlinie vorangestellt werden?
   bool hasBreakBefore(int index_or_id, bool by_id = false) const;
   // Soll dem Objekt an Position (oder mit ID) 'index_or_id' eine Trennlinie folgen?
   bool hasBreakAfter(int index_or_id, bool by_id = false) const;

   // Assoziierte Operation mit Index (oder ID) 'index_or_id' ermitteln
   // (Liefert 0, falls bei 'index' kein cEloOperation-Objekt!)
   cEloOperation *getOperation(int index_or_id, bool by_id = false) const;
   // Sub-ID der Operation mit Index (oder ID) 'index_or_id' ermitteln
   // (Liefert -1, falls bei 'index' kein cEloOperation-Objekt!)
   int getOperationSubId(int index_or_id, bool by_id = false) const;
   // Untergeordnete Beschreibung mit Index (oder ID) 'index_or_id' ermitteln
   // (Liefert 0, falls bei 'index' kein cEloActionDescription-Objekte!)
   cEloActionDescription *getSubDescription(int index_or_id, bool by_id = false) const;


protected:

   // Stile assoziierter Objekte
   // ==========================

   enum OBJECT_STYLES {
      osBreakBefore     = 1 << 0,      // Trennlinie VOR dem Objekt (wenn moeglich)
      osBreakAfter      = 1 << 1,      // Trennlinie NACH dem Objekt (wenn moeglich)
      osDefault         = 1 << 2       // Der Wert wird als Defaultwert gekennzeichnet
   };


   // Assoziierte Objekte
   // ===================

   // Deklaration der Verwandschaft: this erbt alles von 'action_descr'
   void inheritFrom(cEloActionDescription *action_descr);
   // Assoziiertes Objekt hinzufuegen, Einfuegen vor 'insert_before'
   void addObject(cEloBase *obj, int obj_id = -1, int obj_id_count = 1, cEloBase *insert_before = 0, int obj_style = 0);
   // Assoziiertes Objekt von 'index' einfuegen
   void addObjectBefore(cEloBase *obj, int obj_id = -1, int obj_id_count = 1, int index = 0, int obj_style = 0);
   // Assoziiertes Objekt entfernen
   void removeObject(cEloBase *obj);
   // Assoziiertes Objekt ueber dessen User-ID entfernen
   void removeObject(int obj_id);


   // Ueberschriebene Events
   // ======================

   // Wird aufgerufen, um den Typ des ELO-Objektes zu erfragen
   ELO_TYPE onGetType() const
      { return etActionDescription; }


private:

   // Zeiger auf die geordnete Liste assoziierter Operationen (oder 0)
   struct ASSOCIATED_OBJECTS;
   ASSOCIATED_OBJECTS *objects;

   // Intern: Objekt suchen (auch durch alle 'ererbten' Beschreibungen)
   cEloBase *findObject(int index_or_id, bool by_id) const;
   // Intern: Objekt ueber ID suchen (auch durch alle 'ererbten' Beschreibungen)
   cEloBase *findObjectById(int id) const;
   // Intern: Objekt ueber Index suchen (auch durch alle 'ererbten' Beschreibungen)
   cEloBase *findObjectByIndex(int index) const;

   // Intern: Objektstil suchen (auch durch alle 'ererbten' Beschreibungen)
   int findObjectStyle(int index_or_id, bool by_id) const;
   // Intern: Objektstil ueber ID suchen (auch durch alle 'ererbten' Beschreibungen)
   int findObjectStyleById(int id) const;
   // Intern: Objektstil ueber Index suchen (auch durch alle 'ererbten' Beschreibungen)
   int findObjectStyleByIndex(int index) const;

};


// ===========================================================================
// Definition cEloManager
// ---------------------------------------------------------------------------
//
// Basisklasse fuer Manager-Objekte, die einen logisch zusammengehoerenden
// Satz von identischen ELO-Objekten Operationen verwalten. Eine Manager-
// Instanz erzeugt waehrend onInitialize(), eine Menge von ELO-Objekten
// (via new) und fuegt sie mit addObject() zum Manager hinzu. Die Basisklasse
// sorgt spaeter fuer die korrekte Freigabe der ELO-Objekte.
//
// || ACHTUNG! OBACHT!
// ||
// || ECL/win benutzt einen anderen Heap als ECL/base. Deshalb duerfen
// || Operationen, die aus ECL/win stammen, NICHT (N-I-C-H-T) auf dem
// || Heap angelegt werden, sofern die Gefahr besteht, dass sie von der
// || ELO-Manager-Klasse via 'delete' wieder freigegeben werden. Statt dessen
// || muss aus ECL/win das 'destroy_objects'-Flag UNBEDINGT auf false gesetzt
// || werden! (Fuer eine ECL-Anwendung besteht diese Einschraenkung nicht!)
//
// cEclObject
//  +--cEloBase
//      +--cEloManager
//
// ===========================================================================

class __ECL_DLLEXPORT__ cEloManager : public cEloBase {
   ECL_DECLARE(cEloManager,cEloBase)

public:

   // Loescht der Manager seine verwalteten Objekte mit 'delete'?
   inline bool isDestroyingObjects() const
      { return destroy_objects; }


protected:

   // Konstruktor
   cEloManager(bool destroy_objects);
   // Destruktor
   ~cEloManager();

   // Objekt ueber Signatur ermitteln
   cEloBase *getObject(cString sig) const;
   // Objekt hinzufuegen
   void addObject(cEloBase *obj);


   // Ueberschriebene Events
   // ======================

   // Wird aufgerufen, um den eindeutigen (textuellen) Schluessel des ELO-Objektes zu erfragen
   cString onGetKey() const
      { return getSignature(); }
   // Wird aufgerufen, um den Namen des ELO-Objektes zu erfragen
   cString onGetName() const
      { return cString(); }
   // Wird aufgerufen, um die textuelle Beschreibung des ELO-Objektes zu erfragen
   cString onGetDescr() const
      { return cString(); }
   // Wird aufgerufen, um die eindeutige Signatur des ELO-Objektes zu erfragen
   cString onGetSignature() const
      { return __getClassName(); }

   // Zeiger auf Liste verwalteter Objekte (oder 0)
   struct MANAGED_OBJECTS;
   MANAGED_OBJECTS *objects;


private:

   // Verwaltete Objekte automatisch loeschen?
   bool destroy_objects;

};


// ===========================================================================
// Definition cEloOperationManager
// ---------------------------------------------------------------------------
//
// Basisklasse fuer Manager-Objekte, die einen logisch zusammengehoerenden
// Satz von Operationen verwalten. Eine Manager-Instanz erzeugt waehrend
// onInitialize() in ihrem Konstruktor, eine Menge von Operationen (via new)
// und fuegt sie mit addOperation() zum Manager hinzu. Die Basisklasse sorgt
// spaeter fuer die korrekte Freigabe der Operations-Objekte.
//
// cEclObject
//  +--cEloBase
//      +--cEloManager
//          +--cEloOperationManager
//
// ===========================================================================

class __ECL_DLLEXPORT__ cEloOperationManager : public cEloManager {
   ECL_DECLARE(cEloOperationManager,cEloManager)

public:

   // Konstruktor
   inline cEloOperationManager(bool destroy_objects = true) :
      cEloManager(destroy_objects) { }

   // Operation ueber Signatur ermitteln
   cEloOperation *getOperation(cString op_sig) const;


protected:

   // Operation hinzufuegen
   void addOperation(cEloOperation *op);


   // Ueberschriebene Events
   // ======================

   // Wird aufgerufen, um den Typ des ELO-Objektes zu erfragen
   ELO_TYPE onGetType() const
      { return etOperationManager; }

};


// ===========================================================================
// Definition cEloActionManager
// ---------------------------------------------------------------------------
//
// Basisklasse fuer Manager-Objekte, die einen logisch zusammengehoerenden
// Satz von (statischen) Aktionen verwalten. Eine Manager-Instanz erzeugt
// waehrend onInitialize() eine Menge von Operationen (via new) und fuegt
// sie mit addOperation() zum Manager hinzu. Die Basisklasse sorgt spaeter
// fuer die korrekte Freigabe der Operations-Objekte.
//
// cEclObject
//  +--cEloBase
//      +--cEloManager
//          +--cEloActionManager
//
// ===========================================================================

class __ECL_DLLEXPORT__ cEloActionManager : public cEloManager {
   ECL_DECLARE(cEloActionManager,cEloManager)

public:

   // Konstruktor
   inline cEloActionManager(bool destroy_objects = true) :
      cEloManager(destroy_objects) { }

   // Anzeigen der Aenderung der Selektion
   void reflectSelectionChange(cEloSelection *selection);
   // Aktion ueber Signatur ermitteln
   cEloActionStatic *getAction(cString action_sig) const;


protected:

   // Aktion hinzufuegen
   void addAction(cEloActionStatic *action);


   // Ueberschriebene Events
   // ======================

   // Wird aufgerufen, um den Typ des ELO-Objektes zu erfragen
   ELO_TYPE onGetType() const
      { return etActionManager; }

};


// ===========================================================================
// Definition cEloDescriptionManager
// ---------------------------------------------------------------------------
//
// Basisklasse fuer Manager-Objekte, die einen logisch zusammengehoerenden
// Satz von Beschreibungsobjekten verwalten. Eine Manager-Instanz erzeugt
// waehrend onInitialize() eine Menge von Beschreibungsobjekten (via new)
// und fuegt sie mit addDescription() zum Manager hinzu. Die Basisklasse
// sorgt spaeter fuer die korrekte Freigabe der Beschreibungsobjekte.
//
// cEclObject
//  +--cEloBase
//      +--cEloManager
//          +--cEloDescriptionManager
//
// ===========================================================================

class __ECL_DLLEXPORT__ cEloDescriptionManager : public cEloManager {
   ECL_DECLARE(cEloDescriptionManager,cEloManager)

public:

   // Konstruktor
   inline cEloDescriptionManager(bool destroy_objects = true) :
      cEloManager(destroy_objects) { }

   // Beschreibungsobjekt ueber Signatur ermitteln
   cEloDescription *getDescription(cString descr_sig) const;


protected:

   // Beschreibungsobjekt hinzufuegen
   void addDescription(cEloDescription *descr);


   // Ueberschriebene Events
   // ======================

   // Wird aufgerufen, um den Typ des ELO-Objektes zu erfragen
   ELO_TYPE onGetType() const
      { return etDescriptionManager; }

};


// ===========================================================================
// Definition cEloSelection
// ---------------------------------------------------------------------------
//
// cEclObject
//  +--cEloSelection
//
// ===========================================================================

class __ECL_DLLEXPORT__ cEloSelection : public cEclObject {
   ECL_DECLARE(cEloSelection,cEclObject)

public:

   // Konstruktor
   cEloSelection();
   // Copy-Konstruktor
   cEloSelection(const cEloSelection& other);
   // Destruktor
   ~cEloSelection();

   // Zuweisungsoperator
   cEloSelection& operator=(const cEloSelection& other);


   // Selektion
   // =========

   // Selektion loeschen
   void clearSelection();
   // Element zur Selektion hinzufuegen
   void addElement(cEloElement *elem, int from = -1, int to = -1);
   // Element aus der Selektion entfernen
   void removeElement(cEloElement *elem, int from = -1, int to = -1);

   // Anzahl selektierter Elemente erfragen
   int getElementCount() const;
   // Zugriff auf ein Element der Selektion
   cEloElement *getElement(int index) const;
   // Ist zum Element 'index' ein (Unter-)Bereich definiert?
   bool hasElementRange(int index) const;
   // Unterbereich von Element 'index' erfragen
   void getElementRange(int index, int& from, int& to) const;

   // Ist 'elem' (ggf. mit Unterbereich) in der Selektion enthalten?
   bool isSelected(const cEloElement *elem, int fromto = -1) const;
   bool isSelected(const cEloElement *elem, int from, int to) const;


   // Operationen
   // ===========

   // Unterstuetzten ALLE Elemente der Elementmenge die Operation mit Signatur 'sig_op'?
   bool supportsOperation(cString op_sig, cEloElement *target = 0) const;
   // Operation 'op_sig' auf die aktuelle Elementmenge anwenden
   void execOperation(cString op_sig, int sub_operation = 0, cEloElement *target = 0);


private:

   // Zeiger auf Liste selektierter Elemente (oder 0)
   struct SELECTED_ELEMENTS;
   SELECTED_ELEMENTS *elements;

   // Aktuelle Anzahl Element in der Selektion
   int elem_count;

};


#endif

/*.EH.*/
