/*.SH.*/

/*
 *  Headerfile for module eb_cmdarg
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  eb_cmdarg.cpp on Thursday February 15 2001  18:32:22
 */

#ifndef __eb_cmdarg__
#define __eb_cmdarg__


#include "base/eb_err.hpp"

// ===========================================================================
// Deklaration cErrCmdArg
// ---------------------------------------------------------------------------
//
// cBase
//  +--cErrBase
//      +--cErrCmdArg
//
// ===========================================================================

class __ECL_DLLEXPORT__ cErrCmdArg : public cErrBase {

public:
   cErrCmdArg(int err, const char *str = NULL, int line=-1);

   enum ERR_CODE { errBase = ERR_PREFIX('C','M','D'),
      errMissingFile    = errBase + errWarn ,
      errIllState       = errBase + errFatal,
      errFileNestingOV
   };
};


#include "base/eb_str.hpp"
#include "base/eb_file.hpp"

// ===========================================================================
// Deklaration cCmdArg
// ---------------------------------------------------------------------------
//
// cBase
//   +--cCmdArg
//
// ===========================================================================

class __ECL_DLLEXPORT__ cCmdArg : public cBase {
#if defined __ECL_ICC__
   public:  // Der ICC braucht das irgendwie... :-(
#endif
   // lokale Typen
   enum STATES {
      AS_INIT,
      AS_RESET,
      AS_ENVVAR,
      AS_CMDLINE,
      AS_NEWFILE,
      AS_OPTFILE,
      AS_FINISHED
   };
private:
   struct __ECL_DLLEXPORT__ OPTFILE_STACK {
      STATES state;
      cFile *file_hnd;
      cString workstr;
      cString module;
      short line;
   };

   // lokale Variablen
   STATES ArgState;              /* Aktueller Zustand des Moduls */
   STATES LastState;             /* Zuletzt eingenommener Zustand */
   cString ArgPath;
   cString ArgModule;
   cString ActModuleName;
   short LineNo;
   cString WorkString;           /* Arbeitsbereich, enth. aktuelle Zeile */
   const char * WorkPtr;         /* Zeiger in WorkString */
   const char * LastWorkPtr;     /* Letzter Wert des Zeigers in WorkString */

   cString CmdlineString;        /* uebergebene Kommandozeile */
   cString ActualField;          /* Arbeitsbereich, enth. aktuellen Parameter */
   //cString ExtraString;  //## raus?

   int  ArgC;                    // uebergebener Parametervektor
   char **ArgV;

   short OptfileStackInd;
   OPTFILE_STACK OptfileStack[ 3 ];    // Stackgroesse kann HIER geaendert werden !!!
                                       // (frueher die Konstante OPTFILE_STACK_MAX)

   cString default_extension;    // Default-Dateierweiterung
   cString envvar_prefix;        // Praefix fuer Umgebungsvariable

private:
   // Multifunktionskonstruktor
   void cCmdArg_ALL(int argc, char *argv[], char *cmdline,
                    char *module, char *def_ext, char *env_pre);

public:
   cCmdArg( int argc, char *argv[],
            char *module=NULL, char *def_ext=NULL, char *env_pre=NULL )
      { cCmdArg_ALL( argc, argv, NULL, module, def_ext, env_pre ); }
   cCmdArg( char *cmdline,
            char *module=NULL, char *def_ext=NULL, char *env_pre=NULL )
      { cCmdArg_ALL( 0, NULL, cmdline, module, def_ext, env_pre ); }
   virtual ~cCmdArg();

   // Ermitteln des naechsten Argumentes
   const char *getNext();
   // Zuletzt ermitteltes Argument nochmals lesen
   const char *getAgain() { return ActualField; }

   // Ermittelt den aktuellen Modulnamen
   const char *getModule() { return ArgModule; }
   // Pfad aus dem das Modul gestartet wurde
   const char *getPath() { return ArgPath; }

private:
   void NextField(void);
   void RestoreField(void);
   void StateReset(void);
   void StateEnvvar(void);
   void StateCmdline(void);
   void StateNewfile(void);
   void StateOptfile(void);

};


class __ECL_DLLEXPORT__ cCmdOptions : public cCmdArg {
public:
   // Definition eines Optionstokens
   typedef struct {
      int key;                // Kennung der Option
      unsigned short minlen;  // signifikante Mindestlaenge, 0=Kommentar
      char *token;            // Token, NULL=Tabellenende
   } OPTION;
   // key wenn die Option nicht in der Liste gefunden wurde
   enum {
      keyNoOption,   // '/' & '-' fehlen, value -> erstes Zeichen
      keyNotFound    // unbekannte Option, value -> HINTER '/' bzw. '-'
   };

private:
   const OPTION *option_list; // Optionstabelle

public:
   // Konstruktoren wie bei cCmdArg (Argumentvektor oder Kommandozeile)
   cCmdOptions( int argc, char *argv[],
                char *module=NULL, char *def_ext=NULL, char *env_pre=NULL );
   cCmdOptions( char *cmdline,
                char *module=NULL, char *def_ext=NULL, char *env_pre=NULL );
   //virtual ~cCmdOptions();

   // festlegen der Optionstabelle
   void setOptions( const OPTION *opt ) { option_list = opt; }
   // erfragen der Optionstabelle
   const OPTION *getOptions() { return option_list; }

   // naechste Option auswerten
   bool getOption( int &key, const char* &value );


private:
   const OPTION *findToken( const char *str, const char **rest );

};


#endif

/*.EH.*/
