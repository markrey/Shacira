/*.SH.*/

/*
 *  Headerfile for module eb_file
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  eb_file.cpp on Monday March 05 2001  13:32:02
 */

#ifndef __eb_file__
#define __eb_file__


// Headerfiles
// ===========================================================================

#include <stdio.h>
#include <stdarg.h>

#if defined __ECL_GNUC__
   #include <io.h>
   #include <sys/types.h>
   #include <sys/stat.h>
#else
   #include <io.h>
   #include <sys/stat.h>
#endif

#include "base/eb_err.hpp"
#include "base/eb_str.hpp"

class cFile;
class cDir;


// ===========================================================================
// Definition cErrFile
// ---------------------------------------------------------------------------
//
// cBase
//  +--cErrBase
//      +--cErrFile
//
// ===========================================================================

class __ECL_DLLEXPORT__ cErrFile : public cErrBase {

public:
   cErrFile(ERR_TYPE err);
   cErrFile(ERR_TYPE err, const char *filespec);
   cErrFile(ERR_TYPE err, cFile& file);
   cErrFile(ERR_TYPE err, cDir& dir);

   enum ERR_CODE { errBase = ERR_PREFIX('F','I','L'),

      // Informationen
      errEOF         = errBase+errInfo  , //
      errNoMatch                        , //

      // Fehler
      errIllSpec     = errBase+errError , //
      errIllDevice                      , //
      errIllParam                       , //
      errIllAccess                      , //
      errFileNotFound                   , //
      errPathNotFound                   , //
      errExists                         , //
      errPermDenied                     , //
      errGeneralIO                      , //
      errDeviceFull                     , //
      errWriteProt                      , //
      errSeek                           , //
      errUnget                          , //
      errShare                          , //
      errDeviceInUse                    , //
      errDeviceLocked                   , //
      errPipeBusy                       , //
      errDeviceNotReady                 , //
      errSorry                          , //

      // Fatale Fehler
      errIllHandle   = errBase+errFatal , //
      errTableOverflow                  , //
      errTooManyFiles                   , //
      errLib                              //

   };

};


// ===========================================================================
// Definition cFile
// ---------------------------------------------------------------------------
//
// cBase
//  +--cFile
//
// ===========================================================================

class __ECL_DLLEXPORT__ cFile : public cBase {

// Konstanten
public:
   #if defined __ECL_OS2__
      enum {
         PATH_MAX = 260,               // CCHMAXPATH aus BSEDOS.H
         PATH_COMP_MAX = 256           // CCHMAXPATHCOMP aus BSEDOS.H
      };
      #define File_SEPARATOR  "\\"
      #define File_CONSOLE  "con"
   #elif defined __ECL_W32__
      enum {
         PATH_MAX = _MAX_PATH,
         PATH_COMP_MAX = _MAX_DIR
      };
      #define File_SEPARATOR  "\\"
      #define File_CONSOLE  "con"
   #endif

// Typen
public:
   typedef char NAME[ PATH_MAX ];          // Dateiname
   typedef const char *MODE;               // Zugriffsmodus auf Dateien
   typedef struct stat STAT;               // Statusdaten einer Datei
   typedef fpos_t POS;                     // Positionsangabe

   enum BUF_MODE {  // Puffertypen
      BUF_MODE_FULL  = _IOFBF,
      BUF_MODE_LINE  = _IOLBF,
      BUF_MODE_NONE  = _IONBF
   };

   enum SEEK_MODE {  // Modus fuer Seek()
      SEEK_MODE_SET  = SEEK_SET,
      SEEK_MODE_CUR  = SEEK_CUR,
      SEEK_MODE_END  = SEEK_END
   };

// Variablen
private:
   FILE        *File;      // Filehandle
   cString     Name;       // Dateiname
   bool        Text;       // Textmodus?
   bool        IsTTY;      // Zeichenorientiertes Geraet?

   static unsigned long EclMode;  // ECL-spezifische Betriebsarten
public:
   enum {
      ECL_MODE_NOEOFERR = 0x0001    // eof wirft keinen Fehler
   };
   static cBase::MASK_NAME EclMode_mask_name[];

   // Hier sollten mal alle File_...-Typen stehen

// ------ METHODEN ---------------------------------------------------

private:
   void OpenFile( const char *fname, MODE mode );
   void RaiseError( int err_code );

public:
   cFile( const char *fname=NULL, MODE mode="r" );    // Datei oeffnen
   cFile( FILE *f_handle, MODE mode="r" );            // Existierendes Handle einbinden
   ~cFile();                                          // Datei schliessen
   void Open( const char *fname, MODE mode="r" );     // Datei oeffnen (falls nicht durch Konstruktor)
   void Assign( FILE *f_handle, MODE mode="r" );      // Existierendes Handle einbinden
   void Close();                                      // Datei schliessen (Objekt bleibt erhalten)
   bool Eof();                                        // EOF erreicht?
   int GetNo();                                       // DOS-Handle erfragen
   void SetBuf( void *buf );                          // Dateipuffer setzen
   void SetVBuf( void *buf, BUF_MODE type, size_t size );
   void GetPos( POS *pos );                           // Dateiposition ermitteln?
   void SetPos( POS *pos );                           // Dateiposition setzen
   void Rewind();                                     // Dateizeiger zuruecksetzen
   void Seek( long offset, SEEK_MODE mode );          // Dateiposition suchen
   long Tell();                                       // Dateiposition ermitteln
   void FStat( STAT *stat_buf );                      // Dateizustand abfragen
   void Reopen( const char *fname, MODE mode );       // Andere Datei mit Objekt verbinden
   void Flush();                                      // Dateipuffer schreiben
   void Write( void *ptr, size_t elem_size, size_t count );   // In Datei schreiben
   void Putc( int ch );                               // Zeichen in Datei schreiben
   void Puts( const char *s );                        // String in Datei schreiben
   int Printf( const char *fmt, ... );                // printf in Datei
   int VPrintf( const char *fmt, va_list args );      // vprintf in Datei
   size_t cFile::Read( void *ptr, size_t elem_size, size_t count );  // Aus Datei lesen
   int Getc();                                        // Zeichen aus Datei lesen
   char *Gets( char str[], int max_len, bool strip_nl=false ); // String aus Datei lesen
   int Scanf( const char *fmt, ... );                 // Scanf aus Datei
   int VScanf( const char *fmt, va_list args );       // VScanf aus Datei
   void Ungetc( int c );                              // Eingelesenes Zeichen zurueckstellen
   size_t RawRead( void *ptr, size_t count );         // Low-Level Lesen
   size_t RawWrite( void *ptr, size_t count );        // Low-Level Schreiben
   bool Isatty();                                     // Ist Datei zeichenorientiert?
   cString GetName();                                 // Liefert Dateinamen
   void ClearError();                                 // Fehlerzustand zuruecksetzen

   // Auch direkt aufzurufende Funktionen
   static bool Exists( const char *fname );           // Vorhandensein abpruefen
   static void MakeDirName( char path_name[] );       // Backslash an Pfad haengen (falls noetig)
   static void Stat( char *path, STAT *stat_buf );    // Statusdaten ermitteln
   static void Rename( const char *old_name, const char *new_name );
   static void Copy( const char *from_fspec, const char *to_fspec );
   static void Remove( const char *fpattern );
   static cString ExpandFileName(cString path, cString name, cString ext);
   static cString SplitFileName(cString fspec, cString &path, cString &ext);
   static cString GetPath(cString fspec);             // Pfad ermitteln (mit '\' am Ende)
   static cString GetName(cString fspec);             // Dateiname (ohne Ext) ermitteln
   static cString GetFullName(cString fspec);         // Dateiname mit Ext ermitteln
   static cString GetExt(cString fspec);              // Erweiterung ermitteln (mit '.')

   static void SetMode(unsigned long mode);           // Betriebsart einstellen
   static void SetMode(const char *mode);             // Betriebsart in Klartext einstellen
   static unsigned long GetMode();                    // Betriebsart ermitteln
};



// ===========================================================================
// Definition cDir
// ---------------------------------------------------------------------------
//
// cBase
//  +--cDir
//
// ===========================================================================

#if defined  __ECL_GNUC__

   #include <io.h>
   #include <sys/types.h>
   #include <sys/stat.h>
   #include <dirent.h>

#elif defined  __ECL_ICC__

   #include <io.h>
   #include <sys/stat.h>

   #define MAXNAMLEN  cFile::PATH_COMP_MAX
   #define MAXPATHLEN cFile::PATH_COMP_MAX
   #define A_RONLY   0x01
   #define A_HIDDEN  0x02
   #define A_SYSTEM  0x04
   #define A_LABEL   0x08
   #define A_DIR     0x10
   #define A_ARCHIVE 0x20

   struct ftime {
      unsigned int twosecs : 5;
      unsigned int minutes : 6;
      unsigned int hours   : 5;
   };

   struct fdate {
      unsigned int day     : 5;
      unsigned int month   : 4;
      unsigned int year    : 7;
   };

   struct dirent {
      int            d_ino;                 /* Almost not used           */
      int            d_reclen;              /* Almost not used           */
      int            d_namlen;              /* Length of d_name          */
      char           d_name[MAXNAMLEN + 1]; /* File name, 0 terminated   */
      unsigned long  d_size;                /* File size (bytes)         */
      unsigned long  d_attr;                /* OS file attributes        */
      struct ftime   d_time;                /* OS file modification time */
      struct fdate   d_date;                /* OS file modification date */
   };

#elif defined  __ECL_VCPP__

   #include <io.h>
   #include <sys\stat.h>

   #define MAXNAMLEN  cFile::PATH_COMP_MAX
   #define MAXPATHLEN cFile::PATH_COMP_MAX
   #define A_RONLY   0x01
   #define A_HIDDEN  0x02
   #define A_SYSTEM  0x04
   #define A_LABEL   0x08
   #define A_DIR     0x10
   #define A_ARCHIVE 0x20

   struct ftime {
      unsigned int twosecs : 5;
      unsigned int minutes : 6;
      unsigned int hours   : 5;
   };

   struct fdate {
      unsigned int day     : 5;
      unsigned int month   : 4;
      unsigned int year    : 7;
   };

   struct dirent {
      int            d_ino;                 /* Almost not used           */
      int            d_reclen;              /* Almost not used           */
      int            d_namlen;              /* Length of d_name          */
      char           d_name[MAXNAMLEN + 1]; /* File name, 0 terminated   */
      unsigned long  d_size;                /* File size (bytes)         */
      unsigned long  d_attr;                /* OS file attributes        */
      struct ftime   d_time;                /* OS file modification time */
      struct fdate   d_date;                /* OS file modification date */
   };

#else

   #error "Your compiler is not supported"

#endif

class __ECL_DLLEXPORT__ cDir : public cBase {

public:

   // Verzeichnis oeffnen
   cDir(const char *name);
   // Verzeichnis schliessen
   ~cDir();

   // Verzeichniseintrag (DirRead)
   typedef struct dirent DIR_ENTRY;


   // Funktionen auf Verzeichnis
   // ==========================

   // Eintrag lesen
   DIR_ENTRY *cDir::read();
   // Eintrag ansteuern
   void seek(long offset);
   // Nummer des aktuellen Eintrags
   long tell();
   // Zu erstem Eintrag zurueck
   void rewind();


   // Statische Funktionen
   // ====================

   // Aktuelles Arbeitsverzeichnis erfragen
   static cString getWorkingDir();
   // Aktuelles Arbeitsverzeichnis setzen
   static void setWorkingDir(cString dir);


private:

   void *Dir;        // Directory-Struktur
   cString Name;     // Directory-Name

   // Fehler generieren, Fehlercode aus errno
   void raiseError(int err_code);
   // Fehler generieren, Fehlercode aus errno (statische Version)
   static void raiseError(int err_code, const char *dirname);

};


class __ECL_DLLEXPORT__ cFileFind : public cBase {
private:
   cString  file_name;
   cString  file_path;
   long     file_size;
   int      file_attr;
   time_t   file_date;

public:
   enum {
      ATTR_READONLY  = 0x01,
      ATTR_HIDDEN    = 0x02,
      ATTR_SYSTEM    = 0x04,
      ATTR_DIRECTORY = 0x10,
      ATTR_ARCHIVE   = 0x20,

      MASK_ALL       = 0x0600,   // sichtbare Verzeichnisse und Dateien
      MASK_FILE      = 0x1600,   // sichtbare Dateien
      MASK_DIR       = 0x1610    // sichtbare Verzeichnisse
   };

   cFileFind(cString _files, int _mask=MASK_FILE);
   cFileFind(cString _files, cString _dirs);
   ~cFileFind();

   // naechste passende Datei suchen, false falls es keine mehr gibt
   bool findNext();
   bool easy_find_next();

   // Name der gefundenen Datei
   cString getFullName() { return ff_tail->file_name; }
   // Pfad der gefundenen Datei
   cString getPath() { return ff_tail->file_path; }
   // Pfad und Name der gefundenen Datei
   cString getFileSpec() { return ff_tail->file_path+ff_tail->file_name; }
   // Laenge der gefundenen Datei
   long getSize()    { return ff_tail->file_size; }
   // Attribute der gefundenen Datei
   int getAttr()     { return ff_tail->file_attr; }
   // Datum der gefundenen Datei
   time_t getDate()  { return ff_tail->file_date; }

   // Attribute gezielt pruefen
   bool isReadOnly() { return (ff_tail->file_attr & ATTR_READONLY) != 0; }
   bool isHidden()   { return (ff_tail->file_attr & ATTR_HIDDEN) != 0; }
   bool isSystem()   { return (ff_tail->file_attr & ATTR_SYSTEM) != 0; }
   bool isDir()      { return (ff_tail->file_attr & ATTR_DIRECTORY) != 0; }
   bool isArchive()  { return (ff_tail->file_attr & ATTR_ARCHIVE) != 0; }

private:
   enum {
      STATE_FIRST,
      STATE_NEXT,
      STATE_DONE
   } find_state;
   int find_mask;

   // --- Parameter fuer die rekursive Durchwanderungsvariante
   //     (walk_mode, ff_last & ff_tail zur Erkennung und Durchfuehrung der
   //     einstufigen Suche)
   enum {
      WALK_OFF,   // Deaktiviert
      WALK_FILES, // Suche nach Dateien
      WALK_DIRS   // Suche nach Verzeichnissen
   } walk_mode;
   cFileFind *ff_tail;  // Aktuelle und tiefste Suchebene
   cFileFind *ff_last;  // vorangegangene Suchebene

   cString walk_path,walk_file_pattern,walk_dir_pattern;
   bool walk_find_next();
public:
   void walk_set_last(cFileFind *ff) { ff_last = ff; }
   // --- Ende der mehrstufigen Erweiterung

private:
   // Fehlercode fuer _first() und _next()
   enum {
      FIND_OK,
      FIND_NO_MATCH,
      FIND_ILL_PARAM
   };
   // Die Funktionen _first(), _next() und _close() stellen (bis jetzt) die
   // Schnittstelle zum verwendeten Betriebssystem/Compiler dar.
   #if defined __ECL_VCPP__
      long _handle;
   #elif defined __ECL_ICC__
      // TBD ...
   #endif

   // find_pattern x find_attr --> _handle x find x error
   int _first(const char *pattern, int mask);
   // find_handle -> find x error
   int _next();
   // find_handle -> %
   void _close();
};


#endif

/*.EH.*/
