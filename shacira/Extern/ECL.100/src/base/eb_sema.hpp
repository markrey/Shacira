/*.SH.*/

/*
 *  Headerfile for module eb_sema
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  eb_sema.cpp on Saturday March 17 2001  16:10:35
 */

#ifndef __eb_sema__
#define __eb_sema__


// Headerfiles
// ===========================================================================

#include "base/eb_base.hpp"
#include "base/eb_str.hpp"
#include "base/eb_list.hpp"


// ===========================================================================
// Definition cSema
// ---------------------------------------------------------------------------
//
// Basisklasse fuer Semaphoren
//
// cBase
//  +--cOsBase
//      +--cSema
//
// ===========================================================================

class __ECL_DLLEXPORT__ cSema : public cOsBase {

public:
   enum OPEN_MODE {
      semCreate,        // Semaphore erzeugen
      semOpen,          // Semaphore oeffnen (Verbindung herstellen)
      semOpenOrCreate   // Semaphore oeffnen (Erzeugen, falls nicht vorhanden)
   };

};


// ===========================================================================
// Definition cMutexSem
// ---------------------------------------------------------------------------
//
// Mutual exclusive Semaphore. Der Initialzustand kann beim Konstruktor ange-
// geben werden (realisiert ueber bool):
//
//    true  - Mutex belegt
//    false - Mutex nicht belegt
//
// cBase
//  +--cOsBase
//      +--cSema
//          +--cMutexSem
//
// ===========================================================================

class __ECL_DLLEXPORT__ cMutexSem : public cSema {

public:
   // Anonyme Mutex anlegen
   cMutexSem(bool init_state = false)
      { openAnonymous(init_state); }
   // Benannte Mutex oeffnen oder erzeugen (abhaengig von 'mode')
   cMutexSem(cString name, OPEN_MODE mode, bool init_state = false)
      { openNamed(name, mode, init_state); }
   // Mutex freigeben
   ~cMutexSem()
      { close(); }

   // Mutex anfordern (liefert false bei Timeout oder Fehler)
   // ms_timeout: <0: Unendlich; =0: Sofortige Rueckkehr; >0: Timeout in ms
   bool request(int ms_timeout = -1);
   // Mutex freigeben
   void release();

private:
   // Anonyme Mutex oeffnen
   void openAnonymous(bool init_state);
   // Benannte Mutex oeffnen oder erzeugen (abhaengig von 'mode')
   void openNamed(cString name, OPEN_MODE mode, bool init_state);
   // Mutex schliessen
   void close();

};


// ===========================================================================
// Definition cEventSem
// ---------------------------------------------------------------------------
//
// Event Semaphore. Event-Status realisiert ueber bool:
//
//    true  - Event gesetzt
//    false - Event rueckgesetzt
//
// cBase
//  +--cOsBase
//      +--cSema
//          +--cEventSem
//
// ===========================================================================

class __ECL_DLLEXPORT__ cEventSem : public cSema {

public:
   // Anonymen Event anlegen
   cEventSem(bool init_state = false)
      { openAnonymous(init_state); }
   // Benannten Event oeffnen oder erzeugen (abhaengig von 'mode')
   cEventSem(cString name, OPEN_MODE mode, bool init_state = false)
      { openNamed(name, mode, init_state); }
   // Event freigeben
   ~cEventSem()
      { close(); }

   // Auf Eintreten des Events warten (liefert false bei Timeout oder Fehler)
   // ms_timeout: <0: Unendlich; =0: Sofortige Rueckkehr; >0: Timeout in ms
   bool wait(int ms_timeout = -1) const;

   // Event setzen
   void set();
   // Event ruecksetzen
   void reset();
   // Event setzen und wieder zuruecksetzen
   void pulse();
   // Eventstatus erfragen
   bool query() const;

   // Goodie: Operatoren zur Manipulation der Event-Semaphoren
   operator bool() const
      { return query(); }
   cEventSem& operator=(bool state)
      { if ( state ) set(); else reset();
        return *this; }

private:
   // Anonymen Event oeffnen
   void openAnonymous(bool init_state);
   // Benannten Event oeffnen oder erzeugen (abhaengig von 'mode')
   void openNamed(cString name, OPEN_MODE mode, bool init_state);
   // Event schliessen
   void close();

};

#if defined __ECL_ICC__
   inline void EclDestructElements(const cEventSem **elements, int count)
      { /* no destructor call needed */ }
#endif


// ===========================================================================
// Definition cMuxEventSem
// ---------------------------------------------------------------------------
//
// Multiple Event Semaphores.
//
// cBase
//  +--cOsBase
//      +--cMuxEventSem
//
// ===========================================================================

class __ECL_DLLEXPORT__ cMuxEventSem : public cOsBase {

public:
   // Leere cMuxEventSem konstruieren
   cMuxEventSem()
      { }
   // cMuxEventSem mit einem Event konstruieren
   cMuxEventSem(const cEventSem& event)
      { addEvent(event); }
   // cMuxEventSem aus einem anderen konstruieren
   cMuxEventSem(const cMuxEventSem& other)
      { setEvents(other); }
   // cMuxEventSem freigeben
   ~cMuxEventSem()
      { }

   // Event-Semaphore setzen (bisherigen Inhalt loeschen)
   cMuxEventSem& setEvent(const cEventSem& event);
   // Event-Semaphore hinzufuegen
   cMuxEventSem& addEvent(const cEventSem& event);
   // cMuxEventSem setzen (bisherigen Inhalt loeschen)
   cMuxEventSem& setEvents(const cMuxEventSem& other);
   // cMuxEventSem hinzufuegen
   cMuxEventSem& addEvents(const cMuxEventSem& other);

   // Auf Eintreten von Events warten (liefert false bei Timeout oder Fehler)
   // wait_for_all: Bei true alle, bei false mindestens ein Event signalisiert
   // ms_timeout: <0: Unendlich; =0: Sofortige Rueckkehr; >0: Timeout in ms
   bool wait(int ms_timeout = -1, bool wait_for_all = false);

   // Auf Eintreten aller Events warten
   bool waitForAll(int ms_timeout = -1)
      { return wait(ms_timeout, true); }
   // Auf Eintreten mindestens eines Events warten
   bool waitForOne(int ms_timeout = -1)
      { return wait(ms_timeout, false); }

   // Zuweisung einer einzelnen Event-Semaphoren
   cMuxEventSem& operator=(const cEventSem& event)
      { return setEvent(event); }
   // Zuweisung einer anderen cMuxEventSem
   cMuxEventSem& operator=(const cMuxEventSem& other)
      { return setEvents(other); }

   // Konkatenation von Event-Semaphoren mit cMuxEventSem-Objekten
   inline friend cMuxEventSem operator+(const cEventSem& s1, const cEventSem& s2)
      { return cMuxEventSem(s1).addEvent(s2); }
   inline friend cMuxEventSem operator+(const cEventSem& s1, const cMuxEventSem& ms2)
      { return cMuxEventSem(s1).addEvents(ms2); }
   inline friend cMuxEventSem operator+(const cMuxEventSem& ms1, const cEventSem& s2)
      { return cMuxEventSem(ms1).addEvent(s2); }
   inline friend cMuxEventSem operator+(const cMuxEventSem& ms1, const cMuxEventSem& ms2)
      { return cMuxEventSem(ms1).addEvents(ms2); }

   // Hinzufuegen einer einzelnen Event-Semaphoren
   cMuxEventSem& operator+=(const cEventSem& event)
      { return addEvent(event); }
   // Hinzufuegen einer anderen cMuxEventSem
   cMuxEventSem& operator+=(const cMuxEventSem& other)
      { return addEvents(other); }

private:
   #if defined __ECL_VCPP__
      typedef class __ECL_DLLEXPORT__ cList<const cEventSem*, const cEventSem*> SEMP_LIST;
   #else
      typedef cList<const cEventSem*, const cEventSem*> SEMP_LIST;
   #endif
   SEMP_LIST semp_list;

};


#endif

/*.EH.*/
