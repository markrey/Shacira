/*.SH.*/

/*
 *  Headerfile for module es_row
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  es_row.cpp on Monday December 10 2001  22:55:09
 */

#ifndef __es_row__
#define __es_row__


// Headerfiles
// ===========================================================================

#include "store/es_query.hpp"


// ===========================================================================
// Definition csRow
// ---------------------------------------------------------------------------
//
// cBase
//  +--csBaseStorage
//      +--csRow
//
// ===========================================================================

class __ECL_DLLEXPORT__ csRow : public csBaseStorage, public cEventSource {
   ECL_DECLARE(csRow,csBaseStorage)
   friend class csField;

public:
   // Aktuellen Datensatz aus Query uebernehmen oder neuen Datensatz anlegen
   csRow(csQuery *query, int flags = 0);
   // Ueber cString-'key' definierten Datensatz aus Query erzeugen
   csRow(csQuery *query, cString key, int flags = 0);
   // Copy-Konstruktor
   csRow(const csRow& other);
   // Destruktor
   ~csRow();


   // Flags
   // =====

   enum FLAGS { fStart = csBaseStorage::fUser,
      fUser        = fStart << 2   // Benutzerdefinierte Flags
   };


   // Allgemeines
   // ===========

   // Liefert den Schluesselwert des Datensatzes
   inline cString getKey() const
      { return key; }
   // Liefert einen Zeiger auf die zugrundeliegende Abfrage
   inline csQuery *getQuery() const
      { return query; }


   // Felder
   // ======

   // Anzahl Felder erfragen
   int getFieldCount() const;
   // Feld erfragen
   csField *getField(int idx) const;


   // Aktuelle Werte lesen
   // ====================

   bool fetch();


   // Transaktionen
   // =============
   // Moegliche Transaktionen auf Datensaetze sind Einfuegen, Bearbeiten und
   // Loeschen. Um eine dieser Varianten zu waehlen, muss in den jeweiligen
   // Transaktionsmodus gewechselt und anschliessend entweder save() oder
   // cancel() aufgerufen werden.
   //
   //    EINFUEGEN, BEARBEITEN:     | EINFUEGEN, LOESCHEN:
   //   ----------------------------+--------------------------
   //    if ( row.edit() ) {        | if ( row.add() ) {
   //       ...                     |    ...
   //       if ( UserSays() == OK ) |    row.save();}
   //          row.save();          | }
   //       else                    | if ( row.remove() ) {
   //          row.cancel();        |    ...
   //    }                          |    row.save();}
   //                               | }

   enum TA_MODE {    // Transaktionsmodus:
      READONLY,      // - Datensatz wird nur gelesen
      RW_INSERT,     // - Datensatz wird eingefuegt
      RW_UPDATE,     // - Datensatz wird bearbeitet
      RW_DELETE,     // - Datensatz wird geloescht
      DELETED        // - Datensatz ist geloescht
   };

   // Aktuellen Transaktionsmodus ermitteln
   TA_MODE getTAMode() const
      { return ta_mode; }

   // Neuen Datensatz hinzufuegen (RW_INSERT)
   bool add();
   // Wechselt in den Bearbeiten-Modus (RW_UPDATE)
   bool edit();
   // Wechselt in den Loesch-Modus (RW_DELETE)
   bool remove();
   // Fuehrt aktuelle Aenderungen durch (Uebernehmen-Funktion)
   bool apply();
   // Speichert aktuelle Aenderungen, zurueck zu READONLY
   bool save();
   // Bricht aktuelle Aenderungen ab, zurueck zu READONLY
   bool cancel();


protected:

   // Hilfsfunktionen fuer abgeleitete Klassen
   // ========================================

   // Schluesselwert des Datensatzes manipulieren (z.B. bei edit oder add)
   void setKey(const cString& new_key);


protected:

   // Zusaetzliche Events
   // ===================

   // Wird aufgerufen, wenn ein Feld zum Datensatz hinzugefuegt wird
   virtual void onFieldAdded(csField *field);

   enum INFO {    // Zusatzinformationen:
      INSERT,     // - Funktion wird waehrend INSERT aufgerufen
      UPDATE,     // - Funktion wird waehrend UPDATE aufgerufen
      DELETE      // - Funktion wird waehrend DELETE aufgerufen
   };

   // Wird aufgerufen, um die Felder des Datensatzes (erneut) einzulesen
   virtual bool onFetch() = 0;
   // Wird aufgerufen, um das Einfuegen zu starten (-> false, falls nicht moeglich)
   virtual bool onAdd() = 0;
   // Wird aufgerufen, um die Bearbeitung zu starten (-> false, falls nicht moeglich)
   virtual bool onEdit() = 0;
   // Wird aufgerufen, um den Datensatz zu loeschen (-> false, falls nicht moeglich)
   virtual bool onRemove() = 0;
   // Wird aufgerufen, um die Aenderungen zu speichern (-> false, falls nicht moeglich)
   virtual bool onSave(INFO commit_info) = 0;
   // Wird aufgerufen, um die Aenderungen zu verwerfen (-> false, falls nicht moeglich)
   virtual bool onCancel(INFO rollback_info) = 0;

   // Wird aufgerufen, um den Beginn einer Transaktion zu markieren
   virtual bool onBeginTA() = 0;
   // Wird aufgerufen, um die letzte (alle) Transaktion(en) zu speichern
   virtual bool onCommitTA(bool commit_all) = 0;
   // wird aufgerufen, um die Transaktion zu verwerfen
   virtual bool onRollbackTA() = 0;


private:

   TA_MODE ta_mode;
   csQuery *query;
   cString key;
   void *fields;

   // Intern: Feld hinzufuegen (fuer csField-Konstruktor)
   int addField(csField *field);
   // Intern: Feld loeschen (fuer csField-Destruktor)
   void removeField(csField *field);

};


#endif

/*.EH.*/
