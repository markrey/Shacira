/*.SH.*/

/*
 *  Headerfile for module es_var
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  es_var.cpp on Wednesday March 20 2002  22:47:15
 */

#ifndef __es_var__
#define __es_var__


// Headerfiles
// ===========================================================================

#include "store/es_store.hpp"


// ===========================================================================
// Definition csVar
// ---------------------------------------------------------------------------
//
// cBase
//  +--csBaseStorage
//      +--csStorage
//          +--csVar
//
// ===========================================================================

class __ECL_DLLEXPORT__ csVar : public csStorage {
   ECL_DECLARE(csVar,csStorage)

public:

   // Initialisierung als int-Variable
   csVar(int& _buf, int _width = 11, int _flags = 0);
   // Initialisierung als double-Variable
   csVar(double& _buf, int _width = 21, int _prec = -1, int _flags = fThousandSep);
   // Initialisierung als cTime-Variable
   csVar(cTime& _buf, int _flags = 0);
   // Initialisierung als cDate-Variable
   csVar(cDate& _buf, int _flags = 0);
   // Initialisierung als cDateTime-Variable
   csVar(cDateTime& _buf, int _flags = 0);
   // Initialisierung als char-Variable
   csVar(char& _buf, int _flags = 0);
   // Initialisierung als String-Variable
   csVar(char *_buf, int _size, int _flags = 0);
   // Initialisierung als beliebige Variable; Puffer wird automatisch allokiert
   csVar(TYPE _type, int _size, int _width = 0, int _prec = 0, int _flags = 0);
   // Kopie einer anderen Variable
   csVar(const csVar& other);
   // Destruktor
   ~csVar();


   // Flags
   // =====

   enum FLAGS { fStart = csStorage::fUser,
      fIsNull      = fStart << 0,  // Objekt ist NULL
      fUser        = fStart << 1   // Benutzerdefinierte Flags
   };


protected:

   // Ueberschriebene Events
   // ======================

   // Werte erfragen
   // --------------

   // Variable als int abfragen
   bool onGetInt(int& _buf) const;
   // Variable als double abfragen
   bool onGetDouble(double& _buf) const;
   // Variable als cTime abfragen
   bool onGetTime(cTime& _buf) const;
   // Variable als cDate abfragen
   bool onGetDate(cDate& _buf) const;
   // Variable als cDateTime abfragen
   bool onGetDateTime(cDateTime& _buf) const;
   // Variable als char abfragen
   bool onGetChar(char& _buf) const;
   // Variable als String abfragen
   bool onGetString(cString& _buf) const;


   // Werte setzen
   // ------------

   // Variable ueber int setzen
   bool onPutInt(int _buf);
   // Variable ueber double setzen
   bool onPutDouble(double _buf);
   // Variable ueber cTime setzen
   bool onPutTime(cTime _buf);
   // Variable ueber cDate setzen
   bool onPutDate(cDate _buf);
   // Variable ueber cDateTime setzen
   bool onPutDateTime(cDateTime _buf);
   // Variable ueber char setzen
   bool onPutChar(char _buf);
   // Variable ueber String setzen
   bool onPutString(cString _buf);


   // Pufferspeicher
   // --------------

   // Wird aufgerufen, um die Adresse des Pufferspeichers zu ermitteln
   void *onGetBuffer();
   // Wird aufgerufen, um Puffergroesse (Bytes) ermitteln
   int onGetBufferSize() const;
   // Pruefen, ob der Pufferspeicher kompatibel zum Uebergabetyp ist
   int onGetBufferStyle() const;


   // Sonstiges
   // ---------

   // Sinnvolle maximale Groesse eines Eingabefeldes ermitteln
   int onGetMaskLength() const;

   // Ist die Variable NULL?
   bool onCheckNull() const
      { return !!getFlags(fIsNull); }
   // NULL-Zustand der Variablen setzen
   void onSetNull(bool null = true);


protected:

   // Intern: Konstruktor (fuer cVarXxxx-Klassen)
   csVar(int size, int width, int prec, int flags, TYPE type);
   // Intern: SetBuffer-Methode (fuer cVarXxxx-Klassen)
   void setBuffer(void *new_buf, int new_size = -1, bool auto_del = false);
   // Intern: Neuen Puffer der Groesse 'new_size' allokieren
   void *newBuffer(int new_size);
   // Intern: Kopieren aller Attribute von 'other'
   void copyFrom(const csVar& other);
   // Intern: Setzen des Puffers und des NULL-Zustandes
   void initFrom(const void *data, int size, bool null);


private:

   void *buf;     // Adresse des Puffers
   int size;      // Allokierte Groesse des Puffers

};


// ===========================================================================
// Definition csVarString
// ---------------------------------------------------------------------------
//
// cBase
//  +--csBaseStorage
//      +--csStorage
//          +--csVar
//              +--csVarString
//
// ===========================================================================

class __ECL_DLLEXPORT__ csVarString : public csVar {
   ECL_DECLARE(csVarString,csVar)
   char *v;
public:
   csVarString(int size, int flags = fIsNull) :
      csVar(size, 0, 0, flags | fPermanent, tString)
      { v = new0 char[size]; *v = '\0'; setBuffer(v); }
   csVarString(const csVarString& other) : csVar(other)
      { v = new0 char[getBufferSize()]; setBuffer(v);
        strxcpy(v, other.v, getBufferSize()); }
   csVarString(const cString& s) :
      csVar(s.getSize(), 0, 0, fPermanent, tString)
      { v = new0 char[s.getSize()]; setBuffer(v);
        if ( !s.isEmpty() ) strxcpy(v, s, getBufferSize());
        setNull(s.isEmpty()); }
   ~csVarString()
      { delete[] v; }

   csVarString& operator=(const csVarString& other)
      { copyFrom(other);
        delete[] v; v = new0 char[getBufferSize()]; setBuffer(v);
        strxcpy(v, other.v, getBufferSize()); setNull(other.isNull());
        return *this; }
   csVarString& operator=(const char *s)
      { if ( s ) strxcpy(v, s, getBufferSize());
        setNull(s ? !*s : false);
        return *this; }
   csVarString& operator=(const cString& s)
      { if ( !s.isEmpty() ) strxcpy(v, s, getBufferSize());
        setNull(s.isEmpty());
        return *this; }

   int operator==(const csVarString& other)
      { if ( !isNull() && !other.isNull() ) return strcmp(v, other.v);
        return isNull() && other.isNull() ? 0 : 1; }
   int operator!=(const csVarString& other)
      { return !(*this == other); }

   operator const char *() const
      { return v; }
   operator char *()
      { return v; }
};


// ===========================================================================
// Definition csVarInt
// ---------------------------------------------------------------------------
//
// cBase
//  +--csBaseStorage
//      +--csStorage
//          +--csVar
//              +--csVarInt
//
// ===========================================================================

class __ECL_DLLEXPORT__ csVarInt : public csVar {
   ECL_DECLARE(csVarInt,csVar)
   int v;

public:
   csVarInt() :
      csVar(sizeof(int), 11, 0, fIsNull | (int)fPermanent, tInt)
      { v = 0; setBuffer(&v); }
   csVarInt(int def_val, int width = 11, int flags = 0) :
      csVar(sizeof(int), width, 0, flags | fPermanent, tInt)
      { v = def_val; setBuffer(&v); }
   csVarInt(const csVarInt& other) : csVar(other)
      { v = other.v; setBuffer(&v); }

   csVarInt& operator=(const csVarInt& other)
      { copyFrom(other); v = other.v;
        setNull(other.isNull());
        return *this; }
   int& operator=(int other)
      { v = other; setNull(false); return v; }

   int operator==(const csVarInt& other)
      { if ( !isNull() && !other.isNull() ) return v == other.v;
        return isNull() && other.isNull(); }
   int operator!=(const csVarInt& other)
      { return !(*this == other); }

   operator int () const
      { return v; }
};


// ===========================================================================
// Definition csVarDouble
// ---------------------------------------------------------------------------
//
// cBase
//  +--csBaseStorage
//      +--csStorage
//          +--csVar
//              +--csVarDouble
//
// ===========================================================================

class __ECL_DLLEXPORT__ csVarDouble : public csVar {
   ECL_DECLARE(csVarDouble,csVar)
   double v;

public:
   csVarDouble() :
      csVar(sizeof(double), 21, -1, fIsNull | (int)fPermanent | (int)fThousandSep, tDouble)
      { v = 0.0; setBuffer(&v); }
   csVarDouble(double def_val, int width = 21, int prec = -1, int flags = fThousandSep) :
      csVar(sizeof(double), width, prec, flags | fPermanent, tDouble)
      { v = def_val; setBuffer(&v); }
   csVarDouble(const csVarDouble& other) : csVar(other)
      { v = other.v; setBuffer(&v); }

   csVarDouble& operator=(const csVarDouble& other)
      { copyFrom(other); v = other.v;
        setNull(other.isNull());
        return *this; }
   double& operator=(double other)
      { v = other; setNull(false); return v; }

   int operator==(const csVarDouble& other)
      { if ( !isNull() && !other.isNull() ) return v == other.v;
        return isNull() && other.isNull(); }
   int operator!=(const csVarDouble& other)
      { return !(*this == other); }

   operator double () const
      { return v; }
};


// ===========================================================================
// Definition csVarChar
// ---------------------------------------------------------------------------
//
// cBase
//  +--csBaseStorage
//      +--csStorage
//          +--csVar
//              +--csVarChar
//
// ===========================================================================

class __ECL_DLLEXPORT__ csVarChar : public csVar {
   ECL_DECLARE(csVarChar,csVar)
   char v;

public:
   csVarChar() :
      csVar(sizeof(char), 1, 0, fIsNull | (int)fPermanent, tChar)
      { v = '\0'; setBuffer(&v); }
   csVarChar(char def_val, int flags = 0) :
      csVar(sizeof(char), 1, 0, flags | fPermanent, tChar)
      { v = def_val; setBuffer(&v); }
   csVarChar(const csVarChar& other) : csVar(other)
      { v = other.v; setBuffer(&v); }

   csVarChar& operator=(const csVarChar& other)
      { copyFrom(other); v = other.v;
        setNull(other.isNull());
        return *this; }
   char& operator=(char other)
      { v = other; setNull(false); return v; }

   int operator==(const csVarChar& other)
      { if ( !isNull() && !other.isNull() ) return v == other.v;
        return isNull() && other.isNull(); }
   int operator!=(const csVarChar& other)
      { return !(*this == other); }

   operator char () const
      { return v; }
};


// ===========================================================================
// Definition csVarTime
// ---------------------------------------------------------------------------
//
// cBase
//  +--csBaseStorage
//      +--csStorage
//          +--csVar
//              +--csVarTime
//
// ===========================================================================

class __ECL_DLLEXPORT__ csVarTime : public csVar {
   ECL_DECLARE(csVarTime,csVar)
   cTime v;

public:
   csVarTime() :
      csVar(sizeof(cTime), 0, 0, fIsNull | (int)fPermanent, tTime)
      { setBuffer(&v); }
   csVarTime(const cTime& def_val, int flags = 0) :
      csVar(sizeof(cTime), 0, 0, flags | fPermanent, tTime)
      { v = def_val; setBuffer(&v); }
   csVarTime(const csVarTime& other) : csVar(other)
      { v = other.v; setBuffer(&v); }

   csVarTime& operator=(const csVarTime& other)
      { copyFrom(other); v = other.v;
        setNull(other.isNull());
        return *this; }
   cTime& operator=(const cTime& other)
      { v = other; setNull(false); return v; }

   int operator==(const csVarTime& other)
      { if ( !isNull() && !other.isNull() ) return v == other.v;
        return isNull() && other.isNull(); }
   int operator!=(const csVarTime& other)
      { return !(*this == other); }

   operator cTime () const
      { return v; }
};


// ===========================================================================
// Definition csVarDate
// ---------------------------------------------------------------------------
//
// cBase
//  +--csBaseStorage
//      +--csStorage
//          +--csVar
//              +--csVarDate
//
// ===========================================================================

class __ECL_DLLEXPORT__ csVarDate : public csVar {
   ECL_DECLARE(csVarDate,csVar)
   cDate v;

public:
   csVarDate() :
      csVar(sizeof(cDate), 0, 0, fIsNull | (int)fPermanent, tDate)
      { setBuffer(&v); }
   csVarDate(const cDate& def_val, int flags = 0) :
      csVar(sizeof(cDate), 0, 0, flags | fPermanent, tDate)
      { v = def_val; setBuffer(&v); }
   csVarDate(const csVarDate& other) : csVar(other)
      { v = other.v; setBuffer(&v); }

   csVarDate& operator=(const csVarDate& other)
      { copyFrom(other); v = other.v;
        setNull(other.isNull());
        return *this; }
   cDate& operator=(const cDate& other)
      { v = other; setNull(false); return v; }

   int operator==(const csVarDate& other)
      { if ( !isNull() && !other.isNull() ) return v == other.v;
        return isNull() && other.isNull(); }
   int operator!=(const csVarDate& other)
      { return !(*this == other); }

   operator cDate () const
      { return v; }
};


// ===========================================================================
// Definition csVarDateTime
// ---------------------------------------------------------------------------
//
// cBase
//  +--csBaseStorage
//      +--csStorage
//          +--csVar
//              +--csVarDateTime
//
// ===========================================================================

class __ECL_DLLEXPORT__ csVarDateTime : public csVar {
   ECL_DECLARE(csVarDateTime,csVar)
   cDateTime v;

public:
   csVarDateTime() :
      csVar(sizeof(cDateTime), 0, 0, fIsNull | (int)fPermanent, tDateTime)
      { setBuffer(&v); }
   csVarDateTime(const cDateTime& def_val, int flags = 0) :
      csVar(sizeof(cDateTime), 0, 0, flags | fPermanent, tDateTime)
      { v = def_val; setBuffer(&v); }
   csVarDateTime(const csVarDateTime& other) : csVar(other)
      { v = other.v; setBuffer(&v); }

   csVarDateTime& operator=(const csVarDateTime& other)
      { copyFrom(other); v = other.v;
        setNull(other.isNull());
        return *this; }
   cDateTime& operator=(const cDateTime& other)
      { v = other; setNull(false); return v; }

   int operator==(const csVarDateTime& other)
      { if ( !isNull() && !other.isNull() ) return v == other.v;
        return isNull() && other.isNull(); }
   int operator!=(const csVarDateTime& other)
      { return !(*this == other); }

   operator cDateTime () const
      { return v; }
};


#endif

/*.EH.*/
