/*.SH.*/

/*
 *  Headerfile for module es_query
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  es_query.cpp on Wednesday March 20 2002  22:46:54
 */

#ifndef __es_query__
#define __es_query__


// Headerfiles
// ===========================================================================

#include "base/eb_event.hpp"
#include "store/es_store.hpp"
#include "store/es_filter.hpp"


// Forward-Deklarationen
// ===========================================================================

class cEloElementDescription;


// ===========================================================================
// Definition csQuery
// ---------------------------------------------------------------------------
//
// Realisiert eine abstrakte Abfrage von Datenbestaenden, die u.a. zum Fuellen
// von listenartigen Dialogelemente verwendet werden kann. Um eine konkrete
// Abfrage zu realisieren, muss diese Klasse entsprechend abgeleitet werden.
// Um den Verwaltungsaufwand moeglichst gering zu halten, wurden alle die
// Abfrage betreffenden Informationen (Datensaetze, Feld- und Gesamtbeschrei-
// bung) in eine Klasse "gepackt". Dies hat den Vorteil, dass ein die Abfrage
// benutzendes Objekt lediglich einen Zeiger auf ein csQuery-Objekt benoetigt,
// um alle benoetigten Informationen zu erhalten. Allerdings duerfen manche
// Methoden nur zu bestimmten Zeitpunkten aufgerufen werden (vgl. Kommentare
// in Klassendefinition).
//
//    Bezeichnung | Index | Art      | Beschreibung
//   -------------+-------+----------+----------------------------------
//    fldIconID   |  -4   | Default  | ID des dem Datensatz zugeord. Icons
//    fldDescr    |  -3   | Default  | Kurzbeschreibung des Datensatzes
//    fldName     |  -2   | Default  | Name des Datensatzes
//    fldKey      |  -1   | Default  | Schluesselwert des Datensatzes
//    fldField    |   0   | Optional | Erstes Feld der Abfrage
//    fldField+1  |   1   | Optional | Zweites Feld der Abfrage
//     :          |   :   |  :       |  :
//    fldField+n  |   n   | Optional | (n+1)-tes Feld der Abfrage
//
// Eine csQuery-Ableitung muss mindestens die Methoden onRewind(), onFetch()
// und onGetString() implementieren.
//
// cBase
//  +--csBaseStorage
//      +--csQuery
//
// ===========================================================================

class csFilter;

class __ECL_DLLEXPORT__ csQuery : public csBaseStorage, public cEventSource {
   ECL_DECLARE(csQuery,csBaseStorage)
   friend class csRow;

public:
   csQuery();
   csQuery(int flags);
   csQuery(const csQuery& other);
   ~csQuery();


   // Flags
   // =====

   enum FLAGS { fStart = csBaseStorage::fUser,
      fStopReq     = fStart << 0,  // Abfrage vorzeitig beenden
      fUnfiltered  = fStart << 1,  // Moegliche Query-Filter deaktivieren
      fUser        = fStart << 2   // Benutzerdefinierte Flags
   };


   // Ereignisgesteuertes Durchfuehren der Abfrage
   // ============================================
   // Beispiel fuer ereignisgesteuerte Abfrage:
   //
   //    main()
   //    {
   //       csMyListbox lb(...);
   //       csQuery q(...);
   //       if ( q.start(EVENT(&lb, (EVFUNC_RPI)lb.QueryFunc)) )
   //          print("Abfrage gestartet");
   //    }
   //
   //    int csMyListbox::QueryFunc(void *p1, int p2)
   //    {
   //       csQuery *query = (csQuery*)p1;
   //       csQuery::STATE state = (csQuery::STATE)p2;
   //       switch ( state ) {
   //        case csQuery::qsStart:   PrepareListbox(...); break;
   //        case csQuery::qsData:    AddDataToListbox(...); break;
   //        case csQuery::qsEnd:     CloseListbox(...); break;
   //       }
   //       return (int)true;  // false fuer Abbruch
   //    }

   enum STATE {
      qsInit,           // Vor dem ersten Start
      qsStart,          // Abfrage hat begonnen (vor erstem Datensatz)
      qsData,           // Naechster Datensatz bereit
      qsEnd             // Abfrage beendet (nach letztem Datensatz)
   };

   // Ereignisgesteuerte Abfrage starten
   bool start(const EVENT& event);
   // Ereignisgesteuerte Einzelabfrage starten
   bool start1(const EVENT& event, cString key);
   // Vorzeitiges Beenden der Abfrage vor dem naechsten Datensatz
   bool stop();


   // Sequentielles Durchfuehren der Abfrage
   // ======================================
   // Beispiel fuer sequentielle Abfrage:
   //
   //    main()
   //    {
   //       csMyListbox lb(...);
   //       csQuery q(...);
   //       q.open();
   //       PrepareListbox(...);
   //       while ( !q.next() ) {
   //          AddDataToListbox(...);
   //       }
   //       CloseListbox(...);
   //       q.close();
   //    }

   // Sequentielle Abfrage starten (Startposition: Vor dem ersten Datensatz)
   bool open();
   // Sequentielle Abfrage beenden
   void close();
   // An die Position vor den ersten Datensatz springen (wie close & open)
   bool rewind();
   // Zum naechsten Datensatz gehen und diesen laden
   bool fetch();

   // TBD: Support fuer scrolling cursors
   // bool move(int rel_pos);


   // Hierarchische Abfragen
   // ======================

   // Query-Modus: Erfragen der obersten Hierarchiestufe (Default)
   inline void setQueryFromTopLevel()
      { onSetParentKey(cString()); }
   // Query-Modus: Erfragen der Elemente, die sich auf 'parent_key' beziehen
   inline void setQueryFromKey(cString parent_key)
      { onSetParentKey(parent_key); }

   // Liefert true bei "echten" hierarchischen Abfragen (keine Subqueries)
   inline bool isStructured() const
      { return !!(onGetQueryStyle() & qstIsStructured); }
   // Liefert den Schluesselwert des Parent-Elementes (Leerstring fuer Top-Level)
   inline cString getParentKey() const
      { return onGetParentKey(); }


   // Filter
   // ======

   // Filter fuer eine Spalte erfragen
   csFilter *getFilter(int fld) const;
   // Filter fuer eine Spalte setzen
   bool setFilter(int fld, csFilter *filter);
   // Filter fuer eine Spalte wieder zuruecknehmen
   bool removeFilter(int fld);


   // Sortierung
   // ==========

   // Abfrage nach Spalte 'fld' sortieren (dir > 0: Aufsteigend, < 0: Absteigend)
   inline void orderBy(int fld, int dir = 1)
      { onSetOrder(&fld, &dir, 1); }
   // Sortierreihenfolge der Abfrage festlegen
   inline void setOrder(int fld[], int dir[], int count)
      { onSetOrder(fld, dir, count); }


   // Verfuegbarkeit von Informationen
   // ================================
   // Nicht alle Informationen der Query sind zu jeder Zeit verfuegbar.
   // Die folgenden Funktionen geben an, welche Information momentan
   // verfuegbar ist.

   // Ist die Gesamtbeschreibung der Query momentan verfuegbar?
   inline bool hasQueryInfos() const
      { return onCheckAvailability(qciQuery); }
   // Sind die Feldbeschreibungen momentan verfuegbar?
   inline bool hasFieldInfos() const
      { return onCheckAvailability(qciField); }
   // Sind momentan aktuelle Daten eines Datensatzes verfuegbar?
   inline bool hasData() const
      { return onCheckAvailability(qciData); }


   // Gesamtbeschreibung
   // ==================

   // Gesamttitel sichtbar?
   inline bool isTitleVisible() const
      { return !!(onGetQueryStyle() & qstTitleVisible); }
   // Spaltentitel sichtbar?
   inline bool isColumnTitleVisible() const
      { return !!(onGetQueryStyle() & qstColumnTitleVisible); }

   // Name der Abfrage ermitteln
   inline cString getName() const
      { return onGetQueryName(); }
   // ID des Default-Icons fuer Elemente ermitteln
   inline int getDefIconID() const
      { return onGetQueryDefIconID(); }
   // ELO-Elementbeschreibung der Query ermitteln
   inline const cEloElementDescription * getBaseDescription() const
      { return onGetQueryDescription(); }

   // Versucht den Wert des Schluesselfeldes 'key_name' zu ermitteln, ohne
   // dass ein Datensatz geladen sein muss (oder 0 falls nicht ermittelbar)
   inline cString getKeyValue(cString key_name) const
      { return onGetKeyValue(key_name); }


   // Feld- (=Spalten-) beschreibung
   // ==============================
   // Die folgenden Methoden duerfen nur aufgerufen werden, waehrend
   // eine Abfrage laeuft, d.h. zwischen den Events qsStart und qsEnd
   // bzw. zwischen open() und close()

   // Feld-Indizes
   // ------------

   enum FIELD_INDEX {
      fldField  =  0,   // (optional) Felder der Abfrage (n >= 0)
      fldKey    = -1,   // (default)  Schluesselwert des Datensatzes
      fldName   = -2,   // (default)  Name des Datensatzes
      fldDescr  = -3,   // (default)  Kurzbeschreibung des Datensatzes
      fldIconID = -4    // (default)  Dem Datensatz zugeordnetes Icon
   };

   // Eigenschaften der Felder
   // ------------------------

   // Ermittelt die Anzahl der Felder im Datensatz (excl. Default-Felder)
   inline int getFieldCount() const
      { return onGetQueryFieldCount(); }

   // Ermittelt den Typ eines Feldes
   inline TYPE getFieldType(int fld) const
      { return onGetFieldType(fld); }
   // Ermittelt die maximale Groesse eines Feldes
   inline int getFieldBufferSize(int fld) const
      { return onGetFieldBufferSize(fld); }
   // Ermittelt den Namen eines Feldes
   inline cString getFieldName(int fld) const
      { return onGetFieldName(fld); }
   // Darf das Feld einen NULL-Wert enthalten?
   inline bool isFieldNullable(int fld) const
      { return !(onGetFieldStyle(fld) & fstNotNull); }


   // Element-Anzeige
   // ---------------

   enum HALIGN { haLeft, haCenter, haRight };
   enum VALIGN { vaTop, vaCenter, vaBottom };

   // Guenstigste Anzeigebreite [Zeichen] (0=soviel wie noetig)
   inline int getFieldViewSize(int fld) const
      { return onGetFieldViewSize(fld); }
   // Horizontale Ausrichtung
   inline HALIGN getFieldHAlign(int fld) const
      { return onGetFieldHAlign(fld); }
   // Vertikale Ausrichtung
   inline VALIGN getFieldVAlign(int fld) const
      { return onGetFieldVAlign(fld); }
   // Spalte schreibgeschuetzt (nicht editierbar)?
   inline bool isFieldReadOnly(int fld) const
      { return !!(onGetFieldStyle(fld) & fstReadOnly); }
   // Spalte angezeigt?
   inline bool isFieldVisible(int fld) const
      { return !!(onGetFieldStyle(fld) & fstVisible); }
   // Spalte rechts durch vertikalen Separator abgegrenzt?
   inline bool hasFieldSeparator(int fld) const
      { return !!(onGetFieldStyle(fld) & fstSeparator); }
   // Maximale Feldbreite [Zeichen]
   inline int getFieldWidth(int fld) const
      { return onGetFieldWidth(fld); }
   // Anzahl Nachkommastellen [Zeichen]
   inline int getFieldPrec(int fld) const
      { return onGetFieldPrec(fld); }
   // Anzeigeposition: Zeile (-1 falls gleiche Zeile wie voriges Feld)

   inline int getFieldRow(int fld) const
      { return onGetFieldPos(fld, fpiDispRow); }
   // Anzeigeposition: Spalte (-1 falls naechste Spalte)
   inline int getFieldCol(int fld) const
      { return onGetFieldPos(fld, fpiDispCol); }
   // Zellenverbindung senkrecht: Anzahl weiterer Felder (0 = Default)
   inline int getFieldJoinRows(int fld) const
      { return onGetFieldPos(fld, fpiJoinRows); }
   // Zellenverbindung waagrecht: Anzahl weiterer Felder (0 = Default)
   inline int getFieldJoinCols(int fld) const
      { return onGetFieldPos(fld, fpiJoinCols); }

   // Titel-Anzeige
   // -------------

   // Titel der Spalte
   inline cString getTitleText(int fld) const
      { return onGetTitleText(fld); }
   // Horizontale Ausrichtung des Titels
   inline HALIGN getTitleHAlign(int fld) const
      { return onGetTitleHAlign(fld); }
   // Vertikale Ausrichtung des Titels
   inline VALIGN getTitleVAlign(int fld) const
      { return onGetTitleVAlign(fld); }
   // Titel schreibgeschuetzt (nicht editierbar)?
   inline bool isTitleReadOnly(int fld) const
      { return !!(onGetFieldStyle(fld) & fstTitleReadOnly); }
   // Titel durch horizontalen Separator abgegrenzt?
   inline bool hasTitleSeparator(int fld) const
      { return !!(onGetFieldStyle(fld) & fstTitleSeparator); }


   // Erfragefunktionen fuer aktuellen Datensatz
   // ==========================================
   // Die folgenden Methoden duerfen nur aufgerufen werden, wenn ein
   // Datensatz zur Verfuegung steht, d.h. nur beim Event qsData!

   // Datensatz
   // ---------

   // Kann der Datensatz Kind-Elemente haben (strukturierte Abfrage)?
   inline bool mayHaveChilds() const
      { return !!(onGetRecordStyle() & (rstMayHaveChilds | rstHasSubquery)); }
   // Hat der Datensatz eine Subquery zugeordnet?
   inline bool hasSubquery() const
      { return !!(onGetRecordStyle() & rstHasSubquery); }
   // Sollen die Kind-Elemente des Datensatzes automatisch angezeigt werden?
   inline bool mustAutoViewChilds() const
      { return !!(onGetRecordStyle() & rstAutoViewChilds); }
   // Subquery des Datensatzes erzeugen
   inline csQuery *newSubquery() const
      { return onNewRecordSubquery(); }
   // ELO-Elementbeschreibung des Datensatzes ermitteln
   inline const cEloElementDescription * getDescription() const
      { return onGetRecordDescription(); }

   // Laenge (Bytes) der benutzerspezifischen Zusatzinformationen erfragen
   inline int getUserDataLen() const
      { return onGetUserDataLen(); }
   // Benutzerspezifische Zusatzinformation ermitteln
   inline void *getUserData(void *buf, int buf_size) const
      { return onGetUserData(buf, buf_size); }
   // Icon-ID des Datensatzes ermitteln
   inline bool getIconID(int& buf) const
      { return onGetIconID(buf); }

   // Ermittelt den Basisnamen der einem Feld zugrundeliegenden Daten-
   // struktur (z.B. der Datenbank-Tabellenname). Dieser kann sich fuer
   // jeden Datensatz unterscheiden (z.B. bei SQL-UNION-Abfragen)
   inline cString getBaseName(int fld) const
      { return onGetRecordBaseName(fld); }
   // Ermittelt den Basisnamen eines Feldes in der zugrundeliegenden
   // Datenstruktur (z.B. der Datenbank-Feldname). Dieser kann sich fuer
   // jeden Datensatz unterscheiden (z.B. bei SQL-UNION-Abfragen)
   inline cString getBaseFieldName(int fld) const
      { return onGetRecordBaseFieldName(fld); }


   // Feldwerte
   // ---------

   // Hat das Feld einen NULL-Wert?
   inline bool isNull(int fld) const
      { return onGetNull(fld); }

   // Ermittelt den int-Wert eines Feldes
   bool get(int fld, int& buf) const;
   // Ermittelt den double-Wert eines Feldes
   bool get(int fld, double& buf) const;
   // Ermittelt den cTime-Wert eines Feldes
   bool get(int fld, cTime& buf) const;
   // Ermittelt den cDate-Wert eines Feldes
   bool get(int fld, cDate& buf) const;
   // Ermittelt den cDateTime-Wert eines Feldes
   bool get(int fld, cDateTime& buf) const;
   // Ermittelt den char-Wert eines Feldes
   bool get(int fld, char& buf) const;
   // Ermittelt den cString-Wert eines Feldes
   bool get(int fld, cString& buf) const;
   // Ermittelt die String-Repraesentation eines Feldes
   bool get(int fld, char *buf, int size) const;
   // Ermittelt den cIcon-Wert eines Feldes
   bool get(int fld, cIcon& buf) const;
   // Ermittelt den cBitmap-Wert eines Feldes
   bool get(int fld, cBitmap& buf) const;


   // Freigabesperre
   // ==============

   // Abfrage wird benutzt und darf bis auf weiteres nicht freigegeben werden
   void requestLock();
   // Abfrage wird nicht laenger benutzt und kann freigegeben werden
   void releaseLock(bool delete_now = false);


protected:

   // Zusaetzliche Events
   // ===================

   // Ereignisgesteuerte Abfragesteuerung
   // -----------------------------------

   // Wird aufgerufen, um ereignisgesteuerte Abfrage zu starten
   virtual bool onStart(const EVENT& event);
   // Wird aufgerufen, um ereignisgesteuerte Einzelabfrage zu starten
   virtual bool onStart1(const EVENT& event, cString key);
   // Wird aufgerufen zum vorzeitigen Beenden der Abfrage
   virtual bool onStop();

   // Wird aufgerufen, bevor Abfrage beginnt (vor erstem DS)
   virtual void onQueryStart(const EVENT& event);
   // Wird aufgerufen, wenn naechster Datensatz bereit
   virtual bool onQueryData(const EVENT& event);
   // Wird aufgerufen, wenn Abfrage beendet (nach letztem DS)
   virtual void onQueryEnd(const EVENT& event);


   // Sequentielle Abfragesteuerung
   // -----------------------------

   // Wird aufgerufen, um sequentielle Abfrage zu starten
   virtual bool onOpen();
   // Wird aufgerufen, um sequentielle Abfrage zu beenden
   virtual void onClose();
   // Wird aufgerufen, um an die Position vor dem ersten Datensatz zu springen
   virtual bool onRewind() = 0;
   // Wird aufgerufen, um zum naechsten Datensatz zu gehen und diesen laden
   virtual bool onFetch() = 0;


   // Hierarchische Abfragen
   // ----------------------

   // Wird aufgerufen, um den Schluessel des Parent-Elementes zu setzen
   void onSetParentKey(cString parent_key);
   // Wird aufgerufen, um den Schluessel des Parent-Elementes zu erfragen
   cString onGetParentKey() const;


   // Verfuegbarkeit von Informationen
   // --------------------------------

   // Moegliche Informationen
   enum QUERY_INFOS {
      qciQuery                = 0x0001,   // Gesamtbeschreibung verfuegbar?
      qciField                = 0x0002,   // Feldbeschreibungen verfuegbar?
      qciData                 = 0x0004    // Aktuelle Daten verfuegbar?
   };

   // Wird aufgerufen, um die aktuelle Verfuegbarkeit zu pruefen
   virtual bool onCheckAvailability(QUERY_INFOS qci) const;


   // Manipulation von Datensaetzen
   // -----------------------------

   // Wird aufgerufen, um den Schluesselwert eines neuen Datensatzes zu ermitteln
   virtual cString onGetNewRowKey() const;
   // Wird aufgerufen, wenn ein Datensatz hinzugefuegt wurde
   virtual void onRowAdded(csRow *row);
   // Wird aufgerufen, wenn sich ein Datensatz geaendert hat
   virtual void onRowChanged(csRow *row);
   // Wird aufgerufen, wenn ein Datensatz entfernt wurde
   virtual void onRowRemoved(csRow *row);


   // Sortierung
   // ----------

   // Wird aufgerufen, um die Sortierreihenfolge der Abfrage festzulegen
   virtual void onSetOrder(int *fld, int *dir, int count);


   // Beschreibung
   // ------------

   // Gesamtbeschreibung der Abfrage
   enum QUERY_STYLE {
      qstTitleVisible         = 0x0001,   // Gesamttitel sichtbar?
      qstColumnTitleVisible   = 0x0002,   // Spaltentitel sichtbar?
      qstIsStructured         = 0x0004    // Hierarchische Abfrage?
   };

   // Wird aufgerufen, um die Anzahl Felder im Datensatz zu ermitteln
   virtual int onGetQueryFieldCount() const;
   // Wird aufgerufen, um die Gesamtbeschreibung der Abfrage zu ermitteln (QUERY_STYLE)
   virtual int onGetQueryStyle() const;
   // Wird aufgerufen, um das Default-Icon fuer die Elemente der Abfrage zu ermitteln
   virtual cString onGetQueryName() const;
   // Wird aufgerufen, um die ID des Default-Icons fuer die Elemente der Abfrage zu ermitteln
   virtual int onGetQueryDefIconID() const;
   // Wird aufgerufen, um die ELO-Elementbeschreibung der Query zu ermitteln
   virtual const cEloElementDescription * onGetQueryDescription() const;
   // Wird aufgerufen, um den Wert des Schluesselfeldes 'key_name' zu ermitteln
   virtual cString onGetKeyValue(cString key_name) const;


   // Beschreibung des Datensatzes
   enum RECORD_STYLE {
      rstMayHaveChilds     = 0x0001,   // Kann der Datensatz Child-Elemente haben?
      rstHasSubquery       = 0x0002,   // Hat der Datensatz eine Subquery?
      rstAutoViewChilds    = 0x0004    // Child-Element automatisch anzeigen?
   };

   // Wird aufgerufen, um die Beschreibung des Datensatzs zu ermitteln (RECORD_STYLE)
   virtual int onGetRecordStyle() const;
   // Wird aufgerufen, um eine (neue) Subquery des Datensatzes zu erzeugen
   virtual csQuery *onNewRecordSubquery() const;
   // Wird aufgerufen, um die ELO-Elementbeschreibung des Datensatzes zu ermitteln
   virtual const cEloElementDescription * onGetRecordDescription() const;

   // Wird aufgerufen, um die Laenge (Bytes) der benutzerspezifischen Zusatzinformationen erfragen
   virtual int onGetUserDataLen() const;
   // Wird aufgerufen, um die benutzerspezifischen Zusatzinformation zu ermitteln
   virtual void *onGetUserData(void *buf, int buf_size) const;
   // Wird aufgerufen, um die Icon-ID des Datensatzes zu lesen
   virtual bool onGetIconID(int& buf) const;

   // Beschreibung eines Feldes
   enum FIELD_STYLE {
      fstReadOnly          = 0x0001,   // Spalte schreibgeschuetzt (nicht editierbar)?
      fstVisible           = 0x0002,   // Spalte angezeigt?
      fstSeparator         = 0x0004,   // Spalte durch vertikalen Separator abgegrenzt?
      fstTitleReadOnly     = 0x0008,   // Titel schreibgeschuetzt (nicht editierbar)?
      fstTitleSeparator    = 0x0010,   // Titel durch horizontalen Separator abgegrenzt?
      fstNotNull           = 0x0020    // Darf das Feld keine NULL-Wert enthalten?
   };

   // Wird aufgerufen, um die Beschreibung einer Spalte zu ermitteln (FIELD_STYLE)
   virtual int onGetFieldStyle(int fld) const;
   // Wird aufgerufen, um den Typ eines Feldes zu ermitteln
   virtual TYPE onGetFieldType(int fld) const;

   // Wird aufgerufen, um die horizontale Ausrichtung zu ermitteln
   virtual HALIGN onGetFieldHAlign(int fld) const;
   // Wird aufgerufen, um die vertikale Ausrichtung zu ermitteln
   virtual VALIGN onGetFieldVAlign(int fld) const;

   // Wird aufgerufen, um den Namen eines Feldes zu ermitteln
   virtual cString onGetFieldName(int fld) const;
   // Wird aufgerufen, um den Titel der Spalte zu ermitteln
   virtual cString onGetTitleText(int fld) const;
   // Wird aufgerufen, um die horizontale Ausrichtung des Titels zu ermitteln
   virtual HALIGN onGetTitleHAlign(int fld) const;
   // Wird aufgerufen, um die vertikale Ausrichtung des Titels zu ermitteln
   virtual VALIGN onGetTitleVAlign(int fld) const;

   // Wird aufgerufen, um den Tabellennamen eines Feldes zu ermitteln
   virtual cString onGetRecordBaseName(int fld) const;
   // Wird aufgerufen, um den Basisnamen eines Feldes zu ermitteln
   virtual cString onGetRecordBaseFieldName(int fld) const;

   // Wird aufgerufen, um die maximale Groesse eines Feldes zu ermitteln
   virtual int onGetFieldBufferSize(int fld) const;
   // Wird aufgerufen, um die guenstigste Anzeigebreite zu ermitteln
   virtual int onGetFieldViewSize(int fld) const;
   // Wird aufgerufen, um die maximale Feldbreite zu ermitteln
   virtual int onGetFieldWidth(int fld) const;
   // Wird aufgerufen, um die Anzahl Nachkommastellen zu ermitteln
   virtual int onGetFieldPrec(int fld) const;


   // Positionsinformation
   enum FIELD_POSINFO {
      fpiDispRow     = 1,  // Anzeigezeile des Feldes (-1 = Default)
      fpiDispCol     = 2,  // Anzeigespalte des Feldes (-1 = Default)
      fpiJoinRows    = 3,  // Anzahl zu verbindender Zellen senkrecht
      fpiJoinCols    = 4   // Anzahl zu verbindender Zellen waagrecht
   };

   // Wird aufgerufen, um Positionsinformationen ueber das Feld zu ermitteln
   virtual int onGetFieldPos(int fld, FIELD_POSINFO fpi) const;


   // Werte erfragen
   // --------------

   // Wird aufgerufen, um den NULL-Zustand des Feldes zu ermitteln
   virtual bool onGetNull(int fld) const;

   // Wird aufgerufen, um einen int-Wert aus Feld 'fld' zu lesen
   virtual bool onGetInt(int fld, int& buf) const;
   // Wird aufgerufen, um einen double-Wert aus Feld 'fld' zu lesen
   virtual bool onGetDouble(int fld, double& buf) const;
   // Wird aufgerufen, um einen cTime-Wert aus Feld 'fld' zu lesen
   virtual bool onGetTime(int fld, cTime& buf) const;
   // Wird aufgerufen, um einen cDate-Wert aus Feld 'fld' zu lesen
   virtual bool onGetDate(int fld, cDate& buf) const;
   // Wird aufgerufen, um einen cDateTime-Wert aus Feld 'fld' zu lesen
   virtual bool onGetDateTime(int fld, cDateTime& buf) const;
   // Wird aufgerufen, um einen char-Wert aus Feld 'fld' zu lesen
   virtual bool onGetChar(int fld, char& buf) const;
   // Wird aufgerufen, um einen cString-Wert aus Feld 'fld' zu lesen
   virtual bool onGetString(int fld, cString& buf) const = 0;
   // Wird aufgerufen, um einen cIcon-Wert aus Feld 'fld' zu lesen
   virtual bool onGetIcon(int fld, cIcon& buf) const;
   // Wird aufgerufen, um einen cBitmap-Wert aus Feld 'fld' zu lesen
   virtual bool onGetBitmap(int fld, cBitmap& buf) const;


   // Vereinfachte Query-Implementierung
   // ==================================
   // Zur leichteren Realisierung von einfachen Abfragen kann die Default-
   // Implementierung von onStart() herangezogen werden. Dazu muss die
   // Methode onLoop() ueberschrieben werden und immer, wenn eine neuer
   // Datensatz bereit steht, die Methode signalDataReady() aufgerufen
   // werden.
   //
   // class csMyQuery : csQuery {
   //    int actual;
   //    ...
   //    bool onLoop(const EVENT& event)
   //    {
   //       for ( actual = 0 ; actual < MAX  ; actual++ ) {
   //          if ( getFlags(fStopReq) )
   //             break;
   //          if ( !signalDataReady(event) )
   //             return false;
   //       }
   //       return true;
   //    }
   //    ...
   //    bool onGetString(int fld, cString& buf) const
   //    {
   //       buf = my_buffer[actual];
   //       return true;
   //    }
   // };

   // Wird aufgerufen, um die Hauptschleife der Abfrage zu realisieren
   virtual bool onLoop(const EVENT& event);
   // Muss von onLoop aufgerufen werden, um einen neuen Datensatz zu signalisieren
   bool signalDataReady(const EVENT& event);


protected:

   // Filterverwaltung
   // ================

   // Filtertabelle generieren
   bool installFilter(int field_count);
   // Filtertabelle verwerfen
   bool deinstallFilter();
   // Filterfunktion fuer Textfeld ausfuehren
   void callFilter(int fld, cString& text) const;
   // Filterfunktion fuer Icon-Feld ausfuehren
   void callFilter(int fld, cString key, cIcon& icon) const;
   // Filterfunktion fuer Bitmap-Feld ausfuehren
   void callFilter(int fld, cString key, cBitmap& bmp) const;
   // Maximale Feldgroesse nach Filterung berechnen
   int getFilteredBufferSize(int fld, int size) const;


private:

   struct FILTER_LIST {
      int fld;
      csFilter *filter;
      FILTER_LIST *next;
   };

   FILTER_LIST *flist_anchor;
   csFilter **filter_tab;
   cString parent_key;           // Parent-Key fuer hierarchische Abfragen

   STATE state;                  // Aktueller Zustand der Abfrage
   int lock_count;               // Zaehler fuer Freigabesperre

};


// ===========================================================================
// Definition csEnumQuery
// ---------------------------------------------------------------------------
//
// Einfache Abfrage, deren Elemente leicht ueber den Konstruktor definiert
// werden koennen. So kann z.B. eine Abfrage, welche die Namen der Wochentage
// "Montag".."Sonntag" liefert und als zugehoerige Schluessel die Werte 0..6
// erzeugt werden durch:
//
//    csEnumQuery *query = new csEnumQuery("Montag", "Dienstag", "Mittwoch",
//       "Donnerstag", "Freitag", "Samstag", "Sonntag", NULL);
//
// Die Schluesselelemente werden numerisch und in aufsteigender Reihenfolge ver-
// geben, beginnend mit 0. Sollen von dieser Vorschrift abweichende Schluessel
// benutzt werden, kann dies ueber "kodierte" Namen folgendermassen erfolgen:
//
//    csEnumQuery *query = new csEnumQuery("MON$Montag", "TUE$Dienstag",
//       "WED$Mittwoch", "THU$Donnerstag", "FRI$Freitag",
//       "SAT$Samstag", "SUN$Sonntag", NULL);
//
// cBase
//  +--csBaseStorage
//      +--csQuery
//          +--csEnumQuery
//
// ===========================================================================

class __ECL_DLLEXPORT__ csEnumQuery : public csQuery {
   ECL_DECLARE(csEnumQuery,csQuery)

public:

   // Konstruktor aus variabler Anzahl Strings
   csEnumQuery(const char *_str1, ...);
   // Konstruktor aus Flag und variabler Anzahl Strings
   csEnumQuery(int _flags, const char *_str1, ...);
   // Konstruktor aus Flag, Maximalgroessen und variabler Anzahl Strings
   csEnumQuery(int _flags, int max_key, int max_name, int max_descr, const char *_str1, ...);
   // Copy-Konstruktor
   csEnumQuery(const csEnumQuery& other);
   // Destruktor
   ~csEnumQuery();


   // Flags
   // =====

   enum FLAGS { fStart = csQuery::fUser,
      fEncodedKeys = fStart << 0,  // Schluessel in Enums kodiert: "key$name"
      fInclDescr   = fStart << 1,  // Jeder zweite Parameter enthaelt Beschr.
      fUser        = fStart << 2   // Benutzerdefinierte Flags
   };


protected:

   // Wird aufgerufen, um an die Position vor dem ersten Datensatz zu springen
   bool onRewind();
   // Wird aufgerufen, um zum naechsten Datensatz zu gehen und diesen laden
   bool onFetch();
   // Wird aufgerufen, um die maximale Groesse eines Feldes zu ermitteln
   int onGetFieldBufferSize(int fld) const;
   // Wird aufgerufen, um einen cString-Wert aus Feld 'fld' zu lesen
   bool onGetString(int fld, cString& buf) const;


protected:

   // Konstruktor ueber Flags (nur fuer Ableitungen)
   csEnumQuery(int flags);
   // Initialisierung ueber variable Argumentliste (nur fuer Ableitungen)
   void init(const char *str1, va_list arg_ptr);

   // Wert fuer maixmale Schluesselgroesse vorbelegen
   void setMaxKeySize(int max)
      { max_key_size = max; }
   // Wert fuer maixmale Namensgroesse vorbelegen
   void setMaxNameSize(int max)
      { max_name_size = max; }
   // Wert fuer maixmale Beschreibungsgroesse vorbelegen
   void setMaxDescrSize(int max)
      { max_descr_size = max; }


private:

   struct NODE {
      NODE() { }
      NODE(int _key, const char *_name, const char *_descr, bool _encoded_keys);
      char key[12];
      cString name, descr;
      NODE *next;
   };
   NODE *anchor, *actual;
   int max_key_size, max_name_size, max_descr_size;

};


#endif

/*.EH.*/
