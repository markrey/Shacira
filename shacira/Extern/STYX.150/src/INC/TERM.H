/* ------------------------------------------------------------------------ */
/*                                                                          */
/* [term.h]                       Type: Term                                */
/*                                                                          */
/* Copyright (c) 1993 by D\olle, Manns                                      */
/* ------------------------------------------------------------------------ */

/* File generated by 'ctoh'. Don't change manually. */

#ifndef term_INCL
#define term_INCL


#include "otab.h"


#ifdef __cplusplus
extern "C" {
#endif


/* ------------------------ Types and Constants ----------------------------- */

/* Most of the Functions assume, that the Term Parameter has a */
/* unique Root Node, which has no 'next'-Node.                 */

AbstractType(DT_Term); /* Abstract Term         Type */
AbstractType(DT_Mode); /* Abstract TermType     Type */
AbstractType(DT_Val);  /* Abstract TermValue    Type */
AbstractType(DT_Pos);  /* Abstract TermPosition Type */
AbstractType(DT_Itr);  /* Abstract TermIterator Type */

/* ----------------------- Construct and Delete ----------------------------- */

/* without New & Copy */

DT_Term DT_createV(DT_Mode mode, DT_Val value, DT_Pos pos)
/* creates value term */
;

DT_Term DT_createT(DT_Mode mode, DT_Term term, DT_Pos pos)
/* creates term with subterm */
;

DT_Pos DT_updPos(DT_Term term, DT_Pos pos)
/* updates position, returns old position */
;

DT_Term DT_consT(DT_Term left, DT_Term right); /* concats left and right    */

void DT_delT(DT_Term term, void (*del_term)(DT_Term term))
/* deletes term ( del_term only deletes term attributes ) */
;


/* ----------------------- Access / Information ----------------------------- */

c_bool  DT_isTerm(DT_Term term);       /* term has subterm ?                */
DT_Mode DT_mode(DT_Term term);         /* term type ( mode )                */
DT_Val  DT_val(DT_Term term);          /* term value ( ! DT_isTerm(term) )  */
DT_Pos  DT_pos(DT_Term term);          /* term value position               */
DT_Term DT_next(DT_Term term);         /* next ( right ) term               */
DT_Term DT_parts(DT_Term term);        /* left subterm ( DT_isTerm(term) )  */

/* ----------------------------- Get and Search ----------------------------- */

int DT_cntST(DT_Term term, c_bool (*filter)(DT_Term term))
/* number of subterms t with filter(t) = False */
;

DT_Term DT_nthST(DT_Term term, int nth, c_bool (*filter)(DT_Term term))
/* nth subterm t with filter(t) = False [1..DT_cntST(term)] */
;

DT_Term DT_r_findT
        (
          DT_Term term, c_bool (*pred)(DT_Term term, StdCPtr any), StdCPtr any
        )
/* subterm t with (*pred)(t,any) = True ( recursive ) */
;

DT_Term DT_l_findT
        (
          DT_Term term, c_bool (*pred)(DT_Term term, StdCPtr any), StdCPtr any
        )
/* subterm t with (*pred)(t,any) = True ( not recursive ) */
;


/* -------------------------- Term Iterator --------------------------------- */

#define DT_ROOT           0
#define DT_PRAE           1
#define DT_POST           2

DT_Itr  DT_createIT(DT_Term term);  /* creates term iterator                */
c_bool  DT_getIT(DT_Itr iter);      /* next term in prae/post order         */
void    DT_skipIT(DT_Itr iter);     /* skips subterms                       */
short   DT_stateIT(DT_Itr iter);    /* current status ( DT_PRAE / DT_POST ) */
DT_Term DT_termIT(DT_Itr iter);     /* current term                         */
OT_Tab  DT_stackIT(DT_Itr iter);    /* current iterator stack               */
void    DT_delIT(DT_Itr iter);      /* deletes term iterator                */

#define DT_FORALL(it,tr)  for( (it) = DT_createIT(tr); \
                               DT_getIT(it) ? C_True : ( DT_delIT(it), C_False ); )
#define DT_BREAK(it)      { DT_delIT(it); break; }

/* -------------------------- Term Predicates ------------------------------- */

c_bool DT_equalT
     (
       DT_Term left, DT_Term right,
       c_bool (*cmpEQ)(DT_Term left, DT_Term right),
       DT_Term (*filter)(DT_Term term)
     )
/* left = right ? */
;

c_bool DT_subT
     (
       DT_Term left, DT_Term right,
       c_bool (*cmpEQ)(DT_Term left, DT_Term right),
       DT_Term (*filter)(DT_Term term)
     )
/* left <= right ? */
;


/* ---------------------------- Printing ------------------------------------ */

void DT_printT(DT_Term term, void (*pMember)(DT_Term term), int indent)
/* prints term */
;



#ifdef __cplusplus
}
#endif

#endif
